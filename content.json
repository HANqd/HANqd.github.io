{"meta":{"title":"HANqd's BLOG","subtitle":"一个刚进军安全的小白。","description":null,"author":"HANqd","url":"https://hanqd.github.io","root":"/"},"pages":[],"posts":[{"title":"pwn-栈溢出（1）","slug":"20190402","date":"2019-04-02T12:10:40.857Z","updated":"2019-04-02T12:11:40.676Z","comments":true,"path":"2019/04/02/20190402/","link":"","permalink":"https://hanqd.github.io/2019/04/02/20190402/","excerpt":"栈溢出简介计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。为了实现栈溢出，要满足两个条件。","text":"栈溢出简介计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。为了实现栈溢出，要满足两个条件。 第一，程序要有向栈内写入数据的行为； 第二，程序并不限制写入数据的长度。 历史上第一例被广泛注意的“莫里斯蠕虫”病毒就是利用C语言标准库的 gets() 函数并未限制输入数据长度的漏洞，从而实现了栈溢出。 背景知识-函数调用栈函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。 函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。 函数调用发生和结束时调用栈的变化 函数状态主要涉及三个寄存器－－esp，ebp，eip。 esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。 ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。 eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。 下面是发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。 （1）子过程参数入栈：首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。（2）调用函数（父过程）的返回地址入栈：将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。（在执行完调用函数后回到主函数，能够继续执行主函数指令的指令地址）（3）将调用函数的基地址（ebp）入栈，并将当前栈顶地址传到ebp寄存器：将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。（4）将被调用函数的局部变量压入栈内在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。 函数调用结束时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。（1） 将被调用函数的局部变量弹出栈外：首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。（2）将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内：将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的 ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。（3）将调用函数的返回地址弹出栈外，并存到 eip 寄存器内总过程总结为下图： 技术清单当函数正在执行内部指令的过程中无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 eip，所以目标就是让 eip 载入攻击指令的地址。 函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？ 首先，在退栈过程中，返回地址会被传给 eip，所以只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。 其次，可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。 函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？ 这时，eip 会指向原程序中某个指定的函数，没法通过改写返回地址来控制了，不过可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。 一共包括下面的四种情况： 修改返回地址，让其指向溢出数据中的一段指令（shellcode） 修改返回地址，让其指向内存中已有的某个函数（return2libc） 修改返回地址，让其指向内存中已有的一段指令（ROP） 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT） Shellcode(修改返回地址，让其指向溢出数据中的一段指令) 要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。shellcode 可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴。下面是溢出数据的组成，shellcode 所用溢出数据的构造。payload : padding1 + address of shellcode + padding2 + shellcode padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。 返回地址之前的填充数据（padding1）应该多长？ 我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。一般是缓冲区大小+ebp大小 [esp-0x100],32位机器时，ebp为4字节，所以填充数据大小为：0x100+4=300个字节 shellcode起始地址应该是多少？ 可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。 操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。","categories":[],"tags":[]},{"title":"每日一题 1009+vector容器","slug":"20190401","date":"2019-04-01T09:34:28.033Z","updated":"2019-04-01T09:35:48.721Z","comments":true,"path":"2019/04/01/20190401/","link":"","permalink":"https://hanqd.github.io/2019/04/01/20190401/","excerpt":"1009 说反话题目描述给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。","text":"1009 说反话题目描述给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 题目分析输入样例：Hello World Here I Come输出样例：Come I Here World Hello由样例，可以想到用栈来解决，符合栈的先进后出的特点，还可以用vactor容器解决。 C++代码方法一：123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; char c; stack&lt;string&gt; s; //声明一个string类型的栈变量s string str; while(cin&gt;&gt;str) &#123; s.push(str);//str入栈 if((c=getchar())==&apos;\\n&apos;) break;//c接收入栈的单个字符，判断是否输入完毕 &#125; cout&lt;&lt;s.top();//输出栈顶元素 s.pop();//栈顶元素出栈 while(!s.empty()) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;s.top();//循环输出栈顶元素 s.pop();//栈顶元素出栈 &#125; return 0;&#125; getchar()函数作用：getchar()是到缓冲区读取第一个字符首先,从键盘输入许多字符,最后回车后,所有字符包括回车放到缓冲区这时才开始循环执行getchar(),读入一个字符判断是否回车,不是就继续读,是回车就退出循环(之所以说是顺序接受一行字符,是因为它取的始终是缓冲区中第一个字符,每取一个缓冲区的字符少一个,也就是顺序读取了) 方法二：vactor12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;int main ()&#123; char c; vector&lt;string&gt; v;//相当于string v[]，数组长度不定 string str; while(cin&gt;&gt;str) &#123; v.insert(v.begin(),str);//向容器v中存入str字符串 if((c=getchar())==&apos;\\n&apos;) break; &#125; vector&lt;string&gt;::iterator i=v.begin(),end=v.end();//i指向v的首地址，区间是到最后一个元素 for(int j=v.size();j&gt;0;j--) &#123; cout&lt;&lt;*i;//输出i指针指向的内容 if(j!=1) cout&lt;&lt;&quot; &quot;; i++; &#125; return 0;&#125; vector(向量)C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的. 用法: 文件包含:首先在程序开头处加上#include (vector)以包含所需要的类文件vector还有一定要加上using namespace std; 变量声明:2.1 例:声明一个int向量以替代一维的数组:vector (int) a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。2.2 例:用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector (int *) a.同理想用向量代替三维数组也是一样,vector (int**)a;再往上面依此类推. 具体的用法以及函数调用: push_back 在数组的最后添加一个数据 pop_back 去掉数组的最后一个数据 at 得到编号位置的数据 begin 得到数组头的指针 end 得到数组的最后一个单元+1的指针 front 得到数组头的引用 back 得到数组的最后一个单元的引用 max_size 得到vector最大可以是多大 capacity 当前vector分配的大小 size 当前使用数据的大小 resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 reserve 改变当前vecotr所分配空间的大小 erase 删除指针指向的数据项 clear 清空当前的vector rend 将vector反转构的结束指针返回(其实就是原来的begin-1) empty 判断vector是否为空 swap 与另一个vector交换数据 详细的函数实现功能：其中vector c. c.clear() 移除容器中所有数据。 c.empty() 判断容器是否为空。 c.erase(pos) 删除pos位置的数据 c.erase(beg,end) 删除[beg,end)区间的数据 c.front() 传回第一个数据。 c.insert(pos,elem) 在pos位置插入一个elem拷贝 c.pop_back() 删除最后一个数据。 c.push_back(elem) 在尾部加入一个数据。 c.resize(num) 重新设置该容器的大小 c.size() 回容器中实际数据的个数。 c.begin() 返回指向容器第一个元素的迭代器 c.end() 返回指向容器最后一个元素的迭代器 iteratoriterator是C++标准库（STL）中的迭代器可以把它理解成类似指针的东西~当然，只是用处差不多，使用方式和声明方式可是完全不同.","categories":[],"tags":[]},{"title":"每日一题 1008+pwn学习","slug":"每日一题1008","date":"2019-03-31T13:02:45.449Z","updated":"2019-03-31T13:03:40.801Z","comments":true,"path":"2019/03/31/每日一题1008/","link":"","permalink":"https://hanqd.github.io/2019/03/31/每日一题1008/","excerpt":"1008 数组元素循环右移问题题目描述一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移","text":"1008 数组元素循环右移问题题目描述一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0 A1⋯AN−1）变换为（AN−M ⋯AN−1 A0 A1 ⋯AN−M−1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 题目分析方法一：可以直接在输入时改变输入顺序方法二：用数据结构中的链表中的reverse函数，进行反转注意：这里有m&gt;n的情况，需要对m进行处理，m=m%n，这样数组才不会出错。 C++代码方法一：1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int a[101]; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&gt;n) &#123; m=m%n; &#125; for(int i=m;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n-1;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;a[n-1]; return 0;&#125; 方法二：1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int *p=new int[n];//分配一块长度为n的内存，指针p指向这个数组的首址 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i]; &#125; m=m%n; reverse(p,p+n-m);//前n-m个数反转，由1 2 3 4-&gt;4 3 2 1 reverse(p+n-m,p+n);//后面的数反转，由5 6 -&gt;6 5 reverse(p,p+n);//n个数全反转 4 3 2 1 6 5 -&gt;5 6 1 2 3 4 for(int i=0;i&lt;n-1;i++) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;p[n-1]; return 0;&#125; pwn学习从网上找了CTF关于pwn的解题类型，看了一些大佬的博客，对Ubuntu配置pwn的环境，可是！！各种包都按不上，更新源也出错，找了好多大学的替换源，也还是出错。。。。。明天再弄！","categories":[],"tags":[]},{"title":"每日一题 1007+Misc Another 01Game","slug":"每日一题","date":"2019-03-30T13:53:16.208Z","updated":"2019-03-30T13:55:49.572Z","comments":true,"path":"2019/03/30/每日一题/","link":"","permalink":"https://hanqd.github.io/2019/03/30/每日一题/","excerpt":"Another 01Game题目描述题目给了一个txt文件，里边只有01串。","text":"Another 01Game题目描述题目给了一个txt文件，里边只有01串。 解题思路题目给了思路：0和1的数量很关键，首先统计0和1的数量：1369.0/7 = 195.571428571428581369.0/8 = 171.1251369.0 ** 0.5 = 37.01369不是7和8的倍数，说明很可能和ASCII没关系。1369 是 37 的平方，说明可以由0和1正好组成一个正方形（二维码，QR code）。可以使用Python、MATLAB 等编程生成图片。扫描得到 另一个01字符串。统计字符串长度，可以当作 ASCII 编程解出 flag。 解题脚本12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonimport qrcodeqr = qrcode.QRCode( version = 7, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=4)qr.add_data('''0000000111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110''')qr.make(fit=True)img = qr.make_image()img.save(\"test.png\") 扫码还是得到01字符串，有189个01，根据题目提示，每7个一组，前面加0，用ASCLL码解码即可。注意：flag中0和O的输入！！！ 1007 素数对猜想题目描述让我们定义dn为：dn=pn+1−pn，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N(&lt;10^5)，请计算不超过N的满足猜想的素数对的个数。 输入格式输入在一行给出正整数N。 输出格式在一行中输出不超过N的满足猜想的素数对的个数。 题目分析算法很简单，就是先判断是否是素数，在相邻的两个数相减，为2则个数加1. C++代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int count=0; int a=2,b=3; for(int i=5;i&lt;=n;i++) &#123; bool t=true; for(int j=2;j&lt;=sqrt(i);j++) &#123; if(i%j==0) &#123; t=false; break; &#125; &#125; if(t) &#123; a=b; b=i; if((b-a)==2) count++; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"每日一题 1006","slug":"每日一题1006","date":"2019-03-29T02:35:28.127Z","updated":"2019-03-29T02:37:13.602Z","comments":true,"path":"2019/03/29/每日一题1006/","link":"","permalink":"https://hanqd.github.io/2019/03/29/每日一题1006/","excerpt":"1006 换个格式输出整数题目描述让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。","text":"1006 换个格式输出整数题目描述让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式每个测试用例的输出占一行，用规定的格式输出 n。 题目分析这是一道水题，分别用三个变量记录个、十、百位的数字，再分别输出即可。 C++代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int b,s,g; b=n/100; s=(n/10)%10; g=n%10; for(int i=0;i&lt;b;i++) &#123; cout&lt;&lt;\"B\"; &#125; for(int i=0;i&lt;s;i++) &#123; cout&lt;&lt;\"S\"; &#125; for(int i=1;i&lt;=g;i++) &#123; cout&lt;&lt;i; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Misc：Forensics2（流量分析题）","slug":"Misc Forensics2","date":"2019-03-28T12:37:55.193Z","updated":"2019-03-28T12:38:57.870Z","comments":true,"path":"2019/03/28/Misc Forensics2/","link":"","permalink":"https://hanqd.github.io/2019/03/28/Misc Forensics2/","excerpt":"Forensics2题目描述题目给了一个.pcap文件，给了一句提示：是关于文件的。","text":"Forensics2题目描述题目给了一个.pcap文件，给了一句提示：是关于文件的。 题目分析 用wireshark软件打开文件，发现有很多协议，之前学的网络的知识也忘得差不多了。。。。决定先了解一下各个协议的功能。 ICMP：ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。在网络层。 ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。在网络层。 TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。在运输层。 SSH：SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过使用SSH，可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。 NFS：NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。在应用层 portmap端口映射是一个服务器，将RPC程序号转换为DARPA的协议端口号，在使用RPC调用时它必须运行。portmap进程的主要功能是把RPC程序号转化为Internet的端口号。 mount在Windows系统下的含义是：挂载文件到一个虚拟盘或一个虚拟文件夹中，通过访问这个虚拟盘或文件夹使用整个文件。 根据上述协议的功能和定义，猜测要找的文件在NFS协议共享的资源中，运用了SSH协议进行了加密。 对NFS协议进行过滤，如下图，找到flag.txt.gz，是一个压缩包形式。 在这条协议附件逐个分析每条协议传输的信息，最后在write那条中找到了data. 在data处右键-》显示分组字节-》选择压缩，即可得到flag。","categories":[],"tags":[]},{"title":"每日一题 1005","slug":"每日一题1005","date":"2019-03-28T07:28:08.741Z","updated":"2019-03-28T07:29:30.716Z","comments":true,"path":"2019/03/28/每日一题1005/","link":"","permalink":"https://hanqd.github.io/2019/03/28/每日一题1005/","excerpt":"1005 继续(3n+1)猜想题目描述卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。","text":"1005 继续(3n+1)猜想题目描述卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 题目分析输入样例：63 5 6 7 8 11输出样例：7 6根据输入和输出样例，可以看出，在验证3时，需要计算5、8、4、2，那么这四个数被3覆盖了，就不是关键数。6需要计算11，那么11不是关键数，6没有被输入的数覆盖，所以6是关键数。这道题就是输出在输入的数的计算过程中没有出现过的数。思路：把输入的值当做数组下标，这个以输入值作为下标的数组记录这个值出现的次数，在计算过程中没出现过，数组值设为1，出现过，数组值设为2。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n]; int xiabiao[101]=&#123;0&#125;; int keynum[100001]=&#123;0&#125;; int count=0,temp; //输入n个数 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; int m=a[i]; //下标=数组值 if(xiabiao[m]==2) &#123; continue;//数组值出现过，即被某个数所覆盖 &#125; else xiabiao[m]=1;//没出现过的置1 while(m!=1) &#123; if(m%2==0) &#123; m=m/2; xiabiao[m]=2; &#125; else &#123; m=(m*3+1)/2; xiabiao[m]=2; &#125; &#125; &#125; //把xiabiao[]数组中值为1的存入另一个数组keynum[]，即所求的关键数 for(int i=0;i&lt;101;i++) &#123; if(xiabiao[i]==1) &#123; keynum[count]=i; count++; &#125; &#125; //对关键字排序，降序 for(int i=0;i&lt;count;i++) &#123; for(int j=i+1;j&lt;count;j++) &#123; if(keynum[i]&lt;keynum[j]) &#123; temp=keynum[i]; keynum[i]=keynum[j]; keynum[j]=temp; &#125; &#125; &#125; for(int k=0;k&lt;count-1;k++) &#123; cout&lt;&lt;keynum[k]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;keynum[count-1]; return 0;&#125;","categories":[],"tags":[]},{"title":"CTF逆向reverse：Reverse sign in","slug":"reverse1","date":"2019-03-28T02:52:16.969Z","updated":"2019-03-28T02:57:29.140Z","comments":true,"path":"2019/03/28/reverse1/","link":"","permalink":"https://hanqd.github.io/2019/03/28/reverse1/","excerpt":"题目Reverse sign in题目描述题目中只给了一个rev1文件，其他的没有了。","text":"题目Reverse sign in题目描述题目中只给了一个rev1文件，其他的没有了。 题目分析 知道是个逆向题目，所以直接用ida打开该文件，Fn+F5反编译为c伪代码，得到如下图，知道flag就在sub_400686函数中。 查看sub_400686函数伪代码，如下 找到byte_400818数据，即为数组中的32个值 (char)(*(_BYTE *)(i + a1)在C语言中，内存地址也是用整数int表示（32bit）。因此，(BYTE *)(i+a1) 表示把整数(i+a1)强制转换为BYTE型数值的地址。 char *(i+a1) 即i+a1指向一个字符串常量 ^是在程序中是异或运算符号，即长度为32的数组与i进行异或运算 C++代码12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int b[]=&#123;0x66,0x6D, 0x63, 0x64, 0x7F, 0x3C, 0x36, 0x72, 0x57, 0x42, 0x64, 0x3B, 0x7B, 0x52, 0x7C, 0x3C, 0x66, 0x54, 0x60,0x60, 0x27, 0x4A, 0x49, 0x7F, 0x71, 0x58, 0x52, 0x72, 0x7D, 0x75, 0x2A, 0x62&#125;; char a[33]; for(int i=0;i&lt;=31;i++) &#123; a[i]= b[i]^i; &#125; for(int j=0;j&lt;=31;j++) &#123; cout&lt;&lt;a[j]; &#125; cout&lt;&lt;endl; return 0;&#125; 得到flag，注意：最后那个是两个_，输入时只输了一个，试了两遍！！！要细心啊~~~","categories":[],"tags":[]},{"title":"每日一题 1004","slug":"每日一题1004","date":"2019-03-27T03:00:27.982Z","updated":"2019-03-27T03:01:42.623Z","comments":true,"path":"2019/03/27/每日一题1004/","link":"","permalink":"https://hanqd.github.io/2019/03/27/每日一题1004/","excerpt":"1004 成绩排名题目描述读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。","text":"1004 成绩排名题目描述读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 … … …第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 题目解析：只需找到成绩最高和最低的学生，在和其学号和姓名对应起来即可。 C++代码：代码一：使用结构体1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; //定义一个名字为student的结构体，有三个成员 struct student &#123; char a[11]; char b[11]; int grade; &#125;; //定义三个变量，结构体类型，其中s是所有学生，max是最大值，min是标记最小值的 student s,max,min; int n; cin&gt;&gt;n; cin&gt;&gt;s.a&gt;&gt;s.b&gt;&gt;s.grade; max=min=s; //先假设最大和最小值是第一个学生 //拿第一个的分数分别和其他n-1个学生相比 for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;s.a&gt;&gt;s.b&gt;&gt;s.grade; if(s.grade&gt;max.grade) max=s; if(s.grade&lt;min.grade) min=s; &#125; //max和min已经在上边的循环中指向最大最小的学生，在引用它们的成员即可 cout&lt;&lt;max.a&lt;&lt;&quot; &quot;&lt;&lt;max.b&lt;&lt;endl; cout&lt;&lt;min.a&lt;&lt;&quot; &quot;&lt;&lt;min.b&lt;&lt;endl; return 0;&#125; 代码二：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; string a[n+1],b[n+1]; int grade[n]; int max=0,min=100,s,k;//s,k分别记录最大值和最小值的下标 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;grade[i]; &#125; for(int j=0;j&lt;n;j++) &#123; if(grade[j]&gt;max) &#123; max=grade[j]; s=j; &#125; if(grade[j]&lt;min) &#123; min=grade[j]; k=j; &#125; &#125; cout&lt;&lt;a[s]&lt;&lt;&quot; &quot;&lt;&lt;b[s]&lt;&lt;endl; cout&lt;&lt;a[k]&lt;&lt;&quot; &quot;&lt;&lt;b[k]&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Web calculator","slug":"Web calculate","date":"2019-03-26T12:39:08.259Z","updated":"2019-03-26T12:45:33.555Z","comments":true,"path":"2019/03/26/Web calculate/","link":"","permalink":"https://hanqd.github.io/2019/03/26/Web calculate/","excerpt":"Calculator题目描述","text":"Calculator题目描述 打开链接，网页如下 做题准备 安装requests库网址：http://cn.pythonrequests.org/zh_CN/latest/user/install.html#install我是Windows系统，选择安装的压缩包，解压缩后，把整个文件夹复制到Python的Lib目录下即可。 requests库的使用 http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#url 题目分析要用1.5s计算出结果，并且每次刷新calculator，算数表达式都会变，那么按照平常的计算方式肯定是行不通的，根据题目提示，可以用requests库来解决，要解决的问题： 怎样从服务器那获得算术表达式，计算出结果？ 怎样把计算出的结果提交给服务器？ 让服务器知道获取算式和提交结果的是一个人？ 解题步骤 问题1：需要爬取网页信息，用正则表达式。（导入re模块）Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 问题2：requests里的get传递 URL 参数你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么可以使用如下代码： 12payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get(\"http://httpbin.org/get\", params=payload) 问题3：使用session会话session是一次浏览器和服务器的会话对象，session也是缓存，是内容，是块数据。因为我们访问网页使用的HTTP协议是无状态的，没有任何关系，快速的。所以我们如果想要关联客户的信息就需要一种办法能够把客户的信息联系在一起，这个方法就是cookie。但是cookie是把信息储存在用户本地，它在一个域名下是全局的。不安全又很容易的被修改。所以session就出现了，它储存在服务器上，通过它关联同一个用户的信息，这样用户在访问不同的页面的时候我们就知道对方是同一个人，而不需要每次无状态的访问都需要用户登录/关联了。 脚本代码1234567891011import requestsimport res = requests.Session()t = s.get('http://123.207.149.64:23331/calculator/')print(t.text)value = re.compile(r'&lt;form action=\"\" method=\"GET\"&gt;&lt;span id=\"exp\"&gt;(.*?)&lt;/span&gt;')n = re.findall(value, t.text, re.S | re.M)print('result:\\n\\n%s=%d\\n' % (n, eval(n)))ans = eval(n)f = t.get('http://123.207.149.64:23331/calculator/', params=&#123;'answer': ans&#125;)print(f.text) 结果运行时出现错误：AttributeError: module ‘requests’ has no attribute ‘session’，查了安装的requests库，里边有session模块，但就是运行说没有！！查了好多原因，也重装了requests，还是不行，做这个题用了太长时间了，今天脑子被他弄得晕晕的，决定明天在弄。","categories":[],"tags":[]},{"title":"每日一题 1003","slug":"每日一题1003","date":"2019-03-26T03:17:36.805Z","updated":"2019-03-26T04:01:20.619Z","comments":true,"path":"2019/03/26/每日一题1003/","link":"","permalink":"https://hanqd.github.io/2019/03/26/每日一题1003/","excerpt":"1003 我要通过题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：","text":"1003 我要通过题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 题目分析 条件1：字符串仅有P、A、T这三个字符，包括其他字符则答案错误； 条件2：xPATx形式的字符串正确，其中x为空字符串或者A，例如：PAT、APATA、AAPATAA，要求P左边的A的个数和T右边的个数一样，并且P和T仅有一个； 条件3：aPbTc是正确的，则aPbATca也是正确的，其中a,b,c为空字符串或者A，例如：APATA、APAATAA、AAPATAA、AAPAATAAAA根据P左边，T右边和P、T中间的A的个数来看，可找到规律，即left*mid=right,即答案正确。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; string a; int len=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; //p是P的个数，t是T的个数，left是P左边A的个数，mid,right分别是对应位置A的个数 int p=0,t=0,left=0,mid=0,right=0; len=a.length(); for(int j=0;j&lt;len;j++) &#123; //字符串为A，并且前面没出现过P和T，P左边A的个数 if(a[j]=='A'&amp;&amp;p==0&amp;&amp;t==0) &#123; left++; continue; &#125; //P的个数 if(a[j]=='P') &#123; p++; continue; &#125; //中间A的个数，前面出现了P且个数为1，前面不能出现T if(a[j]=='A'&amp;&amp;p==1&amp;&amp;t==0) &#123; mid++; continue; &#125; //T的个数，并且前边P和T中间出现了A，防止出现PT情况 if(a[j]=='T'&amp;&amp;mid&gt;=1) &#123; t++; continue; &#125; //右边A的个数，前边出现了P和T，个数为1 if(a[j]=='A'&amp;&amp;p==1&amp;&amp;t==1) &#123; right++; continue; &#125; else &#123; break; &#125; &#125; //判断条件：P和T的个数为1，A的个数：左边乘中间等于右边，输出YES if(p==1&amp;&amp;t==1&amp;&amp;(left*mid==right)) &#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125; &#125; return 0; &#125;","categories":[],"tags":[]},{"title":"Python笔记——数据类型（整数、浮点数、数据类型转换）","slug":"Python数据类型（整数、浮点数、数据类型转换）","date":"2019-03-18T08:38:50.653Z","updated":"2019-03-18T09:06:28.161Z","comments":true,"path":"2019/03/18/Python数据类型（整数、浮点数、数据类型转换）/","link":"","permalink":"https://hanqd.github.io/2019/03/18/Python数据类型（整数、浮点数、数据类型转换）/","excerpt":"今天安装了pycharm,界面很好看，是一款好用的编译器。继续学习Python！","text":"今天安装了pycharm,界面很好看，是一款好用的编译器。继续学习Python！ 整数（int）&emsp; 整数包括正整数、负整数和零。Python中的整数范围是很大的。Python中整数还可以以几种不同的进制进行书写。0+“进制标志”+数字代表不同进制的数，进制标志有以下几种： 0o[0O]数字 表示八进制整数（例如：0o24/0O24） 0x[0X]数字 表示十六进制整数（例如：0x3F/0X3F） 0b[0B]数字 表示二进制整数（例如：0b101/0B101） 不带进制标志的为十进制数。&emsp; 注意：每种进制开头数字都是0；八进制的数字0后是小写字母o或大写字母O；但十进制不得以数字0开头书写；每种进制书写时数码不得超过进制规定的数码范围。整数运算符 运算符 描述 ** 乘方运算符 * 乘法运算符 / 除法运算符 // 整除运算符 % 取余运算符 + 加法运算符 - 减法运算符 &#124; 位或 ^ 位异或 &amp; 位与 &lt;&lt; 左移运算 &gt;&gt; 右移运算 “//”运算符就是取商而丢弃余数，比如:14//4=3|、^、&amp;、&lt;&lt;、&gt;&gt;运算符都是位运算符，要依据二进制形式进行运算。 运算符优先级从高到低排列如下： ** *、/、% +、- |、^、&amp;、&lt;&lt;、&gt;&gt; 在同一个式子中，可以使用括号来修改运算符的优先级，即括号具有最高优先级。不必强记运算符的优先级，在没有把握的情况下可以运用括号。注意：“/”运算符的运算结果为浮点数，即时是两个整数相除。 浮点数（float）浮点数就是常用的带小数的数，当然整数部分也可以为零。浮点数的书写除了一般形式（如3.14）外，还有以下几种表示方法： 19. 小数部分为零，可以不写； .098 整数部分为零，可以不写； -2e3 科学计数法，表示-2*10^3 类型转换Python中常用的数据类型的相互转换，所使用函数如下： str(object=’’) 可以将整数和浮点数转换为字符串，默认建立空字符串 int(x,base=10) 将数字字符串或数值转换为整数（base表示进制） float(x) 将字符串或数值转换为浮点数 此外：str()可以创建一个空字符串，int()也可以建立一个默认值为0的整数，float()可以建立一个默认值为0.0的浮点数。【实例】注意：将字符串形式的数值转换为整数时，其中只能包含数字。input()函数接受键盘输入时，无论输入的是整数、浮点数还是字符串，Python得到的都是字符串，那么当需要整数或浮点数时都要进行类型转换。","categories":[],"tags":[]},{"title":"Python笔记——数据类型（字符串）","slug":"Python数据类型（字符串）","date":"2019-03-17T14:32:02.464Z","updated":"2019-03-17T14:56:50.802Z","comments":true,"path":"2019/03/17/Python数据类型（字符串）/","link":"","permalink":"https://hanqd.github.io/2019/03/17/Python数据类型（字符串）/","excerpt":"字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。","text":"字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。 Python的简单数据类型字符串 字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。 注意：单引号和双引号都是英文字符中的符号。 三种表示方法的区别和联系： 单引号字符串与双引号字符串本质上是相同的。但是单引号字符串里边不允许再出现单引号，例如：’aa’ss’cc’，这种是错误的，但是可以使用转义字符来输出’：’aaa”ss”aa’，这样正确，同理，双引号字符串也是，双引号里不能再出现双引号，但可以用转义字符。 三引号字符串可以由多行组成，单引号或双引号不行，当需要使用大段多行的字符串行就使用它。1234'''This is a function.Return a tuple.''' 转义字符串 \\n 换行符 \\t 制表符（Tab） \\r 回车（Enter） \\ “\\”字符 \\’ 单引号字符串中的单引号 \\” 双引号里的双引号 字符串运算“+”：连接字符串乘号 ：单字符串的多次连接‘aaa’+’bbb’ ——&gt;’aaabbb’“python”*3 ——&gt;python python python 字符串处理函数常见的字符串函数 string.capitalize() 将字符串的第一个字母大写 string.count() 获得字符串中某一子字符串的数目 string.find() 获得字符串中某一子字符串的起始位置，无则返回-1 string.isalnum() 检测字符串是仅包含0-9A-Za-z string.isalpha() 检测字符串是仅包含A-Za-z string.isdigit() 检测字符串是仅包含数字 string.islower() 检测字符串是否均为小写字母 string.isspace() 检测字符串中所有字符是否均为空白字符 string.istitle() 检测字符串中的单词是否为首字母大写 string.isupper() 检测字符串是否均为大写字母 string.join() 连接字符串 string.lower() 将字符串全部转换为小写 string.split() 分割字符串 string.swapcase() 将字符串中大写字母转换为小写，小写字母转换为大写 string.title() 将字符串中的单词首字母大写 string.upper() 将字符串中的全部字母转换为大写 len(string) 获取字符串长度 其中split()函数返回以指定的字符将字符串分割成为列表形式并返回，但并不改变原字符串，原型如下：split([sep[,maxsplit]]) sep：可选参数，指定分割的字符，默认为空格 maxsplit：可选参数，分割次数 join()函数将原字符串插入参数字符串中的每两个字符之间。如果参数字符串中只有一个字符，那么返回参数字符串。同样，join()并不改变原字符串，只是返回一个新的字符串。","categories":[],"tags":[]},{"title":"你好，hexo","slug":"你好，hexo","date":"2019-03-15T08:45:25.000Z","updated":"2019-03-15T08:45:25.929Z","comments":true,"path":"2019/03/15/你好，hexo/","link":"","permalink":"https://hanqd.github.io/2019/03/15/你好，hexo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T03:01:22.322Z","updated":"2019-03-16T04:18:31.716Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"https://hanqd.github.io/2019/03/15/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}