{"meta":{"title":"HANqd's BLOG","subtitle":"一个刚进军安全的小白。","description":null,"author":"HANqd","url":"https://hanqd.github.io","root":"/"},"pages":[{"title":"分类&标签","date":"2019-04-06T12:21:36.000Z","updated":"2019-04-06T12:29:33.860Z","comments":true,"path":"tags/index.html","permalink":"https://hanqd.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Web学习+oj Web","slug":"20190411","date":"2019-04-11T14:38:16.360Z","updated":"2019-04-11T14:44:50.552Z","comments":true,"path":"2019/04/11/20190411/","link":"","permalink":"https://hanqd.github.io/2019/04/11/20190411/","excerpt":"通过视频学习了WEB，下面是做的笔记，供以后查阅,一个字一个字码的，omg。","text":"通过视频学习了WEB，下面是做的笔记，供以后查阅,一个字一个字码的，omg。 HTTP协议HTTP简介 HTTP（超文本传输协议） HTTP设计用来将超文本标记语言（HTML）文档从Web服务器传送到Web浏览器 HTTP是一个请求和回应协议：客户机发送请求，服务器对请求给出回应 HTTP（应用层协议）使用可靠的TCP（传输层协议）连接，默认TCP端口是80（HTTP不安全） 承载于TLS或SSL协议层之上，默认端口为443（HTTPS安全） HTTP非持久连接 浏览器首先初始化与运行http服务器主机的TCP连接，使用URL指定端口 浏览器通过与TCP连接相关联的本地套接字发出一个HTTP请求信息 服务器接收到请求后，解析请求并处理请求，然后通过一个套接字发出响应信息 服务器通知TCP需要关闭连接（在浏览器收到响应消息后才会真正终止连接） 浏览器收到响应消息，TCP终止连接这个就是平时访问一个静态页面，HTTP所做的工作，我们输入一个网址，期间有一个响应时间，一旦我们看到了我们访问的页面，服务器就会关闭TCP连接。 HTTP持久连接 持久连接没有关闭连接这一步，服务器响应后会继续让TCP连接保持打开状态当我们请求一个大的文件或者观看视频的时候，服务器会让TCP连接打开，持续输出数据。（当看视频时，下边的缓存条就是说明TCP持续保持连接） HTTP特点 支持客户/服务器模式（也就是浏览器/服务器模式） 简单快速客户向服务器请求服务时，只需传送请求方法和路径（URL），不需要等待很长的协议解析时间。 灵活HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记后，就可以被浏览器和服务器识别。 无连接每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 HTTP协议是无状态协议无状态是指协议对于事务处理没有记忆能力。 URL：统一资源定位符 统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示，是互联网上标准资源地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL标准格式：schema://[user:password@]domain:port/path?query_string#fragments字段解释： schema：请求协议格式，例如http、php、JavaScript user:password@：用户访问服务器时，输入用户名和密码，通过http协议进行身份验证，现在都不这么做了，并不是每个网站都需要实名认证的，都是匿名访问。 domain：域名，服务器的标识，如百度，还有直接是ip地址标识，都是一样的。（平常我们输入网址时，主要是输这一部分） port：端口（输入时一般省略，默认80），但是在做渗透时，可能要用多个端口，为防止端口重用，要输入端口号。 path：路径，即页面的路径 query_string：web传输的参数，http中的get参数，例如搜索关键词时，服务器就是通过URL后的这个参数定位关键词的。 fragments：标记符，可以通过设置，让页面定位在不同的地方，例如top,让页面在顶部 注意：URL中允许出现的字符是有限制的，URL的path开始允许直接出现A-Z，a-z,0-9以及半角连接（-，半角减号）、下划线（_）、点号（.）、波浪号（~）。其他字符均会被进行百分号编码。 抓包分析HTTP报文 HTTP的一个会话，由Request和response组成（请求包和响应包） HTTP请求（Requests）由请求行、消息报头、请求正文三部分组成请求行：请求方法、URL、协议/版本(一般用http1.0版本)消息报头/请求头，这是一个扩充选项，里边的内容可能不全，标识用户的一些请求状态请求正文，一般包含一些参数或者是上传给服务器的文件。不一定不存在 HTTP响应（Responses）也包含三个部分：状态行、消息报头、响应正文状态行：协议状态代码描述消息报头：描述服务器的一些信息响应正文：一定会有 设置代理 知道HTTP协议分为两部分：请求和回应 而平时浏览网页，请求报文是经过浏览器包装好的，不通过工具直接访问只能够控制很少的部分 要想真正的认为控制与服务器的交互，只能通过代理抓包的方法 代理：作为客户端和服务器的中间者，在利用http协议交互时，所有请求和回应都不会直接发送给目标，而是由代理接受和转发 浏览器设置代理 进入浏览器的“选项” 配置网络代理“设置”，手动配置代理（一般不用代理服务器，浏览器直接和服务器对话） 通常在本机进行抓包（代理在本机上） 设置ip地址为127.0.0.1（本机寻回测试的地址）端口为任意空闲端口并记录（代理模式为http代理）怎么查看端口是否空闲？？（一般用8080端口）在cmd里输入 netstat -an命令，即可查看用了的端口 burpsuite代理设置在浏览器中设置好了代理（就是127.0.0.1），那么还得告诉这个中间人，让他给浏览器和服务器传话，接下来对这个代理进行设置。（用burpsuite工具） 进入burpsuite的proxy选项 点击Option设置栏 选中需要设置的代理地址点击edit进行配置 将IP和端口设置为与浏览器中相同的选项 当设置完代理后，界面上IP地址前有一个小框，如果端口空闲，可以打上对号，如果发现打不上对号，说明当前使用的端口被占，只要换一个端口就行，注意这里改了，浏览器那里也得改。 抓包实践 切换到proxy功能中的Intercept窗口 将intercept选项设置为on开启状态 浏览器访问任意网页，burp即可抓取到请求报文请求回应HTTP请求报文如上图所示第一行GET，那是请求行下边红框里的全是消息报头这里没有请求正文，因为这里只访问了一个静态页面HTTP请求方法 GET GET方法用于获取请求页面的指定形式 （通过URL） POST POST可以向服务器传输一些加密信息，也可以传输文件，POST方法与GET方法相似，但是最大的区别在于GET方法没有请求内容，而POST是有请求正文的，且GET请求会将发送的数据显示在浏览器端，而POST请求不会 HEAD HEAD方法除了服务器不能在响应里返回消息正文主体，其他的与GET方法相同 PUT PUT相当于往服务器上传资源。PUT方法用于请求服务器把请求实体存储在请求资源下，如果请求资源已经存在服务器中，将会用此请求中的数据替换原先的数据，作为指定资源的最新修改版 以下HTTP方法可能会对服务器造成损害 DELETE 与PUT方法相反，DELETE方法用于请求资源服务器删除指定的资源 TRACE TRACE方法一般用于激发一个远程应用层的请求消息回路。回显服务器收到得到请求。可用于监测除了自己以外，还有没有代理截取了自己的返回包 CONNECT 为了用于能动态的切换到隧道的代理 OPTIONS OPTIONS方法用于请求获取URL标识的资源在请求/响应的通信过程中可以使用的功能选项 HTTP请求首部 Host：主要用于指定被请求资源的Internet主机和端口号 User-Agent：向服务器端传递客户端操作系统、浏览器、和其他的属性 Referer:包含一个URL，代表当前URL上的一个URL，比如点击了百度的页面，再从百度页面中进入下一个页面，就又referer，第一个页面没有referer Cookie：是一段文本，通常来表示请求者身份 Range：Range可以请求实体部分内容，不下载整个文件内容，多线程下载一定会用到此请求头 x-forward-for：即XFF头，代表请求端的IP，也可以是多个，中间用逗号隔开 Accept:用于指定客户端接收哪些MIME类型的信息 Accept-Charset：用于指定客户端接收的字符集 下面是用POST发起请求时，才会有的请求正文的信息头，会标识我们要上传的文件，会用到以下几个字段：（信息：就是实体内部的属性，包括实体信息类型、长度、压缩方法，最后一次修改时间等） Content-Type：用于向接收方指示实体的介质类型（上传的文件类型） Content-Encoding：被用作媒体类型的修饰符，表示了已经被用到实体正文的附加内容编码，想要获得content-type报头域中所引用的媒体类型，必须采用相应的解码机制。（标识加密编码的模式） Content-Length：用于指明实体正文的长度，以字节方式存储的十进制数字来表示 Last-Modified：用于指示资源的最后修改时间和日期 HTTP响应报文 状态行：由三部分组成：（如上图红框所示）HTTP-Version：表示服务器HTTP协议的版本Status-Code ：表示服务器发回的响应状态代码Reason-Phrase：表示状态代码的文本描述状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理，范围是100~101 2xx：成功–表示请求已被成功接收、理解、接受，范围是200~206 3xx：重定向–要完成请求必须进行更进一步操作，范围是300~305 4xx：客户端错误–请求有语法错误或请求无法实现，范围是400~415 5xx：服务器端错误–服务器未能实现合法的请求，范围是500~505 HTTP常见响应状态码 响应报头 响应正文就是服务器返回的资源的内容 HTTP响应首部响应头：是服务器根据客户端发送的请求返回的内容 Sever：服务器所使用的Web服务器的名称 Set-Cookie：向客户端设置Cookie Last-Modified:服务器通过这个头信息告诉浏览器，资源的最后修改时间 Location：告诉浏览器去访问哪个页面，浏览器接收到这个请求后会立刻访问Location头所指向的页面 Refresh：服务器通过Refresh头告诉浏览器定时刷新浏览器 HTTP安全机制HTTP安全问题HTTP没有考虑到信息的加密和验证问题，面临着数据明文传送和缺乏对消息完整性的验证这两个问题。HTTP协议在数据传输过程中，只要攻击者能够控制到受害者的网络，便可以轻易的嗅探、修改HTTP传输的内容。HTTP协议在传输客户端请求和服务端响应时，仅仅在报文头部包含了传输数据长度，没有任何校验数据完整性的机制。 HTTP安全协议HTTPS协议，通过在TCP层与HTTP层增加一个SSL（安全套接字）来增强数据传输时的安全性。使用HTTPS时，数据的传输的加解密均由SSL进行，与上层HTTP无关。 HTTP与HTTPS的区别HTTPS是在HTTP协议的基础上，HTTP请求与响应都是以相同的方式进行工作，主要区别如下： HTTP是超文本传输协议，信息明文传输。HTTPS是由安全性的SSL加密传输协议 HTTP与HTTPS采用完全不同的连接方式，HTTP是80端口，HTTPS是443端口 HTTPS协议需要到CA申请证书，而HTTP不需要 HTTP连接相对简单，是无状态的，而HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议。Cookie与session会话（session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份（会话信息存储在客户端）Session通过在服务器端记录信息确定用户身份（会话信息存储在服务器端）Session和Cookie的作用都是为了保持访问用户与后端服务器的交互状态。 Web calculator由于之前的request库导入不成功，一直出错，今天把pycharm重装，把电脑上多个版本的Python卸载之后，可以正常使用requests库了。于是接着把之前做的calculator题解完。爬取页面数据可以用requests 与 beautiful soup，具体例子https://www.jianshu.com/p/9c266216957b。，很详细，适合新手。然后用正则表达式来匹配数字，创建一个列表（相当于C中的数组），把需要计算的数字存到列表中，计算结果。根据提交ip地址，提交结果，打印页面，即得到flag。下面是我的解题脚本12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupimport res = requests.Session()t = s.get('http://123.207.149.64:23331/calculator/')print(t.text)soup = BeautifulSoup(t.text,'lxml')a = soup.find_all(id=\"exp\")equ = a[0].stringpattern = re.compile(r'\\d+')num = re.findall(pattern,equ)print(num)j = 0dic=[0,0,0,0]for i in num: dic[j] = int(i) j=j+1result = dic[0]+dic[1]*dic[2]-dic[3]print(result)canshu = &#123;'answer':str(result)&#125;r =s.get('http://123.207.149.64:23331/calculator/', params=canshu)print(r.text)","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"}]},{"title":"pwn题目初尝试","slug":"oj pwn","date":"2019-04-10T14:39:27.968Z","updated":"2019-04-10T14:40:53.915Z","comments":true,"path":"2019/04/10/oj pwn/","link":"","permalink":"https://hanqd.github.io/2019/04/10/oj pwn/","excerpt":"oj pwn-bof搭建好环境，也看了很多关于pwn的博客，就开始练练手吧，毕竟理论和实际操作还是有差别的。","text":"oj pwn-bof搭建好环境，也看了很多关于pwn的博客，就开始练练手吧，毕竟理论和实际操作还是有差别的。 知识准备二进制保护检测工具——checksec。里边的参数解释： Arch，该项位程序的位数，显示位32位程序。 RELRO，RELRO会有Partial RELRO和FULL RELRO，如果开启了FULL RELRO，那么我们将无法修改got表，关于got表后面的文章遇到了再讲解。 Stack，栈中是否开启了Canary found，如果该项保护被打开那么我们将无法直接覆盖EIP让程序任意跳转，因为在跳转后将会进行cookie校验，该项保护是可以绕过的，遇到的时候将详细分析。 NX，该项表示堆栈是否可执行，如果开启了该项保护，那么我们的shellcode将不能被执行。 PIE，该项表示地址随机化保护，如果开启了该项那么程序每次运行的地址都会变化，如果未开启那么No PIE（0x8048000）括号内的代表程序基址。 查看rof文件信息 ：file 文件名是32位的，用IDA 32位的把文件打开 查看保护机制没开任何保护，可以进行常规操作啦。 运行程序把文件bof拖到Ubuntu里，在终端用命令行运行（./pwn），输入很多a，出现如下错误，说明产生了溢出。 分析代码 找offset,用gdb进行调试，查看刚好输入多少位才能覆盖返回地址。 返回地址这需要构造什么内容，如果没有保护直接写shellcode，拿到shell,如果在程序中有system，则在IDA中按Alt+T查找有没有“/bin/sh”字符串，如果有，则直接找到其地址，即可构造内容，没有则需要自己写shellcode。 我在做这道题时，进行第一步就卡住了，用gdb运行程序出错，如下于是手动算位数，需要’a’*0x1c+’a’*4,需要32位才能刚好覆盖返回地址（这里根据在IDA看到的buf空间算出来的位数可能不对，这里先试一下。）有了需要覆盖的内容位数，在来找shell的返回地址，看到bof中有system函数，但是没有“/bin/sh”字符串，需要构造shellcode. 脚本123456789from pwn import *#r=remote('pwn1.blue-whale.me',9990)r=process('./pwn')elf=ELF('./pwn')shellcode=asm(shellcraft.sh())address = 0x080483F0payload = 'a'*(32-len(shellcode))+ p32(address)+shellcoder.send(payload)r.interactive() 但是攻击失败。。。。。 shellcode前面步骤同上，在此略去。 进入gdb调试 首先用cyclic命令产生长度很长的字符串，这里长度是200，可自己设置。 进入gdb调试 把上面产生的字符串输入进去 出现寄存器的内容和PC地址 查看覆盖长度脚本12345678from pwn import *r = remote (\"pwn1.blue-whale.me\",9992)shellcode=asm(shellcraft.sh())text = r.recvline()[17: -2]buf_addr=int(text,16)payload=shellcode+'a'*(32-len(shellcode))+p32(buf_addr)r.send(payload)r.interactive() 总结我觉得这个题出错点有二：一是可能覆盖位数算错了二是shellcode注入的地址有误做pwn题还是得多练习，多找思路，多借助工具，可能事半功倍。争取明天做出来！ 今日所做边做题边看了很多pwn的博客，还有pwn的writeup，做了第一道bof和shellcode那道，shellcode题用了题目给出的网址和端口号，可能服务器被墙了，导致连接端口失败。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwn环境搭建（Ubuntu下）","slug":"pwn环境搭建","date":"2019-04-09T13:53:36.143Z","updated":"2019-04-09T13:54:34.482Z","comments":true,"path":"2019/04/09/pwn环境搭建/","link":"","permalink":"https://hanqd.github.io/2019/04/09/pwn环境搭建/","excerpt":"pwn环境搭建前言因为需要pwn做题环境，之前也搭建过，不过没有成功，原因是Ubuntu系统源一直更新不成功，所以导致之后的安装全部失败，今天抱着又失败的心情来安装，竟然成功了！！！因为找到了正确的阿里源！！感谢大佬！http://www.cnblogs.com/dtiove/p/5917263.html","text":"pwn环境搭建前言因为需要pwn做题环境，之前也搭建过，不过没有成功，原因是Ubuntu系统源一直更新不成功，所以导致之后的安装全部失败，今天抱着又失败的心情来安装，竟然成功了！！！因为找到了正确的阿里源！！感谢大佬！http://www.cnblogs.com/dtiove/p/5917263.html更换源：sudo gedit sources.list更新源以下是根据网上各种安装博客，搭建的pwn做题环境,在这里记录一下： 安装所需 Ubuntu16.4 Python pip libssl-dev libffi-dev 安装命令sudo apt-get install libffi-devsudo apt-get install libssl-devsudo apt-get install pythonsudo apt-get install python-pippip install pwntools 其中在安装pwntools时，出现错误。解决办法：可能考虑到是python国内网络的问题，这时用国内的镜像源来加速。pip install 包名 -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com成功安装！ ！！！！安装qira成功，但是运行qira失败，配置了路径也不行，明天再试试，一直困在一个死胡同里真的容易憋死！！！！！","categories":[],"tags":[{"name":"pwn环境搭建","slug":"pwn环境搭建","permalink":"https://hanqd.github.io/tags/pwn环境搭建/"}]},{"title":"每日一题 1017（大数除法）","slug":"每日一题1017","date":"2019-04-09T01:57:02.820Z","updated":"2019-04-09T14:14:32.616Z","comments":true,"path":"2019/04/09/每日一题1017/","link":"","permalink":"https://hanqd.github.io/2019/04/09/每日一题1017/","excerpt":"1017 A除以B题目描述本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。","text":"1017 A除以B题目描述本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 题目分析输入样例：123456789050987654321 7 输出样例：17636684150141093474 3 这里的A是不超过1000位的正整数，超出了一般数据类型的表示范围，涉及到大整数的运算，用字符串来表示大数。这里的大数除法思想是：先用大数字符串的第一个数即是s[0]除以被除数，样例中是s[0]=1,用1/7，Q=0,R=1,再用R*10+s[1]除以7，得到商和余数，（这里为什么余数要乘以10？因为这个余数是上一个字符除以7余下的，相比较算术运算中的十位和个位，先用十位上的数除以7，余数不等于0，则在计算个位除以7时，需要加上十位余下的数，计算才正确。）以此类推，直到计算完字符串的最后一个字符。 C++代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string A; int B,Q=0,R=0; cin&gt;&gt;A&gt;&gt;B; Q=(A[0]-&apos;0&apos;)/B; if(A.length()==1||(A.length()&gt;0&amp;&amp;Q!=0)) &#123; cout&lt;&lt;Q; &#125; R=(A[0]-&apos;0&apos;)%B; for(int i=1;i&lt;A.length();i++) &#123; Q=((R*10)+A[i]-&apos;0&apos;)/B; cout&lt;&lt;Q; R=((R*10)+A[i]-&apos;0&apos;)%B; &#125; cout&lt;&lt;&quot; &quot;&lt;&lt;R; return 0;&#125; 大数四则运算：https://www.cnblogs.com/wuqianling/p/5387099.html各种数据类型的取值范围：https://www.cnblogs.com/fightformylife/p/4022058.htmlhttps://www.cnblogs.com/fightformylife/p/4022058.html","categories":[],"tags":[{"name":"PAT每日一题","slug":"PAT每日一题","permalink":"https://hanqd.github.io/tags/PAT每日一题/"}]},{"title":"每日一题1015（结构体+sort排序）+1016","slug":"每日一题1015 1016","date":"2019-04-08T14:13:53.116Z","updated":"2019-04-08T14:15:04.930Z","comments":true,"path":"2019/04/08/每日一题1015 1016/","link":"","permalink":"https://hanqd.github.io/2019/04/08/每日一题1015 1016/","excerpt":"1015 德才论题目描述宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”","text":"1015 德才论题目描述宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤10^5 ），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 题目分析输入样例：14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 输出样例：1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 拿到题目，看到是一道比较综合的一道题目，有关联性数据的存储，要求学号和姓名对应起来，考虑用结构体解决，结构体成员包括准考证号、德分，才分。涉及到排序，考虑用sort()函数，头文件：algorithm。 在结构体中添加两个成员，flag和sum，flag是分类的标志，根据题意可以分为5类，第一类：德才都大于H，第二类：德大于H，才小于H，但是大于L，第三类：德和才都小于H，大于L，但是德大于才，第四类：在德大于L，小于H，才也大于L的情况下，德小于才第五类：德和才其中有一个小于L，即列为其他情况。sum在排序时，按从高到低排序。 2.strcmp(str1,str2)函数，字符串比较函数，设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。这里return strcmp(x.a,y.a)&lt;0; 是按准考证号从小到大排序。 Sort(start,end,排序方法)，这里的排序方法是按照自己编写的cmp函数。C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char a[10]; int de; int cai; int sum; int flag; &#125;;student s[100001];bool cmp(student x,student y)&#123; if(x.flag!=y.flag) return x.flag&lt;y.flag; else if(x.sum!=y.sum) return x.sum&gt;y.sum; else if(x.de!=y.de) return x.de&gt;y.de; else return strcmp(x.a,y.a)&lt;0;&#125;int main()&#123; int n,L,H,count=0; cin&gt;&gt;n&gt;&gt;L&gt;&gt;H; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i].a&gt;&gt;s[i].de&gt;&gt;s[i].cai; s[i].sum=s[i].de+s[i].cai; if(s[i].de&gt;=H&amp;&amp;s[i].cai&gt;=H) &#123; count++; s[i].flag=1; &#125; else if(s[i].de&gt;=H&amp;&amp;s[i].cai&lt;H&amp;&amp;s[i].cai&gt;=L) &#123; count++; s[i].flag=2; &#125; else if(s[i].de&lt;H&amp;&amp;s[i].cai&lt;H&amp;&amp;s[i].de&gt;=s[i].cai&amp;&amp;s[i].de&gt;=L&amp;&amp;s[i].cai&gt;=L) &#123; count++; s[i].flag=3; &#125; else if(s[i].de&gt;=L&amp;&amp;s[i].de&lt;H&amp;&amp;s[i].cai&gt;=L&amp;&amp;s[i].de&lt;s[i].cai) &#123; count++; s[i].flag=4; &#125; else s[i].flag=5; &#125; sort(s,s+n,cmp); cout&lt;&lt;count&lt;&lt;endl; for(int i=0;i&lt;count;i++) &#123; cout&lt;&lt;s[i].a&lt;&lt;&quot; &quot;&lt;&lt;s[i].de&lt;&lt;&quot; &quot;&lt;&lt;s[i].cai&lt;&lt;endl; &#125; return 0;&#125; 1016 部分A+B题目描述正整数 A 的“DA （为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA 。例如：给定 A=3862767，DA =6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。 现给定 A、DA 、B、DB ，请编写程序计算 PA +PB 。 输入格式：输入在一行中依次给出 A、DA 、B、DB ，中间以空格分隔，其中 0&lt;A,B&lt;10^10 。 输出格式：在一行中输出 PA +PB 的值。 题目分析输入样例 1：3862767 6 13530293 3输出样例 1：399 输入样例 2：3862767 1 13530293 8输出样例 2：0 可以对A进行个位分离并进行判断 C++代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int main()&#123; int A,Da,B,Db; cin&gt;&gt;A&gt;&gt;Da&gt;&gt;B&gt;&gt;Db; int a=0,b=0; for(int i=0;A!=0||B!=0;i++) &#123; if(A!=0) &#123; if(A%10==Da) &#123; A=A/10; a=a*10+Da; &#125; else A=A/10; &#125; if(B!=0) &#123; if(B%10==Db) &#123; B=B/10; b=b*10+Db; &#125; else B=B/10; &#125; &#125; cout&lt;&lt;a+b; return 0;&#125;","categories":[],"tags":[{"name":"PAT每日一题","slug":"PAT每日一题","permalink":"https://hanqd.github.io/tags/PAT每日一题/"}]},{"title":"IDA Pro权威指南-第一章 反汇编简介","slug":"IDA Pro学习1","date":"2019-04-07T14:23:51.140Z","updated":"2019-04-07T14:30:55.560Z","comments":true,"path":"2019/04/07/IDA Pro学习1/","link":"","permalink":"https://hanqd.github.io/2019/04/07/IDA Pro学习1/","excerpt":"反汇编简介反汇编理论编程语言分为好几代：","text":"反汇编简介反汇编理论编程语言分为好几代： 第一代语言：这些语言是最低级的语言，一般由0或1或某些简写编码（如十六进制码）组成。第一代语言称为机器语言，有时也叫做字节码，而机器语言程序常被称为二进制文件。 第二代语言：汇编语言。汇编语言会将具体的位模式或操作码，与短小且易于记忆的字符序列（即助记符）对应起来。 第三代语言：高级程序语言，即C、Java等。程序员通常使用编译器将程序转换成汇编语言，或者直接转换为机器语言（或某种大致的等价形式，如字节码）。 何为反汇编程序员使用编译器、汇编器和链接器中的一个或几个创建可执行程序。由源代码（c语言程序）到汇编语言再到机器码的过程。为了回溯编程过程（或对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程，这些工具就叫做反汇编器和反编译器。反汇编器的输入的汇编语言，输出是汇编语言形式，反编译器是以汇编语言甚至机器语言为输入，其输出结果是高级语言。 在竞争激烈的软件市场，“恢复源代码”的前景总是充满吸引力的。以下列举几个原因，说明反汇编困难重重： 编译过程会造成损失。机器语言中没有变量或函数名，变量类型信息只有通过数据的用途来确定。 编译属于多对多操作。源程序可以通过许多不同的方式转换成汇编语言，而机器语言也可以通过许多不同方式转换成源程序。 反编译器非常依赖于语言和库。 要想准确的反编译一个二进制文件，需要近乎完美的反汇编能力。 为何反汇编通常，使用反汇编工具是为了在没有源代码的情况下促进对程序的了解。需要进行反汇编的常见情况包括以下几种： 分析恶意软件 分析闭源软件的漏洞 分析闭源软件的互操作性 分析编译器生成的代码，以验证编译器的性能和准确性 在调试时显示程序指令 分析恶意软件恶意软件的作者很少会提供他们“作品”的源代码，除非你对付的是一种基于脚本的蠕虫。由于缺乏源代码，要准确的了解恶意代码的运行机制，选择非常有限。动态分析和静态分析是分析恶意软件的两种主要技术。动态分析是指在严格控制的环境（沙盒）中执行恶意软件，并使用系统检测实用工具记录其所有行为。相反，静态分析则试图通过浏览程序代码来理解程序的行为。此时，要查看的就是对恶意软件进行反汇编之后的代码。 漏洞分析将整个安全审核过程划分为3个步骤：发现漏洞、分析漏洞、开发破解程序。第一个步骤是发现程序中潜在的可供利用的条件，一般情况下，可以通过模糊测试等动态技术来达到这一目的，也可通过静态分析来实现。编译器究竟如何分配程序变量，反汇编代码清单提供了详细的信息。另外，要了解编译器到底如何对全局声明或在函数中声明的所有变量进行排序，查看反汇编代码清单是唯一的办法。在开发破解程序时，了解变量之间的这些空间关系往往非常重要。 软件互操作性如果仅以二进制形式发布一个软件，竞争对手想要创建可以和它互操作的软件，或者为该软件提供插件，将会非常困难。针对某个仅有一种平台支持的硬件而发布的驱动程序代码，就是一个常见的例子。如果厂商暂时不支持，或者更糟糕的，拒绝支持在其他平台上使用它们的硬件，那么为了开发支持硬件的软件驱动程序，可能需要完成大量的逆向工作。在这些情况下，静态代码分析几乎是唯一的补救方法。 编译器验证由于编译器（或汇编器）的用途是生成机器语言，因此优秀的反汇编工具通常需要验证编译器是否符合设计规范。除准确性外，分析人员还可以从中寻找优化编译器输出的机会，查知编译器本身是否容易被攻破，以致于可以在生成的代码中插入后门，等等。 显示调试信息在调试器中生成代码清单，可能是反汇编器最常见的一种途径。在调试过程中，为了了解详细的环境和背景信息，最好是结合使用调试器和优秀的反汇编器。 如何反汇编以上已经知道了反汇编的目的，下面是介绍如何反汇编。以反汇编器所面临的一个艰巨任务为例：对于一个100KB的文件，请区分其中的代码与数据，并把代码转换成汇编语言显示给用户，在整个过程中，不要遗漏任何信息。要求反汇编器定位函数，识别跳转表并确定局部变量，这进一步增加了反汇编器工作的难度。为了满足所有要求，反汇编器必须从大量算法中选择一些适当的算法，来处理我们提供的文件。 基本的反汇编算法首先开发一个以机器语言为输入、以汇编语言为输出的简单算法。 第一步。确定进行反汇编的代码区域。通常，指令与数据混杂在一起，区分它们就显得非常重要。以最常见的情形——反汇编可执行文件为例，该文件必须符合可执行文件的某种通用格式，如Windows所用的可移植可执行（PE）格式或许多UNIX系统常用的可执行和链接格式（ELF）。这些格式通常含有一种机制，用来确定文件中包含代码和代码入口点的部分的位置（通常变现为层级文件头的形式）。 第二步。知道指令的起始地址后，下一步就是读取该地址（或文件偏移量）所包含的值，并执行一次表查找，将二进制操作码的值与它的汇编语言助记符对应起来。 第三步。获取指令并解码任何所需的操作数后，需要对它的汇编语言等价形式进行格式化，并将其在反汇编代码中输出。 第四步。输出一条指令后，继续反汇编下一条指令，并重复上述过程，直到反汇编完文件中的所有指令。 有大量算法可以用于确定从何处开始反汇编、如何选择下一条反汇编的指令、如何区分代码与数据，以及如何确定何时完成对最后一条指令的反汇编。线性扫描和递归下降是两种最主要的反汇编算法。 线性扫描反汇编线性扫描反汇编算法采用一种非常直接的方法来确定反汇编的指令的位置：一条指令结束、另一条指令开始的地方。确定起始位置的常用解决办法是，假设程序中标注为代码（通常由程序文件的头部指定）的节所包含的全部是机器语言指令。反汇编从一个代码段的第一个字节开始，以线性模式扫描整个代码段，逐条反汇编每条指令，直到完成整个代码段。这种算法并不会通过识别分支等非线性指令来了解程序的控制流。 线性扫描算法的主要优点在于：它能够完全覆盖程序的所有代码段。主要缺点是：没有考虑到代码中可能混有数据。 GNU调试器（gdb）、微软公司的WinDug调试器和objdump实用工具的反汇编引擎均采用线性扫描算法。 递归下降反汇编递归下降采用另外一种不同的方法来定位指令。递归下降算法重视控制流的概念。控制流根据一条指令是否被另一条引用来决定是否对其进行反汇编。为了便于理解递归下降，根据指令对CPU指令指针的影响对他们进行分类。 顺序流指令顺序流指令将执行权传递给紧随其后的下一条指令。如add、mov、push和pop。 条件分支指令条件分支指令提供两条可能的执行路径。如果条件为真，则执行分支，并且必须修改指令指针，使其指向分支的目标。但是，如果条件为假，则继续以线性模式执行指令，并使用线性扫描方法反汇编下一条指令。 无条件分支指令无条件分支并不遵循线性流模式。与顺序流指令一样，执行权只能传递给一条指令，但那条指令不需要紧接在分支指令后面。 函数调用指令函数调用指令的运行方式与无条件跳转指令非常相似，唯一不同在于，一旦函数完成，执行权将返回给紧跟在调用指令后面的指令。从被调用函数返回时，如果程序的运行出现异常，递归下降就有可能失败。5.返回指令有时，递归下降算法访问了所有路径，而且，函数返回指令没有提供接下来要执行的指令的信息。这时，递归下降反汇编器会转而处理前面搁置在一旁的延迟反汇编地址列表。反汇编器从这个列表中取出一个地址，并从这个地址开始继续反汇编过程。 递归下降算法的一个主要优点在于：它具有区分代码与数据的强大能力。主要缺点是：它无法处理间接代码路径，例如利用指针表来查找目标地址的跳转和调用。IDA Pro 是一种典型的递归下降反汇编器。","categories":[],"tags":[{"name":"IDA Pro学习","slug":"IDA-Pro学习","permalink":"https://hanqd.github.io/tags/IDA-Pro学习/"}]},{"title":"每日一题 1014","slug":"每日一题1014","date":"2019-04-06T12:08:36.704Z","updated":"2019-04-06T12:55:15.180Z","comments":true,"path":"2019/04/06/每日一题1014/","link":"","permalink":"https://hanqd.github.io/2019/04/06/每日一题1014/","excerpt":"1014 福尔摩斯的约会题目描述大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。","text":"1014 福尔摩斯的约会题目描述大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 题目分析输入样例：12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：1THU 14:04 前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；这里第四是相对于26个字母来说，D在第四。说明大写字母I所在位置第几就是星期几，用I-A+1来表示。 第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；注意：这里第一对相同的字符是8，而给出的样例是E，说明这里相同的字符要在第一个条件之后出现才行。0到9点的表示：当前数字-0，在前面要加0，两位数，10到23点的表示方法：I-A+10. 后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。相同的字母（大小写都可以）出现的位置，这里是相对于字符串来讲，即第几分钟，小于10的，要在前面加0。 注意：两个字符串中相同位置具有相同字母的对数不止两对，所以在确定小时后一定要跳出循环，不然后面还可能又有一对满足第二个条件的，这就错误了，有一个测试点的陷阱就在这里。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void week(int n)&#123; switch(n) &#123; case 1:cout&lt;&lt;&quot;MON&quot;&lt;&lt;&apos; &apos;;break; case 2:cout&lt;&lt;&quot;TUE&quot;&lt;&lt;&apos; &apos;;break; case 3:cout&lt;&lt;&quot;WED&quot;&lt;&lt;&apos; &apos;;break; case 4:cout&lt;&lt;&quot;THU&quot;&lt;&lt;&apos; &apos;;break; case 5:cout&lt;&lt;&quot;FRI&quot;&lt;&lt;&apos; &apos;;break; case 6:cout&lt;&lt;&quot;SAT&quot;&lt;&lt;&apos; &apos;;break; case 7:cout&lt;&lt;&quot;SUN&quot;&lt;&lt;&apos; &apos;;break; &#125;&#125;int main()&#123; string s1,s2,s3,s4; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4; int i=0; bool flag=false; while(s1.length()&gt;i&amp;&amp;s2.length()&gt;i) &#123; if(s1[i]==s2[i]) &#123; if(flag) &#123; if(s1[i]&gt;=&apos;0&apos;&amp;&amp;s1[i]&lt;=&apos;9&apos;) &#123; cout&lt;&lt;&apos;0&apos;&lt;&lt;s1[i]-&apos;0&apos;&lt;&lt;&quot;:&quot;; break; &#125; else if(s1[i]&gt;=&apos;A&apos;&amp;&amp;s1[i]&lt;=&apos;N&apos;) &#123; cout&lt;&lt;s1[i]-&apos;A&apos;+10&lt;&lt;&quot;:&quot;; break; &#125; &#125; if(!flag&amp;&amp;s1[i]&gt;=&apos;A&apos;&amp;&amp;s1[i]&lt;=&apos;G&apos;) &#123; int n=s1[i]-&apos;A&apos;+1; week(n); flag=true; &#125; &#125; i++; &#125; i=0; while(s3.length()&gt;i&amp;&amp;s4.length()&gt;i) &#123; if(s3[i]==s4[i]&amp;&amp;(s3[i]&gt;=&apos;A&apos;&amp;&amp;s3[i]&lt;=&apos;Z&apos;||s3[i]&gt;=&apos;a&apos;&amp;&amp;s3[i]&lt;=&apos;z&apos;)) &#123; if(i&lt;10) cout&lt;&lt;0; cout&lt;&lt;i; break; &#125; i++; &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT每日一题","slug":"PAT每日一题","permalink":"https://hanqd.github.io/tags/PAT每日一题/"}]},{"title":"每日一题 1011+1012+1013","slug":"每日一题1011 1012 1013","date":"2019-04-05T13:49:11.990Z","updated":"2019-04-05T13:50:22.517Z","comments":true,"path":"2019/04/05/每日一题1011 1012 1013/","link":"","permalink":"https://hanqd.github.io/2019/04/05/每日一题1011 1012 1013/","excerpt":"把之前落下的题目补上。每日一题不能断！","text":"把之前落下的题目补上。每日一题不能断！ 1011 A+B 和 C题目描述给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式：输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 题目分析输入样例：41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例：Case #1: falseCase #2: trueCase #3: trueCase #4: false 根据样例，可以用做个for循环输入三个数，在循环里做判断，注意输出格式。这里注意数据范围，a和b是int型的取值范围【-2^31-2^31-1】，但是两个数相加不一定是int型，可能超出整数型范围，所以声明变量时注意！（我第一遍都是用的int型，答案部分正确，后来改为double型，答案正确。） C++代码123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int T; double a,b,c; cin&gt;&gt;T; for(int i=0;i&lt;T;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a+b&gt;c) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: false&quot;&lt;&lt;endl; &#125; return 0;&#125; 1012 数字分类题目描述给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和；A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1 −n2 +n3 −n4 ⋯；A3 = 被 5 除后余 2 的数字的个数；A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；A5 = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A1 ~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 题目分析输入样例 1：13 1 2 3 4 5 6 7 8 9 10 20 16 18输出样例 1：30 11 2 9.7 9 输入样例 2：8 1 2 4 5 6 7 9 16输出样例 2：N 11 2 N 9 这是一道条件题，只要细心一点就能AC，这里注意A2可能为0，可以用一个变量记录是否有对5求余后为1的值。 C++代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n+1]; int sum1=0,sum2=0,sum3=0,k=1,max=0; int A2=0,A3=0,A4=0,A5=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; if(a[i]%5==0&amp;&amp;a[i]%2==0) &#123; sum1+=a[i]; &#125; else if(a[i]%5==1) &#123; sum2+=a[i]*k; k=-k; A2++; &#125; else if(a[i]%5==2) &#123; A3++; &#125; if(a[i]%5==3) &#123; sum3+=a[i]; A4++; &#125; if(a[i]%5==4) &#123; if(a[i]&gt;max) max=a[i]; A5++; &#125; &#125; if(sum1&gt;0) cout&lt;&lt;sum1; else cout&lt;&lt;&quot;N&quot;; if(A2&gt;0) cout&lt;&lt;&quot; &quot;&lt;&lt;sum2; else cout&lt;&lt;&quot; N&quot;; if(A3&gt;0) cout&lt;&lt;&quot; &quot;&lt;&lt;A3; else cout&lt;&lt;&quot; N&quot;; if(A4&gt;0) cout&lt;&lt;&apos; &apos;&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(1)&lt;&lt;sum3*1.0/A4; else cout&lt;&lt;&quot; N&quot;; if(max&gt;0) cout&lt;&lt;&quot; &quot;&lt;&lt;max; else cout&lt;&lt;&quot; N&quot;; return 0;&#125; 1013 数素数题目描述令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10^4 ，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 题目分析输入样例：5 27输出样例：11 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 先判断输入的数是否是素数，并计数，判断与m和n的大小，注意一下输出格式就行了。 C++代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int m,n,i=2,count=0; bool isPrime; cin&gt;&gt;m&gt;&gt;n; while(count!=n) &#123; isPrime=true; for(int j=2;j&lt;=sqrt(i);j++) &#123; if(i%j==0) &#123; isPrime=false; break; &#125; &#125; if(isPrime) &#123; count++; if(count&gt;=m&amp;&amp;count&lt;n&amp;&amp;((count-m+1)%10!=0)) cout&lt;&lt;i&lt;&lt;&quot; &quot;; if(count&gt;=m&amp;&amp;count&lt;n&amp;&amp;((count-m+1)%10==0)) cout&lt;&lt;i&lt;&lt;endl; if(count==n) cout&lt;&lt;i; &#125; i++; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Misc shell","slug":"Misc shell","date":"2019-04-04T14:58:37.561Z","updated":"2019-04-04T14:59:54.243Z","comments":true,"path":"2019/04/04/Misc shell/","link":"","permalink":"https://hanqd.github.io/2019/04/04/Misc shell/","excerpt":"Misc shell题目描述流量分析。如果你解不出flag，请先查看整个流量，搞清楚网络中的两台主机之间发生了什么。","text":"Misc shell题目描述流量分析。如果你解不出flag，请先查看整个流量，搞清楚网络中的两台主机之间发生了什么。 题目分析根据题目提示，是一道流量分析题，用wireshark打开文件，如下题目提示，查看整个流量，那么通过过滤协议，一条条分析协议的方法是不对的，可以用跟踪数据流的方法，查看两台主机之间发生了什么。 跟踪http流：鼠标放在http协议上，右键-》追踪流-》http流，无可疑信息。 跟踪tcp流：方法同上，发现有flag.txt和base64字样，再往下看，有一串可疑字符串（猜测使用base64编码过的）。 Python中的swapcase()函数是对字符串的大小写进行转换。分析这个字符串是先进行base64编码，再对编码后的字符串进行大小写转换，逆过程即可得到flag。 对字符串进行大小写转换 对转换后的字符串base64解码","categories":[],"tags":[]},{"title":"每日一题 1010","slug":"每日一题1010","date":"2019-04-02T13:34:31.137Z","updated":"2019-04-02T13:35:25.877Z","comments":true,"path":"2019/04/02/每日一题1010/","link":"","permalink":"https://hanqd.github.io/2019/04/02/每日一题1010/","excerpt":"1010 一元多项式求导题目描述设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为nx^n−1 。）","text":"1010 一元多项式求导题目描述设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为nx^n−1 。） 输入格式:以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 输出格式:以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。 题目分析可以一组一组的输出，系数和指数分组输出。注意输出格式，结尾不能有多余的空格，可以先输出一组，在输出其他。 C++代码123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int m,n; int flag=1; while(cin&gt;&gt;m&gt;&gt;n) &#123; if(n&gt;0) &#123; if(flag==1) &#123; cout&lt;&lt;m*n&lt;&lt;&quot; &quot;&lt;&lt;n-1; flag=0; &#125; else &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;m*n&lt;&lt;&quot; &quot;&lt;&lt;n-1; &#125; &#125; &#125; if(flag==1) cout&lt;&lt;&quot;0 0&quot;; return 0;&#125;","categories":[],"tags":[]},{"title":"pwn-栈溢出（1）","slug":"20190402","date":"2019-04-02T12:10:40.857Z","updated":"2019-04-02T12:11:40.676Z","comments":true,"path":"2019/04/02/20190402/","link":"","permalink":"https://hanqd.github.io/2019/04/02/20190402/","excerpt":"栈溢出简介计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。为了实现栈溢出，要满足两个条件。","text":"栈溢出简介计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。为了实现栈溢出，要满足两个条件。 第一，程序要有向栈内写入数据的行为； 第二，程序并不限制写入数据的长度。 历史上第一例被广泛注意的“莫里斯蠕虫”病毒就是利用C语言标准库的 gets() 函数并未限制输入数据长度的漏洞，从而实现了栈溢出。 背景知识-函数调用栈函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。 函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。 函数调用发生和结束时调用栈的变化 函数状态主要涉及三个寄存器－－esp，ebp，eip。 esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。 ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。 eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。 下面是发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。 （1）子过程参数入栈：首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。（2）调用函数（父过程）的返回地址入栈：将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。（在执行完调用函数后回到主函数，能够继续执行主函数指令的指令地址）（3）将调用函数的基地址（ebp）入栈，并将当前栈顶地址传到ebp寄存器：将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。（4）将被调用函数的局部变量压入栈内在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。 函数调用结束时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。（1） 将被调用函数的局部变量弹出栈外：首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。（2）将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内：将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的 ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。（3）将调用函数的返回地址弹出栈外，并存到 eip 寄存器内总过程总结为下图： 技术清单当函数正在执行内部指令的过程中无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 eip，所以目标就是让 eip 载入攻击指令的地址。 函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？ 首先，在退栈过程中，返回地址会被传给 eip，所以只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。 其次，可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。 函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？ 这时，eip 会指向原程序中某个指定的函数，没法通过改写返回地址来控制了，不过可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。 一共包括下面的四种情况： 修改返回地址，让其指向溢出数据中的一段指令（shellcode） 修改返回地址，让其指向内存中已有的某个函数（return2libc） 修改返回地址，让其指向内存中已有的一段指令（ROP） 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT） Shellcode(修改返回地址，让其指向溢出数据中的一段指令) 要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。shellcode 可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴。下面是溢出数据的组成，shellcode 所用溢出数据的构造。payload : padding1 + address of shellcode + padding2 + shellcode padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。 返回地址之前的填充数据（padding1）应该多长？ 我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。一般是缓冲区大小+ebp大小 [esp-0x100],32位机器时，ebp为4字节，所以填充数据大小为：0x100+4=300个字节 shellcode起始地址应该是多少？ 可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。 操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。","categories":[],"tags":[]},{"title":"每日一题 1009+vector容器","slug":"20190401","date":"2019-04-01T09:34:28.033Z","updated":"2019-04-01T09:35:48.721Z","comments":true,"path":"2019/04/01/20190401/","link":"","permalink":"https://hanqd.github.io/2019/04/01/20190401/","excerpt":"1009 说反话题目描述给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。","text":"1009 说反话题目描述给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 题目分析输入样例：Hello World Here I Come输出样例：Come I Here World Hello由样例，可以想到用栈来解决，符合栈的先进后出的特点，还可以用vactor容器解决。 C++代码方法一：123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; char c; stack&lt;string&gt; s; //声明一个string类型的栈变量s string str; while(cin&gt;&gt;str) &#123; s.push(str);//str入栈 if((c=getchar())==&apos;\\n&apos;) break;//c接收入栈的单个字符，判断是否输入完毕 &#125; cout&lt;&lt;s.top();//输出栈顶元素 s.pop();//栈顶元素出栈 while(!s.empty()) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;s.top();//循环输出栈顶元素 s.pop();//栈顶元素出栈 &#125; return 0;&#125; getchar()函数作用：getchar()是到缓冲区读取第一个字符首先,从键盘输入许多字符,最后回车后,所有字符包括回车放到缓冲区这时才开始循环执行getchar(),读入一个字符判断是否回车,不是就继续读,是回车就退出循环(之所以说是顺序接受一行字符,是因为它取的始终是缓冲区中第一个字符,每取一个缓冲区的字符少一个,也就是顺序读取了) 方法二：vactor12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;int main ()&#123; char c; vector&lt;string&gt; v;//相当于string v[]，数组长度不定 string str; while(cin&gt;&gt;str) &#123; v.insert(v.begin(),str);//向容器v中存入str字符串 if((c=getchar())==&apos;\\n&apos;) break; &#125; vector&lt;string&gt;::iterator i=v.begin(),end=v.end();//i指向v的首地址，区间是到最后一个元素 for(int j=v.size();j&gt;0;j--) &#123; cout&lt;&lt;*i;//输出i指针指向的内容 if(j!=1) cout&lt;&lt;&quot; &quot;; i++; &#125; return 0;&#125; vector(向量)C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的. 用法: 文件包含:首先在程序开头处加上#include (vector)以包含所需要的类文件vector还有一定要加上using namespace std; 变量声明:2.1 例:声明一个int向量以替代一维的数组:vector (int) a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。2.2 例:用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector (int *) a.同理想用向量代替三维数组也是一样,vector (int**)a;再往上面依此类推. 具体的用法以及函数调用: push_back 在数组的最后添加一个数据 pop_back 去掉数组的最后一个数据 at 得到编号位置的数据 begin 得到数组头的指针 end 得到数组的最后一个单元+1的指针 front 得到数组头的引用 back 得到数组的最后一个单元的引用 max_size 得到vector最大可以是多大 capacity 当前vector分配的大小 size 当前使用数据的大小 resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 reserve 改变当前vecotr所分配空间的大小 erase 删除指针指向的数据项 clear 清空当前的vector rend 将vector反转构的结束指针返回(其实就是原来的begin-1) empty 判断vector是否为空 swap 与另一个vector交换数据 详细的函数实现功能：其中vector c. c.clear() 移除容器中所有数据。 c.empty() 判断容器是否为空。 c.erase(pos) 删除pos位置的数据 c.erase(beg,end) 删除[beg,end)区间的数据 c.front() 传回第一个数据。 c.insert(pos,elem) 在pos位置插入一个elem拷贝 c.pop_back() 删除最后一个数据。 c.push_back(elem) 在尾部加入一个数据。 c.resize(num) 重新设置该容器的大小 c.size() 回容器中实际数据的个数。 c.begin() 返回指向容器第一个元素的迭代器 c.end() 返回指向容器最后一个元素的迭代器 iteratoriterator是C++标准库（STL）中的迭代器可以把它理解成类似指针的东西~当然，只是用处差不多，使用方式和声明方式可是完全不同.","categories":[],"tags":[]},{"title":"每日一题 1008+pwn学习","slug":"每日一题1008","date":"2019-03-31T13:02:45.449Z","updated":"2019-03-31T13:03:40.801Z","comments":true,"path":"2019/03/31/每日一题1008/","link":"","permalink":"https://hanqd.github.io/2019/03/31/每日一题1008/","excerpt":"1008 数组元素循环右移问题题目描述一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移","text":"1008 数组元素循环右移问题题目描述一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0 A1⋯AN−1）变换为（AN−M ⋯AN−1 A0 A1 ⋯AN−M−1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 题目分析方法一：可以直接在输入时改变输入顺序方法二：用数据结构中的链表中的reverse函数，进行反转注意：这里有m&gt;n的情况，需要对m进行处理，m=m%n，这样数组才不会出错。 C++代码方法一：1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int a[101]; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&gt;n) &#123; m=m%n; &#125; for(int i=m;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n-1;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;a[n-1]; return 0;&#125; 方法二：1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int *p=new int[n];//分配一块长度为n的内存，指针p指向这个数组的首址 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i]; &#125; m=m%n; reverse(p,p+n-m);//前n-m个数反转，由1 2 3 4-&gt;4 3 2 1 reverse(p+n-m,p+n);//后面的数反转，由5 6 -&gt;6 5 reverse(p,p+n);//n个数全反转 4 3 2 1 6 5 -&gt;5 6 1 2 3 4 for(int i=0;i&lt;n-1;i++) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;p[n-1]; return 0;&#125; pwn学习从网上找了CTF关于pwn的解题类型，看了一些大佬的博客，对Ubuntu配置pwn的环境，可是！！各种包都按不上，更新源也出错，找了好多大学的替换源，也还是出错。。。。。明天再弄！","categories":[],"tags":[]},{"title":"每日一题 1007+Misc Another 01Game","slug":"每日一题","date":"2019-03-30T13:53:16.208Z","updated":"2019-03-30T13:55:49.572Z","comments":true,"path":"2019/03/30/每日一题/","link":"","permalink":"https://hanqd.github.io/2019/03/30/每日一题/","excerpt":"Another 01Game题目描述题目给了一个txt文件，里边只有01串。","text":"Another 01Game题目描述题目给了一个txt文件，里边只有01串。 解题思路题目给了思路：0和1的数量很关键，首先统计0和1的数量：1369.0/7 = 195.571428571428581369.0/8 = 171.1251369.0 ** 0.5 = 37.01369不是7和8的倍数，说明很可能和ASCII没关系。1369 是 37 的平方，说明可以由0和1正好组成一个正方形（二维码，QR code）。可以使用Python、MATLAB 等编程生成图片。扫描得到 另一个01字符串。统计字符串长度，可以当作 ASCII 编程解出 flag。 解题脚本12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonimport qrcodeqr = qrcode.QRCode( version = 7, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=4)qr.add_data('''0000000111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110''')qr.make(fit=True)img = qr.make_image()img.save(\"test.png\") 扫码还是得到01字符串，有189个01，根据题目提示，每7个一组，前面加0，用ASCLL码解码即可。注意：flag中0和O的输入！！！ 1007 素数对猜想题目描述让我们定义dn为：dn=pn+1−pn，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N(&lt;10^5)，请计算不超过N的满足猜想的素数对的个数。 输入格式输入在一行给出正整数N。 输出格式在一行中输出不超过N的满足猜想的素数对的个数。 题目分析算法很简单，就是先判断是否是素数，在相邻的两个数相减，为2则个数加1. C++代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int count=0; int a=2,b=3; for(int i=5;i&lt;=n;i++) &#123; bool t=true; for(int j=2;j&lt;=sqrt(i);j++) &#123; if(i%j==0) &#123; t=false; break; &#125; &#125; if(t) &#123; a=b; b=i; if((b-a)==2) count++; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"每日一题 1006","slug":"每日一题1006","date":"2019-03-29T02:35:28.127Z","updated":"2019-03-29T02:37:13.602Z","comments":true,"path":"2019/03/29/每日一题1006/","link":"","permalink":"https://hanqd.github.io/2019/03/29/每日一题1006/","excerpt":"1006 换个格式输出整数题目描述让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。","text":"1006 换个格式输出整数题目描述让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式每个测试用例的输出占一行，用规定的格式输出 n。 题目分析这是一道水题，分别用三个变量记录个、十、百位的数字，再分别输出即可。 C++代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int b,s,g; b=n/100; s=(n/10)%10; g=n%10; for(int i=0;i&lt;b;i++) &#123; cout&lt;&lt;\"B\"; &#125; for(int i=0;i&lt;s;i++) &#123; cout&lt;&lt;\"S\"; &#125; for(int i=1;i&lt;=g;i++) &#123; cout&lt;&lt;i; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Misc：Forensics2（流量分析题）","slug":"Misc Forensics2","date":"2019-03-28T12:37:55.193Z","updated":"2019-03-28T12:38:57.870Z","comments":true,"path":"2019/03/28/Misc Forensics2/","link":"","permalink":"https://hanqd.github.io/2019/03/28/Misc Forensics2/","excerpt":"Forensics2题目描述题目给了一个.pcap文件，给了一句提示：是关于文件的。","text":"Forensics2题目描述题目给了一个.pcap文件，给了一句提示：是关于文件的。 题目分析 用wireshark软件打开文件，发现有很多协议，之前学的网络的知识也忘得差不多了。。。。决定先了解一下各个协议的功能。 ICMP：ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。在网络层。 ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。在网络层。 TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。在运输层。 SSH：SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过使用SSH，可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。 NFS：NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。在应用层 portmap端口映射是一个服务器，将RPC程序号转换为DARPA的协议端口号，在使用RPC调用时它必须运行。portmap进程的主要功能是把RPC程序号转化为Internet的端口号。 mount在Windows系统下的含义是：挂载文件到一个虚拟盘或一个虚拟文件夹中，通过访问这个虚拟盘或文件夹使用整个文件。 根据上述协议的功能和定义，猜测要找的文件在NFS协议共享的资源中，运用了SSH协议进行了加密。 对NFS协议进行过滤，如下图，找到flag.txt.gz，是一个压缩包形式。 在这条协议附件逐个分析每条协议传输的信息，最后在write那条中找到了data. 在data处右键-》显示分组字节-》选择压缩，即可得到flag。","categories":[],"tags":[]},{"title":"每日一题 1005","slug":"每日一题1005","date":"2019-03-28T07:28:08.741Z","updated":"2019-03-28T07:29:30.716Z","comments":true,"path":"2019/03/28/每日一题1005/","link":"","permalink":"https://hanqd.github.io/2019/03/28/每日一题1005/","excerpt":"1005 继续(3n+1)猜想题目描述卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。","text":"1005 继续(3n+1)猜想题目描述卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 题目分析输入样例：63 5 6 7 8 11输出样例：7 6根据输入和输出样例，可以看出，在验证3时，需要计算5、8、4、2，那么这四个数被3覆盖了，就不是关键数。6需要计算11，那么11不是关键数，6没有被输入的数覆盖，所以6是关键数。这道题就是输出在输入的数的计算过程中没有出现过的数。思路：把输入的值当做数组下标，这个以输入值作为下标的数组记录这个值出现的次数，在计算过程中没出现过，数组值设为1，出现过，数组值设为2。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n]; int xiabiao[101]=&#123;0&#125;; int keynum[100001]=&#123;0&#125;; int count=0,temp; //输入n个数 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; int m=a[i]; //下标=数组值 if(xiabiao[m]==2) &#123; continue;//数组值出现过，即被某个数所覆盖 &#125; else xiabiao[m]=1;//没出现过的置1 while(m!=1) &#123; if(m%2==0) &#123; m=m/2; xiabiao[m]=2; &#125; else &#123; m=(m*3+1)/2; xiabiao[m]=2; &#125; &#125; &#125; //把xiabiao[]数组中值为1的存入另一个数组keynum[]，即所求的关键数 for(int i=0;i&lt;101;i++) &#123; if(xiabiao[i]==1) &#123; keynum[count]=i; count++; &#125; &#125; //对关键字排序，降序 for(int i=0;i&lt;count;i++) &#123; for(int j=i+1;j&lt;count;j++) &#123; if(keynum[i]&lt;keynum[j]) &#123; temp=keynum[i]; keynum[i]=keynum[j]; keynum[j]=temp; &#125; &#125; &#125; for(int k=0;k&lt;count-1;k++) &#123; cout&lt;&lt;keynum[k]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;keynum[count-1]; return 0;&#125;","categories":[],"tags":[]},{"title":"CTF逆向reverse：Reverse sign in","slug":"reverse1","date":"2019-03-28T02:52:16.969Z","updated":"2019-03-28T02:57:29.140Z","comments":true,"path":"2019/03/28/reverse1/","link":"","permalink":"https://hanqd.github.io/2019/03/28/reverse1/","excerpt":"题目Reverse sign in题目描述题目中只给了一个rev1文件，其他的没有了。","text":"题目Reverse sign in题目描述题目中只给了一个rev1文件，其他的没有了。 题目分析 知道是个逆向题目，所以直接用ida打开该文件，Fn+F5反编译为c伪代码，得到如下图，知道flag就在sub_400686函数中。 查看sub_400686函数伪代码，如下 找到byte_400818数据，即为数组中的32个值 (char)(*(_BYTE *)(i + a1)在C语言中，内存地址也是用整数int表示（32bit）。因此，(BYTE *)(i+a1) 表示把整数(i+a1)强制转换为BYTE型数值的地址。 char *(i+a1) 即i+a1指向一个字符串常量 ^是在程序中是异或运算符号，即长度为32的数组与i进行异或运算 C++代码12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int b[]=&#123;0x66,0x6D, 0x63, 0x64, 0x7F, 0x3C, 0x36, 0x72, 0x57, 0x42, 0x64, 0x3B, 0x7B, 0x52, 0x7C, 0x3C, 0x66, 0x54, 0x60,0x60, 0x27, 0x4A, 0x49, 0x7F, 0x71, 0x58, 0x52, 0x72, 0x7D, 0x75, 0x2A, 0x62&#125;; char a[33]; for(int i=0;i&lt;=31;i++) &#123; a[i]= b[i]^i; &#125; for(int j=0;j&lt;=31;j++) &#123; cout&lt;&lt;a[j]; &#125; cout&lt;&lt;endl; return 0;&#125; 得到flag，注意：最后那个是两个_，输入时只输了一个，试了两遍！！！要细心啊~~~","categories":[],"tags":[]},{"title":"每日一题 1004","slug":"每日一题1004","date":"2019-03-27T03:00:27.982Z","updated":"2019-03-27T03:01:42.623Z","comments":true,"path":"2019/03/27/每日一题1004/","link":"","permalink":"https://hanqd.github.io/2019/03/27/每日一题1004/","excerpt":"1004 成绩排名题目描述读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。","text":"1004 成绩排名题目描述读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 … … …第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 题目解析：只需找到成绩最高和最低的学生，在和其学号和姓名对应起来即可。 C++代码：代码一：使用结构体1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; //定义一个名字为student的结构体，有三个成员 struct student &#123; char a[11]; char b[11]; int grade; &#125;; //定义三个变量，结构体类型，其中s是所有学生，max是最大值，min是标记最小值的 student s,max,min; int n; cin&gt;&gt;n; cin&gt;&gt;s.a&gt;&gt;s.b&gt;&gt;s.grade; max=min=s; //先假设最大和最小值是第一个学生 //拿第一个的分数分别和其他n-1个学生相比 for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;s.a&gt;&gt;s.b&gt;&gt;s.grade; if(s.grade&gt;max.grade) max=s; if(s.grade&lt;min.grade) min=s; &#125; //max和min已经在上边的循环中指向最大最小的学生，在引用它们的成员即可 cout&lt;&lt;max.a&lt;&lt;&quot; &quot;&lt;&lt;max.b&lt;&lt;endl; cout&lt;&lt;min.a&lt;&lt;&quot; &quot;&lt;&lt;min.b&lt;&lt;endl; return 0;&#125; 代码二：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; string a[n+1],b[n+1]; int grade[n]; int max=0,min=100,s,k;//s,k分别记录最大值和最小值的下标 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;grade[i]; &#125; for(int j=0;j&lt;n;j++) &#123; if(grade[j]&gt;max) &#123; max=grade[j]; s=j; &#125; if(grade[j]&lt;min) &#123; min=grade[j]; k=j; &#125; &#125; cout&lt;&lt;a[s]&lt;&lt;&quot; &quot;&lt;&lt;b[s]&lt;&lt;endl; cout&lt;&lt;a[k]&lt;&lt;&quot; &quot;&lt;&lt;b[k]&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Web calculator","slug":"Web calculate","date":"2019-03-26T12:39:08.259Z","updated":"2019-03-26T12:45:33.555Z","comments":true,"path":"2019/03/26/Web calculate/","link":"","permalink":"https://hanqd.github.io/2019/03/26/Web calculate/","excerpt":"Calculator题目描述","text":"Calculator题目描述 打开链接，网页如下 做题准备 安装requests库网址：http://cn.pythonrequests.org/zh_CN/latest/user/install.html#install我是Windows系统，选择安装的压缩包，解压缩后，把整个文件夹复制到Python的Lib目录下即可。 requests库的使用 http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#url 题目分析要用1.5s计算出结果，并且每次刷新calculator，算数表达式都会变，那么按照平常的计算方式肯定是行不通的，根据题目提示，可以用requests库来解决，要解决的问题： 怎样从服务器那获得算术表达式，计算出结果？ 怎样把计算出的结果提交给服务器？ 让服务器知道获取算式和提交结果的是一个人？ 解题步骤 问题1：需要爬取网页信息，用正则表达式。（导入re模块）Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 问题2：requests里的get传递 URL 参数你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么可以使用如下代码： 12payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get(\"http://httpbin.org/get\", params=payload) 问题3：使用session会话session是一次浏览器和服务器的会话对象，session也是缓存，是内容，是块数据。因为我们访问网页使用的HTTP协议是无状态的，没有任何关系，快速的。所以我们如果想要关联客户的信息就需要一种办法能够把客户的信息联系在一起，这个方法就是cookie。但是cookie是把信息储存在用户本地，它在一个域名下是全局的。不安全又很容易的被修改。所以session就出现了，它储存在服务器上，通过它关联同一个用户的信息，这样用户在访问不同的页面的时候我们就知道对方是同一个人，而不需要每次无状态的访问都需要用户登录/关联了。 脚本代码1234567891011import requestsimport res = requests.Session()t = s.get('http://123.207.149.64:23331/calculator/')print(t.text)value = re.compile(r'&lt;form action=\"\" method=\"GET\"&gt;&lt;span id=\"exp\"&gt;(.*?)&lt;/span&gt;')n = re.findall(value, t.text, re.S | re.M)print('result:\\n\\n%s=%d\\n' % (n, eval(n)))ans = eval(n)f = t.get('http://123.207.149.64:23331/calculator/', params=&#123;'answer': ans&#125;)print(f.text) 结果运行时出现错误：AttributeError: module ‘requests’ has no attribute ‘session’，查了安装的requests库，里边有session模块，但就是运行说没有！！查了好多原因，也重装了requests，还是不行，做这个题用了太长时间了，今天脑子被他弄得晕晕的，决定明天在弄。","categories":[],"tags":[]},{"title":"每日一题 1003","slug":"每日一题1003","date":"2019-03-26T03:17:36.805Z","updated":"2019-03-26T04:01:20.619Z","comments":true,"path":"2019/03/26/每日一题1003/","link":"","permalink":"https://hanqd.github.io/2019/03/26/每日一题1003/","excerpt":"1003 我要通过题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：","text":"1003 我要通过题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 题目分析 条件1：字符串仅有P、A、T这三个字符，包括其他字符则答案错误； 条件2：xPATx形式的字符串正确，其中x为空字符串或者A，例如：PAT、APATA、AAPATAA，要求P左边的A的个数和T右边的个数一样，并且P和T仅有一个； 条件3：aPbTc是正确的，则aPbATca也是正确的，其中a,b,c为空字符串或者A，例如：APATA、APAATAA、AAPATAA、AAPAATAAAA根据P左边，T右边和P、T中间的A的个数来看，可找到规律，即left*mid=right,即答案正确。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; string a; int len=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; //p是P的个数，t是T的个数，left是P左边A的个数，mid,right分别是对应位置A的个数 int p=0,t=0,left=0,mid=0,right=0; len=a.length(); for(int j=0;j&lt;len;j++) &#123; //字符串为A，并且前面没出现过P和T，P左边A的个数 if(a[j]=='A'&amp;&amp;p==0&amp;&amp;t==0) &#123; left++; continue; &#125; //P的个数 if(a[j]=='P') &#123; p++; continue; &#125; //中间A的个数，前面出现了P且个数为1，前面不能出现T if(a[j]=='A'&amp;&amp;p==1&amp;&amp;t==0) &#123; mid++; continue; &#125; //T的个数，并且前边P和T中间出现了A，防止出现PT情况 if(a[j]=='T'&amp;&amp;mid&gt;=1) &#123; t++; continue; &#125; //右边A的个数，前边出现了P和T，个数为1 if(a[j]=='A'&amp;&amp;p==1&amp;&amp;t==1) &#123; right++; continue; &#125; else &#123; break; &#125; &#125; //判断条件：P和T的个数为1，A的个数：左边乘中间等于右边，输出YES if(p==1&amp;&amp;t==1&amp;&amp;(left*mid==right)) &#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125; &#125; return 0; &#125;","categories":[],"tags":[]},{"title":"Python笔记——数据类型（整数、浮点数、数据类型转换）","slug":"Python数据类型（整数、浮点数、数据类型转换）","date":"2019-03-18T08:38:50.653Z","updated":"2019-03-18T09:06:28.161Z","comments":true,"path":"2019/03/18/Python数据类型（整数、浮点数、数据类型转换）/","link":"","permalink":"https://hanqd.github.io/2019/03/18/Python数据类型（整数、浮点数、数据类型转换）/","excerpt":"今天安装了pycharm,界面很好看，是一款好用的编译器。继续学习Python！","text":"今天安装了pycharm,界面很好看，是一款好用的编译器。继续学习Python！ 整数（int）&emsp; 整数包括正整数、负整数和零。Python中的整数范围是很大的。Python中整数还可以以几种不同的进制进行书写。0+“进制标志”+数字代表不同进制的数，进制标志有以下几种： 0o[0O]数字 表示八进制整数（例如：0o24/0O24） 0x[0X]数字 表示十六进制整数（例如：0x3F/0X3F） 0b[0B]数字 表示二进制整数（例如：0b101/0B101） 不带进制标志的为十进制数。&emsp; 注意：每种进制开头数字都是0；八进制的数字0后是小写字母o或大写字母O；但十进制不得以数字0开头书写；每种进制书写时数码不得超过进制规定的数码范围。整数运算符 运算符 描述 ** 乘方运算符 * 乘法运算符 / 除法运算符 // 整除运算符 % 取余运算符 + 加法运算符 - 减法运算符 &#124; 位或 ^ 位异或 &amp; 位与 &lt;&lt; 左移运算 &gt;&gt; 右移运算 “//”运算符就是取商而丢弃余数，比如:14//4=3|、^、&amp;、&lt;&lt;、&gt;&gt;运算符都是位运算符，要依据二进制形式进行运算。 运算符优先级从高到低排列如下： ** *、/、% +、- |、^、&amp;、&lt;&lt;、&gt;&gt; 在同一个式子中，可以使用括号来修改运算符的优先级，即括号具有最高优先级。不必强记运算符的优先级，在没有把握的情况下可以运用括号。注意：“/”运算符的运算结果为浮点数，即时是两个整数相除。 浮点数（float）浮点数就是常用的带小数的数，当然整数部分也可以为零。浮点数的书写除了一般形式（如3.14）外，还有以下几种表示方法： 19. 小数部分为零，可以不写； .098 整数部分为零，可以不写； -2e3 科学计数法，表示-2*10^3 类型转换Python中常用的数据类型的相互转换，所使用函数如下： str(object=’’) 可以将整数和浮点数转换为字符串，默认建立空字符串 int(x,base=10) 将数字字符串或数值转换为整数（base表示进制） float(x) 将字符串或数值转换为浮点数 此外：str()可以创建一个空字符串，int()也可以建立一个默认值为0的整数，float()可以建立一个默认值为0.0的浮点数。【实例】注意：将字符串形式的数值转换为整数时，其中只能包含数字。input()函数接受键盘输入时，无论输入的是整数、浮点数还是字符串，Python得到的都是字符串，那么当需要整数或浮点数时都要进行类型转换。","categories":[],"tags":[]},{"title":"Python笔记——数据类型（字符串）","slug":"Python数据类型（字符串）","date":"2019-03-17T14:32:02.464Z","updated":"2019-03-17T14:56:50.802Z","comments":true,"path":"2019/03/17/Python数据类型（字符串）/","link":"","permalink":"https://hanqd.github.io/2019/03/17/Python数据类型（字符串）/","excerpt":"字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。","text":"字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。 Python的简单数据类型字符串 字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。 注意：单引号和双引号都是英文字符中的符号。 三种表示方法的区别和联系： 单引号字符串与双引号字符串本质上是相同的。但是单引号字符串里边不允许再出现单引号，例如：’aa’ss’cc’，这种是错误的，但是可以使用转义字符来输出’：’aaa”ss”aa’，这样正确，同理，双引号字符串也是，双引号里不能再出现双引号，但可以用转义字符。 三引号字符串可以由多行组成，单引号或双引号不行，当需要使用大段多行的字符串行就使用它。1234'''This is a function.Return a tuple.''' 转义字符串 \\n 换行符 \\t 制表符（Tab） \\r 回车（Enter） \\ “\\”字符 \\’ 单引号字符串中的单引号 \\” 双引号里的双引号 字符串运算“+”：连接字符串乘号 ：单字符串的多次连接‘aaa’+’bbb’ ——&gt;’aaabbb’“python”*3 ——&gt;python python python 字符串处理函数常见的字符串函数 string.capitalize() 将字符串的第一个字母大写 string.count() 获得字符串中某一子字符串的数目 string.find() 获得字符串中某一子字符串的起始位置，无则返回-1 string.isalnum() 检测字符串是仅包含0-9A-Za-z string.isalpha() 检测字符串是仅包含A-Za-z string.isdigit() 检测字符串是仅包含数字 string.islower() 检测字符串是否均为小写字母 string.isspace() 检测字符串中所有字符是否均为空白字符 string.istitle() 检测字符串中的单词是否为首字母大写 string.isupper() 检测字符串是否均为大写字母 string.join() 连接字符串 string.lower() 将字符串全部转换为小写 string.split() 分割字符串 string.swapcase() 将字符串中大写字母转换为小写，小写字母转换为大写 string.title() 将字符串中的单词首字母大写 string.upper() 将字符串中的全部字母转换为大写 len(string) 获取字符串长度 其中split()函数返回以指定的字符将字符串分割成为列表形式并返回，但并不改变原字符串，原型如下：split([sep[,maxsplit]]) sep：可选参数，指定分割的字符，默认为空格 maxsplit：可选参数，分割次数 join()函数将原字符串插入参数字符串中的每两个字符之间。如果参数字符串中只有一个字符，那么返回参数字符串。同样，join()并不改变原字符串，只是返回一个新的字符串。","categories":[],"tags":[]},{"title":"你好，hexo","slug":"你好，hexo","date":"2019-03-15T08:45:25.000Z","updated":"2019-03-15T08:45:25.929Z","comments":true,"path":"2019/03/15/你好，hexo/","link":"","permalink":"https://hanqd.github.io/2019/03/15/你好，hexo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T03:01:22.322Z","updated":"2019-03-16T04:18:31.716Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"https://hanqd.github.io/2019/03/15/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}